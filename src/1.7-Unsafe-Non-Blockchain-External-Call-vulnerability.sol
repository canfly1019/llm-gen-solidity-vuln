pragma solidity >=0.8.0;

// 漏洞名稱: Unsafe Non-Blockchain External Call
// 描述: 合約允許呼叫外部合約以執行非區塊鏈的外部指令，這可能導致不同節點接收到不同結果，進而產生不可預期的行為。

// Vulnerable 合約，內部有一個狀態變數 externalContract，攻擊者可以隨意指定不可信的外部合約，
// 並利用 executeExternalCall 函式觸發外部呼叫，執行攻擊者控制的邏輯。

contract VulnerableExternalCall {
    // 漏洞重點：外部呼叫合約地址（不受信任的來源）
    address public externalContract; // 漏洞：攻擊者可設置成惡意合約地址

    // 缺乏身分驗證機制，任何人都可以設定 externalContract
    function setExternalContract(address _contract) public {
        externalContract = _contract; // 漏洞：未檢查呼叫者身份
    }

    // 執行非區塊鏈外部呼叫，可能導致節點間結果不一致
    function executeExternalCall(string calldata command) public returns (bytes memory) {
        // 漏洞所在：使用低階 call 呼叫不受信任的外部合約，執行任意指令
        (bool success, bytes memory data) = externalContract.call(abi.encodeWithSignature("executeCommand(string)", command));
        require(success, "External call failed");
        return data;
    }

    // fallback function 用以接收 Ether
    receive() external payable {}
}

// 攻擊者部署的惡意合約，用來模擬攻擊
contract AttackContract {
    // 此函式將被 VulnerableExternalCall 呼叫
    function executeCommand(string calldata command) external returns (bytes memory) {
        // 攻擊邏輯：回傳惡意資料或執行其他未經授權的操作
        // 例如，直接回應攻擊者選擇的訊息
        return abi.encodePacked("Attack executed: ", command);
    }
}

/* 攻擊步驟說明（繁體中文）：
   1. 攻擊者首先部署 AttackContract，取得其合約地址。
   2. 攻擊者呼叫 VulnerableExternalCall 合約中的 setExternalContract 函式，將 externalContract 設定為 AttackContract 的地址。
   3. 當任何使用者或系統呼叫 executeExternalCall 並傳入 command 參數時，實際上會觸發 AttackContract 中的 executeCommand 函式，
      從而回傳由攻擊者所控制的結果，造成非預期的行為。
   因為這個外部呼叫結果可能在不同節點上不一致，進而導致資料依賴的判定錯誤和安全風險。
*/