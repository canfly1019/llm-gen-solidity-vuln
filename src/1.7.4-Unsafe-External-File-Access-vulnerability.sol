// Solidity 0.8.0版本
// 本範例展示了一個潛在的 Unsafe External File Access 漏洞，
// 漏洞重點在於合約提供了一個更新外部檔案內容的函式 updateFileData，
// 並未對呼叫者進行任何權限驗證，這使得任何人都可以修改內部儲存的 fileData，
// 進而導致不同節點在讀取此外部文件內容時可能得到不一致的結果。

pragma solidity ^0.8.0;

// 漏洞合約：允許任意外部使用者更新 fileData，造成節點間資料不一致
contract UnsafeFileAccessor {
    // 漏洞：未經驗證的外部檔案內容存取
    string public fileData; // 此變數存放外部檔案的資料，攻擊者可任意修改

    // 漏洞函式：直接更新 fileData，未限制調用者身份
    function updateFileData(string calldata _fileData) external {
        // 攻擊點：無權限檢查，任何人皆可調用並改寫檔案內容
        fileData = _fileData;
    }

    // 根據檔案資料進行決策，因不同節點讀取可能不一致而產生問題
    function processData() external view returns (string memory) {
        if (keccak256(bytes(fileData)) == keccak256(bytes("approved"))) {
            return "File approved";
        } else {
            return "File not approved";
        }
    }
}

// 攻擊合約：示範如何利用 updateFileData 漏洞攻擊 UnsafeFileAccessor 合約
contract AttackUnsafeFileAccessor {
    UnsafeFileAccessor public vulnerable;

    // 部署前需將目標合約地址傳入
    constructor(UnsafeFileAccessor _vulnerable) {
        vulnerable = _vulnerable;
    }

    // 攻擊函式：利用漏洞函式更新檔案內容，破壞一致性
    function attack() external {
        // 攻擊者將檔案內容更新為非預期資料，造成 processData 返回不同結果
        vulnerable.updateFileData("malicious file content");
    }
}

// 攻擊步驟補充說明：
// 1. 部署 UnsafeFileAccessor 合約。
// 2. 攻擊者部署 AttackUnsafeFileAccessor 合約，並傳入上述合約地址。
// 3. 攻擊者呼叫 attack()，更新檔案內容為惡意資料，此變更將影響所有依據 fileData 進行決策的節點。
// 注意：此漏洞與 Solidity 的版本無關，而是設計上允許不受限制的外部檔案存取導致的問題。
