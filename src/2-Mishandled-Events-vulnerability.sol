// SPDX-License-Identifier: UNLICENSED
// Solidity >=0.8.0
// 此漏洞為 Mishandled Events，主要問題在於使用 assert 來檢查使用者條件，當條件不符時，會消耗所有剩餘 gas，造成不必要的資源損失，並且不回傳錯誤訊息。
// 此範例合約中 withdraw 函式使用 assert 檢查，當使用者嘗試提領超過自己餘額時，assert 將觸發，雖然狀態改變會回復，但卻消耗掉所有剩餘 gas，造成攻擊者或誤用者資源的損失。

pragma solidity >=0.8.0;

contract VulnerableContract {
    // 狀態變數，紀錄各地址存款餘額
    mapping(address => uint256) public balances;

    // 事件記錄
    event Deposit(address indexed sender, uint256 amount);
    event Withdrawal(address indexed to, uint256 amount);

    // 使用者存款，並發出 Deposit 事件
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // 提領函式：漏洞在於使用 assert 來檢查餘額，不僅不回傳自訂錯誤訊息，
    // 當條件不成立時，會消耗所有剩餘 gas。
    function withdraw(uint256 _amount) public {
        // 漏洞重點：使用 assert 檢查條件 (應使用 require 替代)，
        // 當資料不符合條件時，所有剩餘 gas 被消耗，造成潛在資源浪費問題。
        assert(balances[msg.sender] >= _amount); // 漏洞：應改用 require
        
        balances[msg.sender] -= _amount;
        payable(msg.sender).transfer(_amount);
        emit Withdrawal(msg.sender, _amount);
    }

    // 正確實作接收 Ether 的函式
    receive() external payable {
        deposit();
    }
}

// 攻擊合約示範
// 說明：攻擊合約嘗試呼叫 VulnerableContract 的 withdraw 函式，要求提領大於其存款的金額（例如 1 ether，此合約未曾存款），
// 觸發 assert，導致呼叫者消耗所有剩餘 gas，造成拒絕服務的攻擊效果。

contract Attack {
    VulnerableContract public target;

    // 修改：使用 payable address 進行顯式轉換以滿足編譯要求
    constructor(address _target) {
        target = VulnerableContract(payable(_target));
    }

    // 攻擊函式：試圖從 target 合約中提領超過自己存款的金額
    function attack() public {
        // 不先 deposit 任何 Ether，由於 balances[msg.sender] 為 0，故 withdraw(1 ether) 會觸發 assert
        target.withdraw(1 ether);
    }
}

/*
部署與攻擊步驟:
1. 部署 VulnerableContract 合約。
2. 部署 Attack 合約，並將 VulnerableContract 的地址傳入 Attack 的 constructor。
3. 呼叫 Attack 合約的 attack() 函式，此時因為呼叫者沒有存款，withdraw() 中的 assert(balances[msg.sender] >= _amount) 會失敗，
   並消耗攻擊合約呼叫的所有剩餘 gas，從而造成拒絕服務的效果。
*/