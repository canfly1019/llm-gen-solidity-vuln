pragma solidity >=0.8.0;

// 此介面定義了 ERC20 的簡化函數（只包含 transfer 與 balanceOf）
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

// ---------------------------------------------------------------------------
// VulnerableTokenHandler 合約中 withdraw 函式存在漏洞：
// 沒有檢查 token.transfer 回傳的布林值，導致在轉帳失敗時不會回復，進而可能讓使用者誤以為交易成功，或依此漏洞進行攻擊。
// ---------------------------------------------------------------------------
contract VulnerableTokenHandler {
    IERC20 public token; // 漏洞所在：token 變數可被設定為外部任意合約，可能會導致不符合標準的行為

    constructor(address _token) {
        token = IERC20(_token);
    }

    // withdraw 函式存在漏洞：未檢查 transfer 回傳的值
    function withdraw(uint256 amount) external {
        // 漏洞重點：未對 token.transfer 的回傳值進行檢查，若 transfer 失敗，將不會 revert
        token.transfer(msg.sender, amount);
    }
}

// 以下是一個最小可行攻擊範例，透過部署 MaliciousToken ，
// 此合約模擬一個不符合 ERC20 標準的 token，當呼叫 transfer 時，永遠回傳 false
// 攻擊步驟：
// 1. 攻擊者部署 MaliciousToken
// 2. 攻擊者部署 VulnerableTokenHandler，並傳入 MaliciousToken 的地址
// 3. 當使用者呼叫 withdraw 時，token.transfer 會回傳 false，但合約不予檢查，讓使用者以為轉帳成功

contract MaliciousToken is IERC20 {
    mapping(address => uint256) public balances;

    constructor() {
        // 為方便展示，部署者取得大量 token
        balances[msg.sender] = 1000000 ether;
    }

    // transfer 永遠回傳 false，模擬不正確的實作
    function transfer(address recipient, uint256 amount) external override returns (bool) {
        // 此處故意不扣除餘額也不新增 recipient 的餘額
        // 攻擊者藉由此漏洞，使用者不會因 transfer 失敗而 revert
        return false;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }
}

// 攻擊說明（繁體中文）：
// 當使用者透過 VulnerableTokenHandler 的 withdraw 函式取款時，實際上呼叫的是 MaliciousToken 的 transfer
// 因為 transfer 永遠會回傳 false，但漏洞合約未檢查回傳值，使用者可能誤以為提款成功，進而觸發後續錯誤操作，可能進行詐騙或擾亂系統行為。