// VulnerableToken.sol
// 此版本展示了 Missing Thrown Exception 漏洞，即在轉帳條件不成立時，僅回傳 false 而未拋出例外，造成呼叫者可能無法正確偵測錯誤狀況。
// 注意：solidity >=0.8.0 會自動檢查 underflow/overflow，但本範例為示意，仍保留原 safe math 函式。

pragma solidity >=0.8.0;

contract VulnerableToken {
    mapping(address => uint256) public balances; // 狀態變數：用以記錄每個地址的 token 餘額
    
    // ERC20 的 Transfer 事件
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    // 建構子，將初始餘額全部給部署者
    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }
    
    // 漏洞點：transfer 函式在餘額不足或 value 不合法時僅回傳 false，未拋出例外
    function transfer(address to, uint256 value) public returns(bool success) {
        if(balances[msg.sender] >= value && value > 0) {
            // 使用不會拋出例外的安全數學運算（注：solidity >=0.8.0 內建 overflow/underflow 檢查）
            // 以下兩行為漏洞實作重點，請注意標示：
            // Vulnerable: 未在失敗時 revert，僅回傳 false
            balances[msg.sender] = substractSafely(balances[msg.sender], value);
            balances[to] = addSafely(balances[to], value);
            emit Transfer(msg.sender, to, value);
            return true;
        } else {
            // 漏洞部份：當條件不成立時僅設定 success = false，未拋出錯誤
            return false;
        }
    }
    
    // 範例 safe math 函式（對 underflow/overflow，solidity >=0.8.0 會自動處理，但此處保留以示意原始邏輯）
    function substractSafely(uint256 a, uint256 b) internal pure returns(uint256) {
        return a - b;
    }
    
    function addSafely(uint256 a, uint256 b) internal pure returns(uint256) {
        return a + b;
    }
}

// 攻擊合約：AttackMissingThrownException
// 此合約示範攻擊者如何利用缺少 thrown exception 的漏洞
// 攻擊者在呼叫 transfer 時若餘額不足，根據漏洞版本，transfer 僅回傳 false，交易不會 revert，可能導致呼叫者依賴回傳值而出錯。

contract AttackMissingThrownException {
    VulnerableToken public token;

    // 部署前需提供 VulnerableToken 合約地址
    constructor(address tokenAddress) {
        token = VulnerableToken(tokenAddress);
    }

    // 攻擊示例：試圖進行超額轉帳，但因穩健性的缺失，轉帳僅回傳 false，不拋出例外
    function attackTransferWithInsufficientBalance() public returns (bool) {
        // 假設攻擊者的 token 餘額不足，因此 transfer 會回傳 false，但不會中斷交易
        bool result = token.transfer(address(this), 1000);
        // 呼叫者可能會忽略該回傳值而認為交易已成功完成，進而產生邏輯錯誤
        return result;
    }
}
