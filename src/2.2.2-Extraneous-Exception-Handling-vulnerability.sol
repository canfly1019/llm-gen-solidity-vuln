// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
說明：
這個漏洞為 Extraneous Exception Handling，問題在於 transferFrom 函數內額外使用了 require(_value < 20 wei) ，這並非規範所建議的處理方式，會造成 token transfer 功能不符合預期。

攻擊手法說明：
1. 正常使用者預期 transferFrom 能夠按照 token 規範正常轉帳；
2. 攻擊者可以藉由呼叫 transferFrom 並傳入大於或等於 20 wei 的值，故意觸發 require 條件，使得本來應該成功的轉帳操作被強行 revert，從而導致資金不能正常流轉，甚至造成部分合約業務邏輯異常。

部署和攻擊步驟：
(1) 部署 VulnerableToken 合約；
(2) 用部署者 address 取得初始 balance；
(3) 攻擊者部署 AttackContract 並設定 VulnerableToken 地址；
(4) 攻擊者呼叫 AttackContract.attack()，此函數內傳入一個不合規的數值（例如 25 wei），觸發 require 使轉帳失敗。
*/

contract VulnerableToken {
    mapping(address => uint) public balances;
    
    // 初始化部署者擁有 1000 wei 的代幣
    constructor() {
        balances[msg.sender] = 1000;
    }
    
    // 存在問題的 transferFrom 函式，額外的 require 限制會導致符合規範的操作被拒絕
    function transferFrom(address _spender, uint _value) public returns (bool success) {
        // extraneous exception handling vulnerability 主要在此行
        require(_value < 20 wei, "value must be less than 20 wei");
        
        // 檢查呼叫者是否有足夠的餘額
        require(balances[msg.sender] >= _value, "Insufficient balance");
        
        balances[msg.sender] -= _value;
        balances[_spender] += _value;
        return true;
    }
    
    // 查詢餘額
    function getBalance(address account) public view returns (uint) {
        return balances[account];
    }
}

// 攻擊合約
contract AttackContract {
    VulnerableToken public vulnerableToken;
    
    // 初始化時設定被攻擊的 VulnerableToken 合約地址
    constructor(address _vulnerableTokenAddress) {
        vulnerableToken = VulnerableToken(_vulnerableTokenAddress);
    }
    
    // 攻擊函式，故意傳入大於或等於 20 wei 的值以觸發 extraneous require 條件失敗，導致轉帳失敗
    function attack() public {
        // 此處使用 25 wei ，觸發 require 條件，使轉帳 revert
        vulnerableToken.transferFrom(msg.sender, 25 wei);
    }
}
