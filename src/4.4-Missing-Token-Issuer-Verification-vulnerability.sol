pragma solidity ^0.8.0;

/*
VulnerableTicket 合約說明:
1. 漏洞名稱：Missing Token Issuer Verification
2. 漏洞描述：轉帳函式 transfer 沒有核對發送者是否為正確的 token 發行者，導致攻擊者可以利用該漏洞，在不支付票費的情況下，觸發 sponsor 獎勵的發放，進而獲取合約的全部餘額。

攻擊步驟：
1. 攻擊者部署或呼叫此合約，並充值合約一定金額作為獎金池。
2. 攻擊者呼叫 transfer 函式，由於缺少 token issuer 的驗證，會直接執行 runSponsor() ，將合約所有餘額轉給呼叫者。
*/

contract VulnerableTicket {
    // 模擬 token 發行者的地址，本應僅允許此地址觸發特定功能，但漏洞在於未正確驗證
    address public tokenIssuer;
    // 票券獎勵接收者，此範例中在 runSponsor 中直接把合約餘額發給呼叫者
    address public sponsor;

    // 建構子設定 tokenIssuer 與 sponsor
    constructor(address _tokenIssuer, address _sponsor) {
        tokenIssuer = _tokenIssuer;
        sponsor = _sponsor;
    }

    // 漏洞函式：transfer
    // 註：缺少 token issuer 的驗證，攻擊者可利用此漏洞
    function transfer() external payable {
        // 漏洞重點：未檢查 msg.sender 是否與 tokenIssuer 相符
        // 攻擊者可直接呼叫此函式來觸發獎勵發放
        runSponsor();
    }

    // 其他功能, 僅允許 tokenIssuer 或本合約調用
    function otherAction() external payable {
        require(msg.sender == tokenIssuer || msg.sender == address(this), "Not allowed");
        // 執行其他安全的操作
    }

    // runSponsor 函式，將合約餘額發放給呼叫者
    // 漏洞：由於缺少驗證，攻擊者可無票費要求下領取合約內所有資金
    function runSponsor() internal {
        // 傳送全額餘額給當前呼叫者
        payable(msg.sender).transfer(address(this).balance);
    }

    // 接收 Ether
    receive() external payable {}
}

/*
攻擊示例說明：
- 攻擊者只需向 VulnerableTicket 合約轉入少量 Ether 作為攻擊觸發時的票費（或甚至不需付費），然後呼叫 transfer()。
- 因為 transfer() 中沒有驗證 msg.sender，攻擊者會獲得合約內所有資金，而票費收取機制失效。
*/

// 攻擊者可以利用如下腳本進行攻擊（假設已部署 VulnerableTicket 合約）：
// VulnerableTicket vulnerable = VulnerableTicket(部署後的合約地址);
// vulnerable.transfer();
