pragma solidity >=0.8.0;

// 此合約示範 Wrong Function Modifier 的漏洞
// 漏洞重點：本來應用於外部呼叫的函式被標記為 public，可能導致不必要的內部呼叫進而增加 gas 費用
contract C {
    // 狀態變數 x，注意此處 x 被初始化為一串固定長度的 bytes
    bytes public x = "012345678901234567890123456789";

    // 漏洞：使用 public modifier 讓此函式既可以被內部呼叫也能被外部呼叫
    // 若設計上僅預期用於外部呼叫，應改用 external，可節省 gas
    function test() public returns (uint) {
        // 下面兩行修改 x 的內容，示意操作，並非真正之攻擊載體
        // 注意：這裡的寫法僅為示範，實際上 x.push() 返回新長度不能直接賦值，但保留原意
        x.push() = 0x01; // 漏洞重點：錯誤使用 public 造成不必要的內部資料拷貝
        x.push() = 0x02; // 同上
        return x.length;
    }
}

// 攻擊合約：模擬外部合約攻擊場景
// 攻擊說明：攻擊者可以從外部呼叫 test()，由於其被宣告為 public，可能被內部呼叫而消耗更多 gas，
// 在某些經濟情境下可能會被利用來達成 DoS 或資源耗盡（gas cost 增加），進而影響全網運作
contract Attack {
    C public target;

    // 部署 Attack 合約時，需指定目標合約 C 的地址
    constructor(address _target) {
        target = C(_target);
    }

    // 攻擊流程：由外部呼叫 attack()，此函式進而呼叫目標合約內的 test()
    function attack() public returns (uint) {
        // 進行攻擊：呼叫 vulnerable 合約中的 test 函式
        uint len = target.test();
        return len;
    }
}

/*
部署與攻擊步驟說明：
1. 部署合約 C (vulnerable 合約) 至區塊鏈上。
2. 使用 C 合約的地址部署 Attack 合約。
3. 呼叫 Attack 合約中的 attack() 函式，進而觸發 C 合約中的 test()。
   由於 test() 使用 public 修飾符，可被內部調用，資料在 memory 與 storage 間不必要的拷貝將消耗更多 gas。
*/