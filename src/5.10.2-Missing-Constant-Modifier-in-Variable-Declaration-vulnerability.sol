pragma solidity >=0.8.0;

// 以下程式碼中，變數 pi 與 FavorateNumber 未宣告為 constant，因而每次存取都會從 storage 讀取，導致消耗更多的 gas。

contract C1 {
    // 漏洞重點：這兩個變數應為 constant，但目前為 storage 變數，會增加不必要的 gas 費用
    uint pi = 314; // 應宣告為 constant
    uint FavorateNumber = 25; // 應宣告為 constant
    
    // 此函式每次呼叫都需從 storage 讀取數值
    function getNumbers() public view returns(uint) {
        return FavorateNumber * pi;
    }
}

contract C2 {
    // 漏洞重點：pi 應宣告為 constant
    uint pi = 314;

    function getPi() public view returns(uint) {
        return pi;
    }
}

// 攻擊合約：
// 雖然這個漏洞主要是 gas 優化問題，但攻擊者可以藉由在內部呼叫大量 getNumbers 或 getPi 方法，藉由不必要的 storage 存取增加交易的 gas 費用，進而進行惡意的 gas 消耗攻擊（例如在大量呼叫的情境下影響合約內部運算的效率）。
// 以下 Attack 合約示範如何呼叫上述合約來間接觀察 gas 消耗的不同（在部署或大量呼叫場景下會較顯著）。

interface IC1 {
    function getNumbers() external view returns(uint);
}

interface IC2 {
    function getPi() external view returns(uint);
}

contract Attack {
    IC1 public c1;
    IC2 public c2;

    // 部署 Attack 合約時需提供已部署 C1 與 C2 合約的地址
    constructor(address _c1, address _c2) {
        c1 = IC1(_c1);
        c2 = IC2(_c2);
    }

    // 攻擊示範：呼叫 getNumbers 與 getPi ，藉由多次呼叫累計較高的 gas 費用
    function attack() public view returns(uint, uint) {
        uint numberResult = c1.getNumbers();
        uint piResult = c2.getPi();
        // 此處的漏洞在於每次呼叫都從 storage 讀取常數，雖然數值不會改變但 gas 成本較高
        return (numberResult, piResult);
    }
}
