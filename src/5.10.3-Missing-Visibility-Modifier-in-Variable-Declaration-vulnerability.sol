pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

// 漏洞版本：缺少明確的可見性修飾符，導致部分狀態變數預設為 internal，可能在子合約中被利用存取敏感數據

contract TestStorageVulnerable {
    // 常數定義 (不需要指定可見性)
    uint constant constuint = 16;
    
    // 此 mapping 明確標示為 public，表示外部可讀取
    mapping (address => uint) public uints1;
    
    // 漏洞點：未指定 visibility，預設為 internal，未來可能導致不當使用
    mapping (address => DeviceData) structs1;
    
    // 漏洞點：未指定 visibility，預設為 internal
    uint[] uintarray;
    
    // 漏洞點：未指定 visibility，預設為 internal
    DeviceData[] deviceDataArray;
    
    // 定義裝置資料結構
    struct DeviceData {
        string deviceBrand;
        string deviceYear;
        string batteryWearLevel;
    }
    
    // 測試函式，用於儲存資料供後續測試
    function testStorage() public {
        // 使用正確 checksum 的地址
        address address1 = 0xbCcc714d56bc0da0fd33d96d2a87b680dD6D0DF6;
        address address2 = 0xaee905FdD3ED851e48d22059575b9F4245A82B04;
        
        // 賦值給公開 mapping
        uints1[address1] = 88;
        uints1[address2] = 99;
        
        // 建立新的裝置資料
        DeviceData memory dev1 = DeviceData("deviceBrand", "deviceYear", "wearLevel");
        // 儲存至未明確設為 private 的 mapping，存在內部存取風險
        structs1[address1] = dev1;
        
        // 推入數值至未明確設為 private 的陣列
        uintarray.push(8000);
        uintarray.push(9000);
        
        // 推入裝置資料
        deviceDataArray.push(dev1);
    }
}

// 攻擊合約：透過繼承直接存取 internal 變數，來進行資料觀察或進一步操作
contract AttackVulnerable is TestStorageVulnerable {
    function exploit() public view returns (uint arrayLength, uint deviceDataLength) {
        // 攻擊者可以存取原合約中未明確隱藏的內部狀態變數
        arrayLength = uintarray.length;         // 取得 uintarray 長度
        deviceDataLength = deviceDataArray.length; // 取得 deviceDataArray 長度
    }
}

/*
說明：
此漏洞主要由於部分狀態變數（如 uintarray 與 deviceDataArray）未明確設置為 private，
因此攻擊者可以透過繼承存取這些變數，進而了解或修改敏感資料。建議對所有非必要公開的狀態變數明確設置可見性。
*/