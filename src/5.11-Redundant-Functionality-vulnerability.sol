pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

// 漏洞合約：含有冗餘功能 (fallback) 的合約會因誤用而導致交易 revert，並增加維護上的難度。
// 此漏洞情境為：開發者同時存在 fallback 與 receive，但 fallback 含有缺陷且會 revert，
// 若使用者不小心發送非空 calldata 的交易，則錯誤路徑將會被觸發。

contract ExRedundantVulnerable {
    // 【漏洞重點】冗餘的 fallback 函數，當收到非空 calldata 時觸發並 revert
    fallback() external payable {
        revert("Vulnerable fallback: Do not use this function");
    }
    
    // 正確的接收 Ether 函數，僅處理空 calldata 的情況
    receive() external payable {
        // 正常接收 Ether
    }
    
    // 儲存累計接收的 Ether 金額
    uint256 public totalReceived;
    
    // 存款函數，累計接收金額
    function deposit() external payable {
        totalReceived += msg.value;
    }
    
    // 每個地址可存入金額
    mapping(address => uint256) public balances;
    
    function depositFor() external payable {
        balances[msg.sender] += msg.value;
        totalReceived += msg.value;
    }
}

// 攻擊合約：利用冗餘 fallback 函數漏洞發起攻擊
// 攻擊方式說明：攻擊者透過傳送非空 calldata 的轉帳，故意觸發 fallback()，
// 使得本應走 receive() 的正常流程被中斷，進而造成交易 revert。

contract AttackRedundant {
    // 注意：由於 ExRedundantVulnerable 合約內部有 payable fallback，
    // 構造子必須接收 payable address
    ExRedundantVulnerable public vulnerableContract;
    
    // 修改後：接受 payable address，以符合類型轉換要求
    constructor(address payable _vulnerableAddress) {
        vulnerableContract = ExRedundantVulnerable(_vulnerableAddress);
    }
    
    // 攻擊函數：發送 Ether 並帶有非空 calldata (例如 "attack")，刻意觸發 fallback()
    function attack() external payable {
        // 傳送非空 calldata，觸發 fallback() 並導致 revert
        (bool success, ) = address(vulnerableContract).call{value: msg.value}(abi.encodePacked("attack"));
        require(success, "Attack failed: vulnerable fallback reverted transaction");
    }
}

/*
部署及攻擊流程（繁體中文）：
1. 部署 ExRedundantVulnerable 合約。
2. 部署 AttackRedundant 合約，建構子中傳入 ExRedundantVulnerable 的 payable 地址。
3. 攻擊者呼叫 AttackRedundant 的 attack() 函數，附帶 Ether 及非空 calldata。
4. 此時，由於 ExRedundantVulnerable 合約中的 fallback() 會被觸發並 revert，
   導致交易失敗，使用者可能因此無法正常使用 receive() 來接收 Ether。
*/