pragma solidity >=0.8.0;

// 以下範例展示了 Shadowing 漏洞，因為 deposit 函式的參數與全域變數使用了相同的名稱 "balance"，
// 導致狀態變數無法被正確更新。

contract Vulnerable {
    // 狀態變數，預期用來記錄存款金額
    uint public balance; // <-- 全域變數

    // deposit 函式中使用參數名稱 "balance" 導致變數遮蔽 (shadowing) 問題
    function deposit(uint balance) public payable {
        // 參數 balance 會遮蔽上方定義的 state 變數 balance
        require(msg.value == balance, "Incorrect value");

        // 本意為更新全域變數，但實際上只是修改函式參數，不會影響 storage 中的 balance
        balance = msg.value; // 漏洞重點：此處變數 shadowing，未正確更新狀態變數
    }

    function getBalance() public view returns(uint) {
        return balance;
    }
}

// 攻擊合約，用來說明如何利用此漏洞，
// 由於 deposit 函式中未正確更新全域變數 balance，
// 攻擊者可以呼叫 deposit 並傳入 ether，但合約中記錄的 balance 卻不會改變，
// 此現象可能會被利用導致其他依賴 balance 的功能出錯。
contract Attack {
    Vulnerable public vulnerable;

    // 部署攻擊合約時傳入 Vulnerable 合約的地址
    constructor(address _vulnerable) {
        vulnerable = Vulnerable(_vulnerable);
    }

    // 攻擊步驟：
    // 1. 部署 Vulnerable 合約。
    // 2. 部署 Attack 合約並傳入 Vulnerable 合約地址。
    // 3. 呼叫 attack() 並附帶 Ether（例如 1 ether），但因為 shadowing 漏洞，狀態變數 balance 並未正確更新。
    function attack() public payable {
        // 此處呼叫 deposit，傳入 msg.value 使得 require 通過，但實際上 state balance 不受影響。
        vulnerable.deposit{value: msg.value}(msg.value);
        // 攻擊者可以藉由查詢 getBalance() 發現存款金額不如預期的變化，進而觸發其他預期之外的邏輯錯誤。
    }
}
