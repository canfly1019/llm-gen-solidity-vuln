pragma solidity >=0.8.0;

// 漏洞說明：
// 本範例展示因為在繼承合約中誤用相同名稱的區域變數，
// 使得原本希望改寫父合約 state 變數 hardcap 的意圖失敗，
// 因為在 Presale 的建構子中宣告了一個同名的局部變數 hardcap，
// 導致父合約中的 hardcap 仍保持原始值 10000 ether。

contract Tokensale {
    // 父合約 hardcap 變數，預設為 10000 ether
    uint public hardcap = 10000 ether;

    // 建構子
    constructor() {}

    // 回傳目前的 hardcap
    function fetchCap() public view returns(uint) {
        return hardcap;
    }
}

contract Presale is Tokensale {
    // 漏洞處：在建構子中錯誤地宣告了一個區域變數 hardcap，
    // 本意是要更新父合約的 hardcap 值為 1000 ether，但結果只是建立了一個局部變數，
    // 因此父合約的 hardcap 依然維持 10000 ether，不符合預期。
    constructor() Tokensale() {
        uint hardcap = 1000 ether;  // 漏洞重點：僅建立局部變數，未修改 state 變數
    }
}

// 攻擊合約用以展示漏洞效果
contract Attack {
    // 範例流程：
    // 1. 部署 Presale 合約。
    // 2. 呼叫 fetchCap()，預期應為 1000 ether，但實際回傳為 10000 ether，
    //    因為建構子內部的局部變數 hardcap 沒有影響到父合約 state 變數 hardcap。
    function attack(address presaleAddress) public view returns (uint) {
        return Presale(presaleAddress).fetchCap();
    }
}

/*
測試步驟說明：
1. 部署 Presale 合約，此時預期 hardcap 應為 1000 ether 但事實上 state 變數 hardcap 還是由父合約定義的 10000 ether。
2. 呼叫 Attack 合約的 attack() 函式，會發現回傳值為 10000 ether；
3. 此漏洞主要展示了因為在使用相同名稱時誤用局部變數而未能正確更新 state 變數的問題。
*/