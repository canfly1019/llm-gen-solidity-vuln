// Vulnerability Code with Stack-based Buffer Overflow Vulnerability
// 此版本的程式碼存在漏洞：遞迴函式 a() 無止境呼叫自身，會導致堆疊空間耗盡，進而造成控制流程混亂，可能破壞部分內部狀態，進而取得未授權權限。
// 需要注意：在 Solidity >=0.8.0 中，EVM 的呼叫堆疊深度雖然有保護機制，但這裡示範的是一個 "Stack-based Buffer Overflow" 的概念，該漏洞與 Solidity 本身版本無太大關聯，僅供學習使用。
// 此漏洞的攻擊手法：攻擊者藉由呼叫 b() 函式來觸發無限遞迴，最終導致合約呼叫失敗或消耗額外的 gas，甚至可能觸發其他控制流程錯誤。

pragma solidity >=0.8.0;

contract StackDepthTestVulnerable {
    // 建構子
    constructor() {}

    // a2 函式表示正確路徑，示意有其他正常邏輯
    function a2() internal {
        // [示意其他邏輯的程式碼]
    }

    // 漏洞所在：遞迴自己呼叫，將導致堆疊過深
    function a() internal {
        // 漏洞重點：無限遞迴可能導致 stack overflow
        a();
    }

    // 此函式從外部呼叫，觸發漏洞
    function b() external {
        a();
    }
}

// 攻擊合約：最小可行攻擊範例，部署後呼叫 attack() 來觸發漏洞
contract AttackVulnerable {
    StackDepthTestVulnerable public target;

    // 部署時必須傳入目標合約的位址
    constructor(address _targetAddress) {
        target = StackDepthTestVulnerable(_targetAddress);
    }

    // 攻擊者的方法：呼叫目標合約的 b() 函式觸發無限遞迴，達成攻擊
    // 注意：此方法可能因為 gas 不足或堆疊溢出而失敗，但可以模擬攻擊效果
    function attack() external {
        // 攻擊時可傳入較高的 gas 限制
        target.b();
    }
}

/*
補充說明：
1. 攻擊者只要呼叫 AttackVulnerable 合約中的 attack() 方法，
   即可觸發 StackDepthTestVulnerable 合約中的 b() 方法進而呼叫 a() 造成無限遞迴。
2. 實際上，在 EVM 中遞迴呼叫會受到呼叫深度限制保護，但此示例旨在展示由不正確邏輯導致堆疊耗盡的概念。
*/