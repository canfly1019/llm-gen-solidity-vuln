pragma solidity >=0.8.0;

/*
漏洞名稱：Read from Arbitrary Storage Location
描述：本合約中利用了未檢查索引範圍的方式，直接從 storage 中讀取資料，可能會造成 underflow 或 overflow 的問題。

攻擊手法：攻擊者可傳入超出預期範圍的索引，例如傳入 3 來讀取原本不應該讓外部讀取的 state variable (例如 secret)，或傳入負值 (-1) 讀取 buffer 區塊以外的其他資料，進而竊取敏感資訊。
部署與測試流程：
1. 部署 Vulnerable 合約。
2. 呼叫 readAt(3) 測試範圍溢出，讀出 secret 的內容 (999)；或呼叫 readAt(-1) 測試 underflow，讀取 buffer 前一個槽位的內容。
*/

contract Vulnerable {
    // Vulnerable 狀態變數: 固定大小的 buffer array，存放在 slot 0, 1, 2
    // 後面 secret 變數自動存在 slot 3
    bytes32[3] public buffer;  // 漏洞重點在此：未做索引驗證
    uint256 public secret;     // 想保密但可能被讀取

    constructor() {
        // 初始化 buffer 陣列
        buffer[0] = keccak256(abi.encodePacked("A"));
        buffer[1] = keccak256(abi.encodePacked("B"));
        buffer[2] = keccak256(abi.encodePacked("C"));
        secret = 999;
    }

    // 漏洞函式：讀取任意 storage 位置的資料，未檢查 index 的範圍
    function readAt(int256 index) public view returns (bytes32 result) {
        // 攻擊者可傳入超出 0~2 的 index，進而讀取不該暴露的 storage 資料
        assembly {
            // 此處直接使用 buffer.slot 作為基準位址，未驗證 index 大小
            result := sload(add(buffer.slot, index))
        }
    }
}

/*
攻擊範例說明：
- 部署合約後，呼叫 readAt(3) 可以讀取 slot 3 的數據，即 secret 的值。
- 呼叫 readAt(-1) 則可能讀取到 buffer 陣列之前的資料(根據 storage layout，不同部署情況結果可能不同)。
*/
