// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
   漏洞名稱: Typographical Error
   漏洞說明:
   此漏洞來源於開發者在撰寫程式時不小心使用了錯誤的運算子，原本意圖是將 numberOne 累加，但錯誤地重設為一個固定的值。
   原始程式碼中的寫法 numberOne =+ 1 在 Solidity >=0.8.0 中會編譯失敗，因為 unary + 運算子不被允許。
   為了保留原漏洞意圖，我們在此版本中將錯誤修正為錯誤邏輯：每次呼叫 alwaysOne() 都會固定將 numberOne 設為 1，而非累加。

   攻擊示範:
   攻擊者可以反覆呼叫 alwaysOne()，發現 numberOne 永遠固定為 1，從而判斷合約內部邏輯並不如預期進行累加，可能影響後續依賴此變數的邏輯。
*/

contract TypoOneCommandVulnerable {
    // 狀態變數: 初始值為 1，但在每次呼叫 alwaysOne() 時錯誤地重設為 1
    uint public numberOne = 1;

    // 漏洞函式: 本應進行累加，但由於 typographical error，實際上每次都將 numberOne 設為 1
    function alwaysOne() public {
        // 漏洞重點：本來應該使用 '+=' 來累加，但誤用為賦值，導致數值不變
        numberOne = 1;
    }
}

// 攻擊示範合約
contract AttackTypoVulnerable {
    TypoOneCommandVulnerable public target;

    // 建構子傳入漏洞合約地址
    constructor(address _targetAddress) {
        target = TypoOneCommandVulnerable(_targetAddress);
    }

    // 攻擊操作：反覆呼叫 alwaysOne() 測試漏洞效應
    function attack() public {
        // 模擬多次呼叫 alwaysOne()，理論上應累加，實際上數值始終為 1
        for (uint i = 0; i < 5; i++) {
            target.alwaysOne();
        }
    }

    // 查詢受害合約中 numberOne 的值
    function getNumber() public view returns (uint) {
        return target.numberOne();
    }
}
