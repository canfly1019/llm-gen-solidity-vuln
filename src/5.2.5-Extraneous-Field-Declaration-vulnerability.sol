// Vulnerability Code
// 此範例示範 Extraneous Field Declaration 漏洞
// 漏洞說明：
// 1. 合約內同時存在一組正規記錄使用者餘額的 mapping (userBalance)，
//    與一組不必要卻暴露在外的 state variable (balance)。
// 2. 此 extraneous field (balance) 原本可能只作為結構體中一部分來使用，
//    但因為被獨立宣告且同時有一個 public getter，因此外部可以讀取（以及透過不當函數修改）。
// 3. 除此之外，我們提供了一個未加存取限制的 setBalance 函式，使得惡意使用者可直接變更 balance 值，
//    進而造成與 mapping 中記錄的不一致，可能導致提款過多或其他邏輯錯亂。
// 攻擊步驟說明：
// 1. 部署 Vulnerable 合約同時附帶一些 Ether。
// 2. 攻擊者呼叫 setBalance 函式，將 balance 調高或調低，使得 contract 狀態與實際 userBalance 不一致。
// 3. 接著攻擊者利用 withdraw 函式進行提款操作，可能提領超過原本預期的金額。
// 注意：本漏洞與 Solidity 語言版本（>=0.8.0）無關，但仍應遵循新版語法規範。

pragma solidity >=0.8.0;

contract Vulnerable {
    // extraneous state variable，本不應在此單獨宣告，但卻與邏輯內 userBalance 重覆存在
    // 漏洞重點：此變數直接使用 public 修飾，攻擊者可藉由其他函式改寫，使得 contract 的內部邏輯失效
    uint public balance; // 僅代表整體餘額，但邏輯上與 mapping 之記錄應一致

    // 正確的使用者餘額記錄，只透過 withdraw 及內部函式來變化
    mapping(address => uint) internal userBalance;

    // 漏洞建構式：同時初始化兩個餘額記錄，兩者間可能產生不一致
    constructor() payable {
        // 初始化送出部署者的餘額
        userBalance[msg.sender] = msg.value;
        balance = msg.value; // extraneous field 被初始化，但後續可能遭到不當修改
    }

    // withdraw 函式：使用 mapping 作為真實餘額依據，但同時操作 extraneous field
    function withdraw(uint _amount) public {
        require(userBalance[msg.sender] >= _amount, "Insufficient funds");
        userBalance[msg.sender] -= _amount;
        // 此處也更新 extraneous field，若該欄位被外部攻擊者改寫，可能導致邏輯混亂
        balance -= _amount; 
        payable(msg.sender).transfer(_amount);
    }

    // 漏洞函式：未限制權限的 setBalance
    // 攻擊者可以呼叫此函式任意修改 extraneous field balance，造成與 mapping 內部數值不一致
    function setBalance(uint _newBalance) public {
        // 漏洞重點：未加權限控管，任一使用者皆可呼叫
        balance = _newBalance;
    }

    // 為了協助測試，提供一個查詢 mapping 內部餘額的函式
    function getUserBalance(address _user) public view returns (uint) {
        return userBalance[_user];
    }
}

/*
攻擊範例說明：
1. 部署 Vulnerable 合約時傳入 10 ETH，使得 deployer 的 userBalance 與 balance 均為 10 ETH。
2. 攻擊者發現 setBalance 函式無存取控制，呼叫 setBalance(100 ether)，使得 extraneous field balance 變為 100 ETH。
3. 當 deployer或其他使用者呼叫 withdraw 時，由於 withdraw 同時更新 userBalance 與 balance，
   此不一致可能導致提款失敗或其他不可預期之行為，例如提款後 balance 與實際 Ether 持有不符。
*/