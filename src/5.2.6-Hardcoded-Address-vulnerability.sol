pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

// VulnerableContract 合約存在硬編碼地址的漏洞，這使得 BENEFICIARY 地址被固定，不應直接寫死，而應該由外部輸入決定。

contract VulnerableContract {
    // 漏洞重點：硬編碼之受益者地址，不應直接寫死，而應該作為參數傳入
    address public constant BENEFICIARY = 0x1234567890123456789012345678901234567890;

    // 使用者捐款時，所有資金將自動轉發到硬編碼的 BENEFICIARY 地址
    function donate() external payable {
        require(msg.value > 0, "Must send some Ether");
        payable(BENEFICIARY).transfer(msg.value);
    }

    // fallback 函式，用於接收 Ether
    receive() external payable {}
}

/*
 攻擊範例說明（繁體中文）：
 由於受益者地址寫死在合約中，如果該地址為攻擊者掌控，捐款者透過 donate() 發送的資金都會流向該攻擊者地址。

 攻擊步驟：
 1. 攻擊者部署 Attacker 合約，並傳入 VulnerableContract 的地址。
 2. 呼叫 attack() 函式並附帶 Ether，這將呼叫 VulnerableContract 的 donate()，使所有資金轉到硬編碼地址。
*/

// 以下為一個攻擊合約，用來示範如何利用此漏洞進行攻擊
contract Attacker {
    VulnerableContract public vulnerable;

    // 修改建構子，利用 payable 轉型來避免編譯錯誤
    constructor(address _vulnerable) {
        // 將 _vulnerable 轉換為 payable address，再轉成 VulnerableContract 類型
        vulnerable = VulnerableContract(payable(_vulnerable));
    }

    // 攻擊函式：將攻擊者的 Ether 透過 VulnerableContract 的 donate() 方法捐出
    function attack() external payable {
        vulnerable.donate{value: msg.value}();
    }

    // 接收 Ether
    receive() external payable {}
}
