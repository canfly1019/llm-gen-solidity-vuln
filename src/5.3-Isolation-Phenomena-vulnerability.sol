// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
漏洞名稱：Isolation Phenomena
描述：
  這個漏洞產生的原因在於查詢函數依賴區塊打包時的狀態（例如 block.timestamp），使得同樣的查詢在不同的區塊中會得到不同結果，
  攻擊者可以利用這點藉由多次呼叫查詢函數，並在獲得最佳結果時執行後續操作，從而獲取不當利益。
  （注意：此漏洞與 Solidity 版本無關，但使用了區塊變數，故在不同區塊中結果可能不一致。）
*/

contract IsolationVulnerable {
    // 漏洞重點：使用 state variable 和 block.timestamp 改變查詢結果
    uint public constant baseReward = 100;

    // vulnerable 查詢函數：依賴動態變數 block.timestamp 作運算
    function getReward() public view returns (uint) {
        // 注意：區塊時間可能因共識機制而略有不同，導致同一查詢在不同區塊中得到不同結果
        return baseReward + (block.timestamp % 10);  // 漏洞重點：使用 block.timestamp 作為折加 Bonus
    }
}

// 以下為攻擊者合約的最小攻擊範例
contract Attacker {
    IsolationVulnerable public vulnerable;

    // 部署時傳入目標合約的地址
    constructor(address _vulnerableAddress) {
        vulnerable = IsolationVulnerable(_vulnerableAddress);
    }

    // 攻擊示例：攻擊者透過多次呼叫 getReward 並觀察返回結果，在獲得理想的 bonus 時發起關鍵交易
    // 實際應用中，此步驟可能與其他具有金錢交易的操作相結合
    function executeAttack() external view returns (uint optimalReward) {
        // 此處僅示範如何讀取漏洞合約的查詢結果，攻擊者可在 off-chain 觀察並選擇合適時機呼叫
        optimalReward = vulnerable.getReward();
    }

    // 攻擊流程說明：
    // 1. 攻擊者在前端或 off-chain 連續呼叫 getReward()，觀察不同區塊的回傳結果
    // 2. 當發現可獲得較高 Reward 時，藉由有價值的交易或進一步操作利用該多出的獎勵
    // 3. 此漏洞利用方式便是利用了區塊鏈共識機制所導致的 "Isolation Phenomena"，使查詢不一致產生套利機會
}
