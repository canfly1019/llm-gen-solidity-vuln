// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱：Phantom Reads
  描述：
  本範例模擬該漏洞情境，合約會先讀取一個快照 (snapshot) 的資料筆數，
  接著讓使用者根據此快照進行資料運算，但在這兩個步驟間，
  資料可能會遭到其他交易更新，造成所讀取到的狀態與當前最新狀態不同，
  這就是 Phantom Reads 的現象。注意：在 Ethereum 的 EVM 中，交易本身都是原子性，
  因此此漏洞較符合 Hyperledger Fabric 等非 EVM 平台的特性，但此範例用以展示類似概念。

  攻擊步驟說明：
  1. 攻擊者先呼叫 vulnerable.startProcess() 取得當前紀錄的快照 snapshot。
  2. 攻擊者或其他人呼叫 vulnerable.addRecord(...) 以在 records 陣列中插入新的資料，
     使得合約內狀態在兩次讀取間發生改變(即出現 phantom records)。
  3. 攻擊者呼叫 vulnerable.finishProcess(snapshot) 進行處理，但該處理依然以舊的快照為依據，
     因而可能造成錯誤運算結果，利用此結果可能造成利益上的偏差。
*/

contract VulnerablePhantom {
    // 狀態變數：紀錄陣列，存在 phantom reads 風險
    uint256[] public records;

    // 可被任意呼叫的函式，用來新增一筆紀錄
    function addRecord(uint256 value) public {
        records.push(value);
    }

    // 開始處理：回傳目前紀錄數量，此為快照，但未加鎖定，可能為舊資料
    function startProcess() public view returns (uint256) {
        // 漏洞重點：直接讀取狀態，但後續處理仍依據此快照，若中間狀態改變則導致錯誤結果
        return records.length;
    }

    // 結束處理：依據使用者提供的快照進行計算，未強制使用最新資料
    function finishProcess(uint256 snapshot) public view returns (uint256 sum) {
        require(snapshot <= records.length, "Data modified");
        // 漏洞重點：根據外部輸入的 snapshot 進行處理，若 records 在中間被攻擊者修改，
        // 則可能錯誤地忽略或計入不該計算的新紀錄
        for (uint256 i = 0; i < snapshot; i++) {
            sum += records[i];
        }
        return sum;
    }
}

// 攻擊合約，用以示範攻擊者如何利用 phantom reads 漏洞取得不正確的資料運算結果
contract AttackPhantom {
    VulnerablePhantom public vulnerable;

    // 部署時須傳入 VulnerablePhantom 合約的地址
    constructor(address vulnerableAddress) {
        vulnerable = VulnerablePhantom(vulnerableAddress);
    }

    // 攻擊流程：
    // 1. 取得資料快照 snapshot
    // 2. 模擬其他人或攻擊者在此期間呼叫 addRecord 改變狀態
    // 3. 使用舊的 snapshot 進行 finishProcess 計算，從而利用資料不一致
    // 注意：由於 view 函式無法在同一交易中改變狀態，此範例僅供部署多筆交易操作時參考
    function attack() public view returns (uint256) {
        uint256 snapshot = vulnerable.startProcess(); // 獲取原始快照
        // 在此假設在兩個操作間，其他交易已經呼叫 vulnerable.addRecord(x) 更新了 records
        uint256 result = vulnerable.finishProcess(snapshot);
        return result;
    }
}
