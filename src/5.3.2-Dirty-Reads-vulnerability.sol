// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱：Dirty Reads
  描述：在同一個交易中，當合約先查詢某個 key 的數值後，再進行更新，但在完成更新前，若有 callback （外部合約通知）的步驟，則該 callback 可能會取得更新前的「髒資料」(dirty read)。

  攻擊示範：
    1. 攻擊者部署 Attacker 合約並指向目標 VulnerableContract。
    2. 攻擊者呼叫 VulnerableContract 的 updateValueAndNotify() 函數，傳入新的數值及攻擊者合約的地址。
    3. 在函數執行過程中，首先讀取 state variable 'value'（【vulnerable 狀態變數】，這裡標示為髒讀重點），並在更新前透過 callback 通知攻擊者。
    4. 攻擊者在 callback 中可以發現該數值仍然是更新前的值，進行後續攻擊邏輯。

  注意：
    本漏洞示範主要在於更新前進行 callback，導致使用髒讀資料，並非 Solidity 版本本身的 bug，而是設計邏輯問題。
*/

interface IAttacker {
    function notify(uint oldValue) external;
}

contract VulnerableContract {
    // 【vulnerable 狀態變數】：此處的數值將會先被讀取造成髒讀漏洞
    uint public value;

    constructor() {
        value = 0;
    }
    
    // 漏洞函式：在更新 state variable 之前，先進行外部 callback，導致回調中讀取到舊資料
    function updateValueAndNotify(uint newValue, address attackerAddr) public {
        // 先讀取當前 value，這裡為髒讀重點
        uint oldValue = value;
        
        // 呼叫外部攻擊者合約的 notify() 函數，回傳還未更新的舊資料
        IAttacker(attackerAddr).notify(oldValue);
        
        // 更新 state variable，這個更新發生在 callback 之後
        value = newValue;
    }
}

// 攻擊者合約：可利用漏洞在回調中取得髒讀資料，進而達到不符預期的效果
contract Attacker {
    VulnerableContract public vulnerableContract;
    uint public capturedValue;  // 用來記錄從 callback 中收到的髒讀資料

    event AttackNotified(uint oldValue);

    constructor(address vulnerableAddr) {
        vulnerableContract = VulnerableContract(vulnerableAddr);
    }

    // 攻擊入口，發起對目標合約的攻擊請求
    function attack() external {
        // 假設新的數值應該是 100，但在 callback 內會讀到舊的資料
        vulnerableContract.updateValueAndNotify(100, address(this));
    }

    // 回調函式，當 VulnerableContract 呼叫 notify 時，取得髒讀的資料
    function notify(uint oldValue) external {
        // 記錄收到的髒讀資料，可作進一步利用
        capturedValue = oldValue;
        emit AttackNotified(oldValue);
        
        // 攻擊者可以根據 capturedValue 執行後續攻擊邏輯
    }
}
