// Solidity版本標示：此漏洞與版本無關，但請以 Solidity >=0.8.0 編譯
pragma solidity >=0.8.0;

// VulnerableContract 範例示意不當型態使用漏洞－ Improper Type Usage
// 本合約中錯誤地使用 uint 來儲存 owner 地址，並在檢查時進行不必要的型態轉換，
// 可能導致未來擴充或其他漏洞出現時，有被攻擊者利用的風險。

contract VulnerableContract {
    // 狀態變數使用錯誤型態：應該使用 address 型態，但被設為 uint
    uint public owner; // BUG：不正確的型態使用

    constructor() {
        // 將 msg.sender 轉換成 uint 型態儲存，容易造成後續轉換錯誤
        owner = uint(uint160(msg.sender)); // BUG：錯誤的型態轉換
    }

    // 僅限 owner 操作的功能，但檢查中使用了錯誤的型態轉換
    function restrictedAction() public view returns (string memory) {
        // BUG：不當型態轉換比較，將 msg.sender 轉換成 uint 後與 owner 比較
        require(uint(uint160(msg.sender)) == owner, "Not owner");
        return "Action performed";
    }
}

// 攻擊合約示例：
// 攻擊手法說明（繁體中文）：
// 由於 VulnerableContract 中使用了不適當的型別轉換，理論上可能存在利用
// 類似型別混淆的漏洞來冒充成為 owner。雖然本示例中並未提供直接的 setter
// 讓 attacker 修改 owner，但在複雜情境中，若有額外漏洞讓 attacker 可控制輸入資料，
// 攻擊者可能會利用不正確的型態檢查，藉由部署攻擊合約，試圖讓 restrictedAction() 通過檢查。

contract AttackContract {
    VulnerableContract public vulnerable;

    constructor(VulnerableContract _vulnerable) {
        vulnerable = _vulnerable;
    }

    // 攻擊示範：
    // 此攻擊手法假設攻擊者能透過其他漏洞修改 vulnerable.owner ，
    // 進而利用不當型態檢查冒充 owner 身份呼叫 restrictedAction()。
    function attack() public {
        // 注意：在此簡化示範中，實際上無法直接修改 owner，
        // 但如果合約中有其他漏洞，可能使攻擊路徑實現 owner 變更
        vulnerable.restrictedAction();
    }
}
