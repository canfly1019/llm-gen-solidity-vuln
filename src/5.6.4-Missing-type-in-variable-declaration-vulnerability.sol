// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
漏洞描述：
原始漏洞名為 "Missing type in variable declaration"，在低版 Solidity 中可以使用 var 讓編譯器自動推論型態，
可能導致不適當的型態推論（例如推論為 int 而非預期的 uint），進而引發 overflow 或 underflow 問題。

注意：Solidity 從 0.5.0 版本開始已經不再支援 var 關鍵字，因此在 Solidity >=0.8.0 中無法使用 var，
因此此版本為模擬漏洞效果，故意使用了 signed integer (int256) 作為迴圈變數型態，以示範可能因型態不當造成的
潛在問題（例如負數值的使用可能引起邏輯錯誤或下溢風險），但實際上此程式碼在 0 到 256 的範圍內運算不會真的發生溢出。

攻擊示例說明：
1. 部署此合約（VulnerableContract）。
2. 呼叫 attack() 函式觸發 calculateSum() 的迴圈運算。
   雖然在這個例子中，錯誤型態不會直接導致資金流失，但在複雜應用中可能引入數學運算錯誤，
   攻擊者亦可能利用錯誤的型態處理製造非預期狀況。
*/

contract VulnerableContract {
    // 此處故意使用 int256 而非 uint256，模擬因自動型態推論（原本用 var 造成）可能選用錯誤型態的情形
    function calculateSum() public pure returns (int256) {
        int256 sum = 0;
        for (int256 i = 0; i <= 256; i++) {  // 漏洞重點：錯誤地使用 signed integer，若有負值可能引發 underflow 問題
            // 使用 unchecked 以模擬在某些條件下內部可能不檢查溢出
            unchecked {
                sum += i;
            }
        }
        return sum;
    }

    // 攻擊者可以呼叫 attack() 來觸發計算
    function attack() external pure returns (int256) {
        return calculateSum();
    }
}
