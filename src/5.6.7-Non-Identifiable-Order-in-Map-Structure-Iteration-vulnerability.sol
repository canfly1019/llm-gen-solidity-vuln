// Vulnerability Code
// 此合約存在漏洞：Non-Identifiable Order in Map Structure Iteration
// 漏洞描述：在處理訂單時，我們依賴 orderIds 陣列來決定訂單的處理順序。然而，未檢查重複的 order id
// 導致攻擊者可以透過重複加入相同的 order id，藉由多次觸發流程，造成 ledger 狀態不一致或重複處理同一訂單。
// 攻擊步驟：
// 1. 攻擊者呼叫 addOrder 並傳入相同的 order id 兩次（或多次），這樣 orders mapping 中只有最後一次的資料，但 orderIds 陣列卻儲存了重複的 id。
// 2. 呼叫 processOrders 時，由於迭代 orderIds 陣列，將重複處理相同的訂單，可能導致資金重複發放或狀態錯誤。

pragma solidity >=0.8.0;

contract VulnerableOrderProcessor {
    // 訂單結構
    struct Order {
        uint id;           // 訂單編號
        uint amount;       // 訂單金額
        address buyer;     // 購買者
    }
    
    // 狀態變數：
    // orders mapping 存儲訂單，但未檢查重複，所以相同 id 可能被重新覆蓋
    mapping(uint => Order) public orders;  // 漏洞重點：未檢查重複的 order id
    
    // orderIds 陣列用於記錄所有提交的 order id，但可能包含重複項
    uint[] public orderIds;  // 漏洞重點：重複的 order id 會在迭代時被重複處理
    
    // 新增訂單，攻擊者可利用重複的 order id 觸發漏洞
    function addOrder(uint _id, uint _amount) public payable {
        // 未檢查重複新增，容易被攻擊者利用
        orders[_id] = Order(_id, _amount, msg.sender);
        orderIds.push(_id); // 可能會加入重複的 id
    }
    
    // 處理所有訂單，按照 orderIds 陣列的順序處理
    function processOrders() public {
        // 漏洞重點：同一個訂單 id 可能被處理多次
        for (uint i = 0; i < orderIds.length; i++) {
            uint id = orderIds[i];
            Order memory order = orders[id];
            processOrder(order);
        }
        // 清除 orderIds 陣列，但 orders mapping 保留最後一筆資料
        delete orderIds;
    }
    
    event OrderProcessed(uint id, uint amount, address buyer);
    
    // 模擬訂單處理邏輯
    function processOrder(Order memory order) internal {
        // 漏洞示範：對同一筆訂單執行多次處理可能導致 double spending 或 ledger 狀態異常
        emit OrderProcessed(order.id, order.amount, order.buyer);
    }
    
    // 接收 Ether
    receive() external payable {}
}

/*
攻擊範例說明：
1. 攻擊者部署 VulnerableOrderProcessor 合約。
2. 攻擊者呼叫 addOrder(1, 100) 兩次，傳入相同的 order id 1。
3. 當呼叫 processOrders 時，合約將遍歷 orderIds 陣列，對 id 1 的訂單處理兩次，可能導致資金錯誤發放或 ledger 狀態不一致。
*/
