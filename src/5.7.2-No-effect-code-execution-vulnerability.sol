pragma solidity >=0.8.0;

// 合約 A 為空合約，無任何狀態變數或邏輯，但仍被用作繼承目標
contract A {
    // 此處無功能，但被子合約 B 誤用，導致無效的代碼增加到最終二進制碼中
}

// 合約 B 繼承自 A
// 此處 constructor 中使用 A() 呼叫父建構函式，雖然對合約功能無影響，卻增加了不必要的二進制碼和部署 gas 消耗
contract B is A {
    // 多餘的構造函式呼叫 (No effect code execution vulnerability)
    constructor() A() {
        // 注意：這裡呼叫 A() 沒有任何實際用途，僅造成代碼冗餘，浪費 Gas
    }
}

// 攻擊範例合約：
// 雖然「No effect code execution」並不直接造成資金損失或其他明顯安全威脅，
// 但攻擊者可以觀察到因為冗餘代碼而導致的較高部署和調用成本，從而進行成本分析或其他間接攻擊策略。
contract Attack {
    B public vulnerableB;

    constructor() {
        // 部署合約 B 時會執行多餘的父建構函式 A()呼叫，導致額外 Gas 消耗
        vulnerableB = new B();
    }

    // 這個合約僅作為測試示例，實際攻擊可能涉及部署大量冗餘合約以增加網路負荷
}

// 部署步驟說明：
// 1. 攻擊者首先部署 Attack 合約
// 2. Attack 合約部署時會同時部署 B 合約 (觸發多餘的 A() 呼叫)，浪費額外的 Gas
// 3. 攻擊者可以進行成本分析，或者在大規模合約部署情境下累積經濟損失