pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

// 此合約存在未使用變數的漏洞，會導致記憶體不必要的分配，增加 gas 消耗，且提升潛在攻擊面
contract UnusedVariablesVuln {
    // 狀態變數 a 被使用，但宣告其他未使用變數會消耗資源
    int a = 1;  // 用於計算

    // 函式 unusedArg 宣告了參數 y，但沒有使用
    function unusedArg(int x, int y) public view returns (int z) {
        // y 為未使用參數，增加不必要的 gas 消耗
        z = x + a;
    }

    // 函式 unusedReturn 回傳三個值，其中第二個變數 n 從未被設定或使用
    function unusedReturn(int x, int y) public pure returns (int m, int n, int o) {
        m = y - x;
        o = m / 2;
        // 注意: n 雖有被回傳，但始終為預設值，增加不必要的資料結構成本
    }

    // 函式 neverAccessed 中宣告了局部變數 x 卻沒有實際利用
    function neverAccessed(int test) public pure returns (int) {
        int z = 10;
        if (test > z) {
            // 宣告並計算變數 x，但僅作為中間運算，無實質用途
            int x = test - z;
            return test - z;
        }
        return z;
    }

    // 函式 tupleAssignment 使用 tuple assignment，原始 unusedReturn 中的中間值也會被分配
    // 修正前未標記為 view/pure，這裡標示為 pure，因為它不修改任何狀態，但故意保留未使用變數的問題
    function tupleAssignment(int p) public pure returns (int q, int r) {
        (q, , r) = unusedReturn(p, 2);
    }
}

// 攻擊者合約：模擬攻擊者利用已部署漏洞合約的例子
// 攻擊方式在於呼叫存在未使用變數的函式來觀察其額外的 gas 花費，進而分析成本問題
contract AttackUnusedVariables {
    UnusedVariablesVuln public vuln;

    // 部署時需提供漏洞合約地址
    constructor(address _vuln) {
        vuln = UnusedVariablesVuln(_vuln);
    }

    // 攻擊函式：反覆呼叫各函式並回傳結果，藉以觀察 gas 耗費上不必要的資源分配
    // 注意：此函式標示為 view，因為被調用的所有函式皆為 view 或 pure
    function attack() public view returns (int, int, int, int) {
        int res1 = vuln.unusedArg(10, 20);
        (int m, int n, int o) = vuln.unusedReturn(5, 15);
        int res2 = vuln.neverAccessed(20);
        (int q, int r) = vuln.tupleAssignment(4);
        return (res1, m, res2, q + r + n + o);
    }
}

/*
補充說明：
1. 本漏洞與 Solidity 版本無直接關聯，但保留未使用變數可導致額外的 gas 消耗與維護困難。
2. 部署並呼叫 AttackUnusedVariables 合約的 attack() 函式，可觀察到因未使用變數引致的不必要成本。
3. 本程式碼中保留未使用的參數及變數以展示漏洞，即使這會產生警告，但不影響編譯。
*/