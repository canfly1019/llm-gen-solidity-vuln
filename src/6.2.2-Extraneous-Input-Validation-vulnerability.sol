pragma solidity >=0.8.0;

// 此程式碼存在 Extraneous Input Validation 漏洞，因為 Foo 合約中對輸入做出過度限制，
// 要求 x 必須為負數，但在 Bar 中卻傳入 0，導致功能無法正常執行。

contract Foo {
    // 漏洞重點：過度嚴格的 require 條件，阻礙有效行為
    function baz(int256 x) public pure returns (int256) {
        require(0 > x, "x must be negative");  // 輸入驗證過度嚴苛，阻止正當操作
        return 42;
    }
}

contract Bar {
    Foo private f;

    constructor() {
        f = new Foo();
    }

    function doubleBaz() public view returns (int256) {
        // 漏洞重點：傳入的參數 0 不符合 Foo.baz 的要求，導致 require 失敗
        return 2 * f.baz(0);
    }
}

// 最小可行的攻擊範例：
// 攻擊者透過呼叫 doubleBaz() 嘗試執行合約功能，
// 但由於過度的輸入驗證，必定觸發 require，並回傳錯誤訊息

contract AttackVulnerable {
    Bar public bar;

    event Result(int256 result);
    event Error(string message);

    constructor() {
        // 部署 Bar 合約前置作業
        bar = new Bar();
    }

    // 攻擊函式，用來觸發漏洞並接收錯誤訊息
    function attack() public {
        try bar.doubleBaz() returns (int256 result) {
            // 若執行成功，則會 emit 結果（在此情況下不會發生）
            emit Result(result);
        } catch Error(string memory reason) {
            // 捕捉到 require 觸發的錯誤訊息，回傳應用程式錯誤
            emit Error(reason);
        } catch {
            emit Error("Unknown error");
        }
    }
}
