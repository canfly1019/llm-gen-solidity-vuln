pragma solidity >=0.8.0;

// 以下是漏洞程式碼，在 division 時未檢查除數是否為零
library SafeMath {
    // 漏洞重點: 此 division 操作未檢查 b 是否為 0，可能導致除以 0 的錯誤
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // 在 Solidity >=0.8.0，除以 0 會自動 revert，但此處若未預期，可能造成業務邏輯上的問題
        uint256 c = a / b;
        return c;
    }
}

// 攻擊範例：利用未檢查除數是否為零的漏洞
contract VulnerableDemo {
    using SafeMath for uint256;

    // 函式 attack 故意將除數設為 0，觸發除以 0 的錯誤（或 revert），展示漏洞影響
    function attack() public pure returns (uint256) {
        uint256 numerator = 10;
        uint256 denominator = 0; // 漏洞點：除數為 0
        // 此操作在 Solidity >=0.8.0 會因 division by zero 自動 revert
        return numerator.div(denominator);
    }

    /*
      攻擊步驟說明：
      1. 部署 VulnerableDemo 合約。
      2. 呼叫 attack() 函式，設計內部將分母設為 0，觸發除以 0 的狀況。
      3. 觀察交易因除以 0 而 revert，這會造成業務流程中斷，進而可能被攻擊者濫用，影響合約的正常邏輯。
    */
}
