pragma solidity >=0.8.0;

// Vulnerable 合約：Exposed Private Data 漏洞演示
// 雖然 players 陣列被標記為 private，但資料仍可被區塊鏈上任意觀察者讀取，
// 攻擊者可使用 web3.eth.getStorageAt 等工具查詢合約的儲存內容。

contract OddEven {
    struct Player {
        address addr;
        uint number;
    }
    // 漏洞重點：雖然使用 private，但區塊鏈上所有的狀態資料都是公開的
    Player[2] private players;
    uint count = 0;

    // 參與遊戲，每次投注 1 ether
    function play(uint number) public payable {
        require(msg.value == 1 ether, "msg.value must be 1 eth");
        players[count] = Player(msg.sender, number);
        count++;
        if (count == 2) {
            selectWinner();
        }
    }

    // 私有函式：選出勝者並轉帳
    // 漏洞重點：此函式內玩家的 number 資料雖未主動外洩，
    // 但攻擊者仍可藉由查詢區塊鏈存儲內容獲知
    function selectWinner() private {
        uint n = players[0].number + players[1].number;
        (bool success, ) = players[n % 2].addr.call{value: address(this).balance}("");
        require(success, "transfer failed");
        // 重置狀態
        delete players;
        count = 0;
    }

    // 接收 Ether 的 fallback 函式
    receive() external payable {}
}

// 攻擊合約示範：
// 雖然 Solidity 合約內無法直接存取其他合約的狀態資料（因為沒有內建的 getStorage 函式），
// 攻擊者可以利用外部工具 (例如 web3.js 或 ethers.js) 調用 eth_getStorageAt API 讀取存儲槽內容，
// 進而獲得 players 陣列裡敏感的數據 (例如玩家下注的數字)。

contract Attack {
    // 此函式僅表示攻擊思路，實際攻擊需在 off-chain 利用 web3.eth.getStorageAt
    // 範例：
    // const data = await web3.eth.getStorageAt(oddEvenAddress, slotIndex);
    function attack(address target) public view returns (bytes32) {
        // 提示：根據變數宣告順序，players 陣列中的資料可能分佈於不同 storage slots。
        // 此處僅作為概念展示，不會實際返回有用數據。
        bytes32 data;
        return data;
    }
    
    // 接收 Ether 防止轉帳失敗
    receive() external payable {}
}
