// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/*
漏洞名稱：Cryptography Misuse
描述：此漏洞示範合約中不當使用雜湊與區塊變數產生隨機數，攻擊者可藉由預測區塊狀態變數來操縱中獎結果。

漏洞重點：
1. 在 buyTicket 函式中使用 block.timestamp, block.difficulty 及 msg.sender 生成隨機數，易於被攻擊者預測。
2. 攻擊合約透過預測這些值，可能在合約調用 buyTicket 時達成中獎條件。

攻擊範例說明：
1. 攻擊者部署攻擊合約 LotteryAttack，並傳入 VulnerableLottery 合約的位址，注意此處 _target 需為 payable address。
2. 利用區塊參數預測隨機數，當符合中獎條件時進行攻擊呼叫 buyTicket() 以獲取獎池中的全部 ETH。
*/

contract VulnerableLottery {
    // 狀態變數（漏洞重點）：使用易預測資料生成隨機數
    address public winner;
    uint public lotteryId;
    
    // 買票函式，需支付 1 ETH
    function buyTicket() public payable {
        require(msg.value == 1 ether, "Require exactly 1 ETH");
        lotteryId++;
        // 漏洞：使用區塊變數生成隨機數，容易被外部預測
        uint random = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender))) % 10;
        if (random == 0) {
            winner = msg.sender; // 漏洞重點：中獎者設定及支付所有餘額
            payable(winner).transfer(address(this).balance);
        }
    }

    // fallback 函式讓合約能接收 ETH
    receive() external payable {}
}

// 攻擊合約：示範如何利用上面漏洞進行攻擊
contract LotteryAttack {
    VulnerableLottery public target;

    // 修改：將 constructor 參數型態改為 address payable，避免型別轉換錯誤
    constructor(address payable _target) {
        target = VulnerableLottery(_target);
    }

    // 攻擊入口函數
    function attack() public payable {
        require(msg.value == 1 ether, "Attack requires exactly 1 ETH");
        // 攻擊者可在離線根據當前區塊狀態計算隨機數，若滿足條件，則發動攻擊
        target.buyTicket{value: 1 ether}();
    }
}

/*
測試攻擊步驟：
1. 部署 VulnerableLottery 合約。
2. 從其他帳戶向 VulnerableLottery 合約注入 ETH （非必要，但可提供足夠獎金）。
3. 部署 LotteryAttack 合約，建構子參數使用 VulnerableLottery 合約的 payable 地址。
4. 當能夠預測到隨機數為中獎條件時，呼叫 attack()。
*/
