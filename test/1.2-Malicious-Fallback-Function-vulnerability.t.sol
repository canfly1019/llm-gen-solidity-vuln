pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract with malicious fallback
contract RegisterUser {
    uint public idError = 0;

    function setNewUser() external returns (bool) {
        // Simulated normal function
        return true;
    }

    // Vulnerable fallback that simply increments idError
    fallback() external payable {
        idError += 1;
    }
}

// External caller that triggers fallback
contract callExternalExample {
    function callRegisterUser(RegisterUser a) public returns (bool) {
        // Call a non-existent function to trigger fallback
        (bool success, ) = address(a).call(abi.encodeWithSignature("nonExistentFunction()"));
        require(success, "Call failed");
        return success;
    }
}

// Malicious contract that attacks RegisterUser via fallback
contract MaliciousFallback {
    function attack(RegisterUser target) public payable {
        // Calling a non-existent function on the target, triggering its fallback
        (bool success, ) = address(target).call{value: msg.value}(abi.encodeWithSignature("nonExistentFunction()"));
        require(success, "Attack failed");
    }
}

contract FallbackVulnerabilityTest is Test {
    RegisterUser public registerUser;
    callExternalExample public externalCaller;
    MaliciousFallback public attacker;

    function setUp() public {
        registerUser = new RegisterUser();
        externalCaller = new callExternalExample();
        attacker = new MaliciousFallback();
    }

    // Test to ensure that calling a non-existent function through callExternalExample triggers the fallback
    function testFallbackTriggeredByExternalCall() public {
        uint initial = registerUser.idError();

        // Trigger fallback via external caller
        bool success = externalCaller.callRegisterUser(registerUser);
        assertTrue(success, "External call should succeed");

        uint newIdError = registerUser.idError();
        // The fallback function should have incremented idError by 1
        assertEq(newIdError, initial + 1, "idError should be incremented by fallback call");
    }

    // Test that a malicious contract can exploit the fallback and change the state
    function testMaliciousFallbackAttack() public {
        uint initial = registerUser.idError();

        // Attacker calls attack() to trigger RegisterUser.fallback() and alter idError
        // We can send a small amount of ether (even 0 ether) because fallback is payable
        attacker.attack{value: 0}(registerUser);

        uint newIdError = registerUser.idError();
        assertEq(newIdError, initial + 1, "Attacker should have incremented idError by 1 via fallback call");
    }

    // Additional test: multiple fallback invocations increase idError accordingly
    function testMultipleFallbackInvocations() public {
        uint initial = registerUser.idError();

        // Call the attack function 5 times
        for (uint i = 0; i < 5; i++) {
            attacker.attack(registerUser);
        }
        uint expected = initial + 5;
        uint newIdError = registerUser.idError();
        assertEq(newIdError, expected, "idError should be incremented by 5 after 5 fallback calls");
    }

    // Test to show that even direct calls to RegisterUser using low-level call trigger fallback
    function testDirectLowLevelCallTriggersFallback() public {
        uint initial = registerUser.idError();

        // Direct low-level call with non-existent function signature
        (bool success, ) = address(registerUser).call(abi.encodeWithSignature("nonExistentFunction()"));
        assertTrue(success, "Direct low-level call should succeed");

        uint newIdError = registerUser.idError();
        assertEq(newIdError, initial + 1, "Direct call should increment idError by 1");
    }
}
