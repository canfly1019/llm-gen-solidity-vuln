pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable Contract Demonstrating Improper Check of External Call Result
// SPDX-License-Identifier: UNLICENSED

contract VulnerableContract {
    // Mapping to record deposited Ether per address
    mapping(address => uint256) public balances;

    // Deposit function: Accept Ether and update balance mapping
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    // Vulnerable withdraw function
    // It deducts the user balance before attempting to send Ether using a low-level call,
    // and DOES NOT check the call return value. This can be exploited if the recipient's fallback
    // intentionally reverts, causing the transfer to fail while state is already updated.
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        // Deduct balance before external call
        balances[msg.sender] -= amount;

        // Make the external call without checking for success
        (bool success, ) = msg.sender.call{value: amount}("");
        // Vulnerability: Not checking if 'success' is true
    }

    // Allow the contract to receive Ether
    receive() external payable {}
}

// Attack contract that exploits the vulnerable withdraw
contract AttackContract {
    VulnerableContract public vulnerable;

    // Set the address of the vulnerable contract
    constructor(address payable _vulnerable) {
        vulnerable = VulnerableContract(_vulnerable);
    }

    // Fallback function that intentionally reverts, causing external call to fail
    fallback() external payable {
        revert("AttackContract: Fallback revert");
    }

    // Deposit funds to the VulnerableContract
    function deposit() external payable {
        vulnerable.deposit{value: msg.value}();
    }

    // Trigger withdraw on the VulnerableContract; the external call will fail due to fallback revert
    function attackWithdraw(uint256 amount) external {
        vulnerable.withdraw(amount);
    }

    // Helper to check balance of AttackContract
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// Foundry Test Contract demonstrating the vulnerability
contract ImproperExternalCallTest is Test {
    VulnerableContract public vulnerable;
    AttackContract public attacker;

    // Setup the test scenario
    function setUp() public {
        // Deploy vulnerable contract
        vulnerable = new VulnerableContract();

        // Deploy attacker contract and pass the vulnerable contract address
        attacker = new AttackContract(payable(address(vulnerable)));

        // Give the attacker contract some Ether for testing
        vm.deal(address(attacker), 10 ether);

        // From the attacker contract, deposit 1 ether into the vulnerable contract
        vm.prank(address(attacker));
        attacker.deposit{value: 1 ether}();
    }

    // Test demonstrating that withdraw improperly processes failed external calls
    function testAttackWithdraw() public {
        // Verify initial state: attacker has deposited 1 ether
        assertEq(vulnerable.balances(address(attacker)), 1 ether, "Attacker's balance should be 1 ether");
        assertEq(address(vulnerable).balance, 1 ether, "Vulnerable contract should hold 1 ether");

        // Perform withdraw through the attacker contract
        // Although the external call (to the attacker's fallback) fails, the vulnerable contract
        // does not check 'success' and thus does not revert the withdrawal.
        vm.prank(address(attacker));
        attacker.attackWithdraw(1 ether);

        // After withdrawal, the internal balance of the attacker in the vulnerable contract is reduced
        // even though the Ether transfer failed due to the fallback revert.
        assertEq(vulnerable.balances(address(attacker)), 0, "Attacker's internal balance should be 0 after withdrawal");

        // The vulnerable contract's Ether balance should remain the same (1 ether) because the transfer failed.
        assertEq(address(vulnerable).balance, 1 ether, "Vulnerable contract's balance should remain 1 ether");

        // The attacker contract never actually received Ether; its balance remains as initial minus deposit
        // Initial balance allocated was 10 ether and 1 ether was used for deposit
        assertEq(address(attacker).balance, 9 ether, "Attacker contract's balance should remain 9 ether");
    }
}
