pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Provider contract
contract Provider {
    // Normally would contain logic to check if the given customer is valid
    function isCustomer(address customer) public virtual returns (bool) {
        return false;
    }
}

// Malicious provider that always reverts on isCustomer
contract MaliciousProvider is Provider {
    function isCustomer(address customer) public pure override returns (bool) {
        revert("Malicious behavior triggered");
    }
}

// Vulnerable Service contract that improperly handles exceptions from external calls
contract Service {
    function getService(address provider, address customer) public {
        Provider _provider = Provider(provider);
        // Call to external contract without proper exception handling
        if (_provider.isCustomer(customer)) {
            // service logic would be here
        }
    }
}

// Forge test contract
contract ExploitTest is Test {
    Service service;
    MaliciousProvider maliciousProvider;

    function setUp() public {
        service = new Service();
        maliciousProvider = new MaliciousProvider();
    }

    // Test that calling getService with a malicious provider reverts due to unhandled exception
    function testGetServiceRevertsWithMaliciousProvider() public {
        // Expect the revert with specific malicious error
        vm.expectRevert(bytes("Malicious behavior triggered"));
        service.getService(address(maliciousProvider), address(this));
    }

    // Optional: test that non-contract address also reverts if attempted to be used as provider.
    // This is to demonstrate that the call is not exception handled in any case
    function testGetServiceRevertsWithNonContract() public {
        // Deploy a contract-less address (e.g., address(0x123)) and expect it to fail because delegate call will fail
        // Note: The revert might be different based on how solidity handles low-level calls
        // vm.expectRevert is generic since calling a non-contract as a contract can lead to fallback behavior
        // Here, we'll catch the revert so test does not fail
        try service.getService(address(0x123), address(this)) {
            // If call doesn't revert, then the test fails
            revert("Expected getService to revert when using a non-contract address as provider");
        } catch {
            // Test passed as it reverted
        }
    }
}
