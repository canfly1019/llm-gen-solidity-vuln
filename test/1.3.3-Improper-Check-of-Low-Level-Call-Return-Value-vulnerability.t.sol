pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract, where the low-level call success is not checked
contract ReturnValueVulnerable {
    // This function makes a low-level call without checking if it succeeded
    function callNotChecked(address callee) public {
        (bool success, ) = callee.call(abi.encodeWithSignature("doSomething()"));
        // Vulnerability: the returned 'success' value is ignored
    }
}

// Malicious contract as provided. It defines a fallback that reverts, but also a function doSomething().
// When calling with empty calldata, the fallback will be triggered and revert, but when calling with the
// proper function selector, doSomething() will be executed. This makes it unsuitable to demonstrate a failed
// low-level call when an attacker wants the call to fail. 
contract Malicious {
    // fallback function that always reverts
    fallback() external payable {
        revert("Malicious fallback triggered.");
    }

    // This function is defined and will be called if the function selector matches
    function doSomething() external pure returns (string memory) {
        return "This should not execute";
    }
}

// Additional contract to demonstrate a malicious contract that does NOT implement doSomething(), forcing the fallback to trigger.
contract MaliciousFallback {
    // Only a fallback is provided, which always reverts
    fallback() external payable {
        revert("Malicious fallback triggered.");
    }
}

// Attack contract that demonstrates the vulnerability by using the ReturnValueVulnerable.
contract Attack {
    ReturnValueVulnerable public vulnerable;
    Malicious public malicious;

    constructor() {
        vulnerable = new ReturnValueVulnerable();
        malicious = new Malicious();
    }

    // Attack flow: even if the underlying call fails, the vulnerable contract does not check the return value
    function attack() public {
        vulnerable.callNotChecked(address(malicious));
    }
}

// Foundry Test Contract
contract VulnerableTest is Test {
    ReturnValueVulnerable vuln;
    Malicious malicious;
    MaliciousFallback maliciousFallback;
    Attack attackContract;

    function setUp() public {
        vuln = new ReturnValueVulnerable();
        malicious = new Malicious();
        maliciousFallback = new MaliciousFallback();
        attackContract = new Attack();
    }

    // Test that a direct low-level call to a contract with only fallback (i.e. no matching function) fails
    function testDirectCallRevertsForFallback() public {
        // Prepare the call data that matches a non-existent function, so that fallback is triggered
        bytes memory callData = abi.encodeWithSignature("doSomething()");
        // Using the MaliciousFallback contract, it does not have doSomething so fallback will trigger
        (bool success, bytes memory result) = address(maliciousFallback).call(callData);
        // The call should fail because fallback reverts
        assertEq(success, false, "Direct low-level call to MaliciousFallback should fail");

        // Alternatively, calling with empty calldata will also trigger fallback
        (success, result) = address(maliciousFallback).call("");
        assertEq(success, false, "Direct low-level call with empty data should also fail");
    }

    // Test that ReturnValueVulnerable.callNotChecked does not revert even if the underlying call fails
    function testCallNotCheckedDoesNotRevert() public {
        // Use the MaliciousFallback contract to force the low-level call to fail
        // We directly invoke callNotChecked with maliciousFallback's address
        // Even though the underlying call fails, callNotChecked does not check the result and will not revert
        vuln.callNotChecked(address(maliciousFallback));
        // If we reach here, it means the lack of check allowed the function to complete without revert
        assertTrue(true, "callNotChecked did not revert despite low-level call failure");
    }

    // Test the attack contract that exploits the vulnerability by not checking the return value
    function testAttackExploitsVulnerability() public {
        // The attack function calls vulnerable.callNotChecked with malicious contract's address
        // Note: When using the provided Malicious contract, the function doSomething() is defined, so the call will succeed.
        // However, this test demonstrates that the vulnerable contract doesn't revert even if the attacker intended a failing call.

        // We perform a direct call to malicious with empty calldata to show that fallback reversion works on direct calls.
        (bool directSuccess, ) = address(malicious).call("");
        assertEq(directSuccess, false, "Direct call with empty data to Malicious should fail due to fallback");

        // Now call attack. Even if the underlying low-level call fails (or would fail in a different malicious contract),
        // the attack() function and vulnerable.callNotChecked do not revert because they do not check the call's return value.
        attackContract.attack();
        assertTrue(true, "Attack contract execution completed, demonstrating unchecked call return value vulnerability");
    }
}
