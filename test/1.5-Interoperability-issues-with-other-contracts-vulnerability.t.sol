pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerability Code (存在合約互通性漏洞範例)
// 說明：
// 此漏洞示範因舊版介面與新版本編譯器使用上的不一致，在呼叫合約時沒有正確使用靜態呼叫方式，加上原本設計為 view 的介面實際上仍修改狀態，可能被攻擊者利用來干擾系統狀態.

contract VulnerableConstant {
    // 狀態變數：計數器
    uint public counter; // 漏洞重點：counter 被不當修改

    // 此函式原本意圖宣告為 view，但實際上修改狀態，導致介面與實作不符
    function myFunction() public returns (uint) {
        // 漏洞重點：意圖為純讀取操作但實際上修改 counter
        counter++;
        return counter;
    }
}

// 新版合約，嘗試呼叫舊合約的 myFunction，但因介面不一致，使用了 call 而非靜態呼叫（staticcall），
// 造成互通性問題，可能導致不可預期行為
contract VulnerableNewContract {
    // 此函式利用 call 直接傳遞 call data，未使用視圖函式專用的 staticcall
    function doSomething(address _addr) public returns (bool) {
        // 漏洞重點：使用 _addr.call 時，abi.encodeWithSignature 參數必須為字串常數
        // 錯誤示範中，可能用錯誤的 encoding 方式，但此處正確使用字串 "myFunction()" 來模擬漏洞前之不當介面
        (bool success, ) = _addr.call(abi.encodeWithSignature("myFunction()"));
        // 注意：缺少對 success 的嚴格驗證可能會導致後續邏輯在狀態不正確時執行
        return success;
    }
}

// 攻擊合約，用於示範攻擊者如何藉由呼叫 VulnerableNewContract 來間接修改 VulnerableConstant 的狀態
contract Attack {
    VulnerableNewContract public target;
    VulnerableConstant public victim;

    // 部署時傳入目標合約位址與受害合約位址
    constructor(address _target, address _victim) {
        target = VulnerableNewContract(_target);
        victim = VulnerableConstant(_victim);
    }

    // 攻擊步驟：呼叫 target 合約的 doSomething，進而觸發 victim 合約的 myFunction 來修改 counter
    function executeAttack() public returns (uint) {
        // 執行攻擊：呼叫 doSomething 使 victim.counter 被修改
        bool success = target.doSomething(address(victim));
        require(success, "Call to victim failed");
        // 回傳 victim 合約中 counter 的數值，可用以驗證攻擊效果
        return victim.counter();
    }
}


// Forge Foundry test contract demonstrating the vulnerability
contract VulnerabilityTest is Test {
    VulnerableConstant victim;
    VulnerableNewContract vulnerableNewContract;
    Attack attacker;

    function setUp() public {
        // Deploy the vulnerable victim contract
        victim = new VulnerableConstant();
        // Deploy the new contract that calls the vulnerable one
        vulnerableNewContract = new VulnerableNewContract();
        // Deploy the attack contract, providing addresses of the new and victim contracts to simulate the attack
        attacker = new Attack(address(vulnerableNewContract), address(victim));
    }

    // Test to demonstrate the vulnerability by using the Attack contract
    function testExecuteAttack() public {
        // Initially, the counter in the victim contract should be 0
        assertEq(victim.counter(), 0, "Initial counter should be 0");

        // Execute the attack which should modify the state of the victim contract
        uint newCounter = attacker.executeAttack();
        
        // Verify that the counter has been incremented
        assertEq(newCounter, 1, "Counter should be incremented to 1 after attack");

        // Call the doSomething function directly to further confirm the interoperability issue
        bool callSuccess = vulnerableNewContract.doSomething(address(victim));
        assertTrue(callSuccess, "Direct call to victim via doSomething should succeed");

        // The counter should now be 2
        assertEq(victim.counter(), 2, "Counter should be incremented to 2 after direct call");
    }

    // Additional test: Ensure that even when invoking the victim contract through different methods,
    // the state modification is not prevented by any static context (vulnerability demonstration)
    function testMultipleCalls() public {
        // Call attack once
        uint counterAfterFirst = attacker.executeAttack();
        assertEq(counterAfterFirst, 1, "Counter should be 1 after first attack");

        // Call doSomething directly
        vm.prank(address(this));
        bool directCallSuccess = vulnerableNewContract.doSomething(address(victim));
        assertTrue(directCallSuccess, "Direct call should succeed");

        // The counter should now be 2
        assertEq(victim.counter(), 2, "Counter should be 2 after second call");
    }
}
