// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

/*
漏洞名稱: Unsafe External Web Service Call
描述: 此漏洞發生在合約直接呼叫外部網路服務取得資料，並未對返回的數值進行有效驗證，攻擊者可藉由控制回傳內容來操控合約邏輯

攻擊手法說明:
1. 攻擊者部署一個惡意的外部網路服務合約 (MaliciousWebService)，實作 getValue() 函式返回一個攻擊者預設的值。
2. 被攻擊的合約 VulnerableContract 紀錄外部網路服務地址，並在 updateValue() 函式中呼叫該地址的 getValue() 函式，並將結果寫入狀態變數。
3. 攻擊者透過調整 MaliciousWebService 回傳的數值，操控 VulnerableContract 的狀態變數 value。

漏洞版本程式碼如下：
*/

contract VulnerableContract {
    // 狀態變數，紀錄外部網路服務地址
    address public externalService; // 漏洞重點：未驗證外部服務之真實性
    
    // 狀態變數，存儲從外部網路服務取得的數值
    uint public value;

    // 建構子設定外部網路服務地址
    constructor(address _externalService) {
        externalService = _externalService;
    }

    // updateValue 函式直接呼叫外部服務取得回傳值
    function updateValue() public {
        // 漏洞重點：未驗證外部服務返回的數據
        (bool success, bytes memory data) = externalService.call(abi.encodeWithSignature("getValue()"));
        require(success, "Call failed");
        
        // 直接將回傳值寫入狀態變數
        value = abi.decode(data, (uint));
    }
}

// 模擬惡意的外部網路服務合約，供攻擊者部署並操控返回值
contract MaliciousWebService {
    // 攻擊者可設定的惡意數值
    uint public manipulatedValue;

    // 攻擊者設定惡意數值
    function setManipulatedValue(uint _val) public {
        manipulatedValue = _val;
    }

    // 被呼叫時返回攻擊者設定的數值
    function getValue() public view returns (uint) {
        // 漏洞重點：回傳數值可被攻擊者控制
        return manipulatedValue;
    }
}


contract VulnerableContractTest is Test {
    VulnerableContract public vulnerable;
    MaliciousWebService public malicious;

    function setUp() public {
        // 部署惡意的外部網路服務合約
        malicious = new MaliciousWebService();
        // 預設設定 manipulatedValue 為 0
        malicious.setManipulatedValue(0);
        // 部署易受攻擊的合約，並將惡意回傳服務地址傳入
        vulnerable = new VulnerableContract(address(malicious));
    }

    function testChangingManipulatedValue() public {
        // 攻擊者第一次設定 manipulatedValue
        malicious.setManipulatedValue(1111);
        vulnerable.updateValue();
        uint currentValue = vulnerable.value();
        assertEq(currentValue, 1111, "vulnerable.value should be 1111 initially");

        // 攻擊者調整 manipulatedValue
        malicious.setManipulatedValue(2222);
        vulnerable.updateValue();
        currentValue = vulnerable.value();
        assertEq(currentValue, 2222, "vulnerable.value should be updated to 2222 after changing manipulated value");
    }

    function testExploitManipulatedValue() public {
        // 攻擊者設置一個極端數值來操控回傳值
        malicious.setManipulatedValue(9999);
        vulnerable.updateValue();
        uint currentValue = vulnerable.value();
        assertEq(currentValue, 9999, "vulnerable.value should be 9999 after exploitation");
    }

    function testUpdateValueRevertWhenCallFails() public {
        // 部署一個 VulnerableContract，指向不存在合約 (例如：0x000000000000000000000000000000000000dEaD)，以模擬外部服務回傳失敗
        VulnerableContract vulnerableFail = new VulnerableContract(address(0x000000000000000000000000000000000000dEaD));
        // 使用 vm.expectRevert() 無參數來捕捉任何錯誤，不去檢查具體 revert message
        vm.expectRevert();
        vulnerableFail.updateValue();
    }
}
