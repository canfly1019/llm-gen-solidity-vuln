// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/1.7.3-Unsafe-External-Command-Execution-vulnerability.sol";

contract UnsafeExternalCommandExecutionTest is Test {
    VulnerableTarget target;
    UnsafeCommandExecutor executor;
    Attack attack;
    address attacker = address(0xABCD);

    function setUp() public {
        // Deploy the vulnerable contracts
        target = new VulnerableTarget();
        executor = new UnsafeCommandExecutor();
        attack = new Attack(address(executor), address(target));
        // Fund the target with 1 ether
        vm.deal(address(target), 1 ether);
    }

    /// @dev Invalid function names revert and do not persist state changes
    function testExecuteCommandRevertsForInvalidFunction() public {
        vm.expectRevert("Command execution failed");
        executor.executeCommand(address(target), "nonexistent");
        // As the require() reverted, the state update is undone
        assertEq(executor.lastExecutedCommand(), "", "lastExecutedCommand should remain empty on failure");
    }

    /// @dev Demonstrate the unsafe external command execution leads to selfdestruct
    function testUnsafeExternalCommandExecutionExploit() public {
        // Precondition: target has 1 ether
        assertEq(address(target).balance, 1 ether, "Target should have 1 ether initially");

        // Attacker triggers the exploit
        vm.prank(attacker);
        attack.attack();

        // After the exploit, the target balance is drained
        assertEq(address(target).balance, 0, "Target balance should be 0 after selfdestruct");
        // The executor contract (msg.sender of pwn) received the funds
        assertEq(address(executor).balance, 1 ether, "Executor should receive the drained funds");
        // The executor recorded the executed command successfully
        assertEq(executor.lastExecutedCommand(), "pwn", "lastExecutedCommand should record 'pwn'");
    }
}