pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract allowing anyone to update the fileData
contract UnsafeFileAccessor {
    // Public string storing the external file data
    string public fileData;

    // Vulnerable function: no access control, any caller may overwrite fileData
    function updateFileData(string calldata _fileData) external {
        fileData = _fileData;
    }

    // Returns decision based on fileData content
    function processData() external view returns (string memory) {
        if (keccak256(bytes(fileData)) == keccak256(bytes("approved"))) {
            return "File approved";
        } else {
            return "File not approved";
        }
    }
}

// Attack contract demonstrating exploitation of the vulnerability
contract AttackUnsafeFileAccessor {
    UnsafeFileAccessor public vulnerable;

    // Store target contract address
    constructor(UnsafeFileAccessor _vulnerable) {
        vulnerable = _vulnerable;
    }

    // Attack function: update fileData to malicious content
    function attack() external {
        vulnerable.updateFileData("malicious file content");
    }
}

// Foundry Test Contract to demonstrate the issue
contract UnsafeExternalFileAccessTest is Test {
    UnsafeFileAccessor public unsafe;
    AttackUnsafeFileAccessor public attacker;

    function setUp() public {
        // Deploy the vulnerable contract
        unsafe = new UnsafeFileAccessor();
        // Deploy the attacking contract and pass the vulnerable contract's address
        attacker = new AttackUnsafeFileAccessor(unsafe);
    }

    // Test to check normal behavior
    function testApprovedFileData() public {
        // Initially update fileData to "approved"
        unsafe.updateFileData("approved");
        // Expect processData() to return "File approved"
        string memory result = unsafe.processData();
        assertEq(result, "File approved", "File should be approved when fileData is 'approved'");
    }

    // Test to simulate the attack and show vulnerability exploitation
    function testExploitVulnerability() public {
        // Set the fileData to a valid state first
        unsafe.updateFileData("approved");
        string memory initialResult = unsafe.processData();
        assertEq(initialResult, "File approved", "Initial state must be approved");

        // Now, the attacker capitalizes on the lack of access control to update fileData maliciously
        attacker.attack();

        // After the attack, the inconsistent fileData should cause different behavior
        string memory resultAfterAttack = unsafe.processData();
        assertEq(resultAfterAttack, "File not approved", "After attack, fileData should not be approved");
    }

    // Additional test demonstrating that any account can update fileData without restrictions
    function testUnauthorizedUpdate() public {
        // Without using the attack contract, an arbitrary caller makes the update
        // In Foundry, the default account (address(this)) is used
        unsafe.updateFileData("malicious file content");
        string memory result = unsafe.processData();
        assertEq(result, "File not approved", "Unauthorized update succeeded in modifying fileData");
    }
}
