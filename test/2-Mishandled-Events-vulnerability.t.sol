pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract with mishandled events due to using assert
contract VulnerableContract {
    mapping(address => uint256) public balances;

    event Deposit(address indexed sender, uint256 amount);
    event Withdrawal(address indexed to, uint256 amount);

    // Deposit function that credits sender's balance and emits an event
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    // Withdraw function -- vulnerable because it uses assert instead of require
    function withdraw(uint256 _amount) public {
        // Using assert here, so if balance is insufficient the call will revert
        // consuming all remaining gas without a helpful error message.
        assert(balances[msg.sender] >= _amount);

        balances[msg.sender] -= _amount;
        payable(msg.sender).transfer(_amount);
        emit Withdrawal(msg.sender, _amount);
    }

    // receive Ether and additionally call deposit to record the deposit
    receive() external payable {
        deposit();
    }
}

// Attack contract that demonstrates the vulnerability by attempting to withdraw more than available
contract Attack {
    VulnerableContract public target;

    constructor(address _target) {
        target = VulnerableContract(payable(_target));
    }

    // Attack function: does not deposit any funds, so the balance is 0.
    // Calling withdraw with 1 ether should trigger the assert in VulnerableContract.withdraw
    function attack() public {
        target.withdraw(1 ether);
    }
}

// Forge test contract focusing on the mishandled events vulnerability
contract VulnerableContractTest is Test {
    VulnerableContract vulnerable;
    Attack attackContract;

    // Setup deploys a fresh VulnerableContract and an Attack contract targeting it
    function setUp() public {
        vulnerable = new VulnerableContract();
        attackContract = new Attack(address(vulnerable));
    }

    // Test that ensures withdrawing more than balance triggers the assert.
    // When the assert fails, the call reverts with a Panic error.
    // In Solidity 0.8, assert failures trigger a Panic with code 0x01 (for example).
    function testAttackTriggeringAssert() public {
        // Since our Attack contract doesn't deposit any funds, calling attack() will cause
        // an assert to fail in the VulnerableContract.withdraw() function.
        // We expect a Panic error to be thrown. The ABI encoding for Panic(uint256) with code 0x01 is used here.
        vm.expectRevert(abi.encodeWithSignature("Panic(uint256)", 0x01));
        attackContract.attack();
    }

    // Additional test demonstrating that a normal deposit and valid withdraw works as expected.
    // Although our focus is on the vulnerability, this control test ensures the contracts behave
    // normally when conditions are met.
    function testValidDepositAndWithdraw() public {
        // Deposit 2 ether into the VulnerableContract from the test contract.
        vulnerable.deposit{value: 2 ether}();
        assertEq(vulnerable.balances(address(this)), 2 ether);

        // Withdraw 1 ether successfully (should not revert)
        vulnerable.withdraw(1 ether);
        assertEq(vulnerable.balances(address(this)), 1 ether);
    }

    // Allow the test contract to receive Ether so that withdrawal transfers do not fail.
    receive() external payable {}
}
