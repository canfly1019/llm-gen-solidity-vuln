pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as given
// SPDX-License-Identifier: MIT

contract NaiveBankVulnerable {
    // State variable: winners are not marked as processed before sending funds
    address payable[] public winners;
    uint public reward = 1 ether;
    mapping(address => bool) public processed;

    constructor() {
        // Initially add the deployer
        winners.push(payable(msg.sender));
    }

    // Add a winner address to the list
    function addWinner(address payable _winner) public {
        winners.push(_winner);
    }

    // Vulnerable function: loops through winners and sends reward
    // If any transfer fails it reverts, but state is not pre-marked
    function setTransfer() public {
        for (uint i = 0; i < winners.length; i++) {
            // If send fails, revert the entire transaction
            require(winners[i].send(reward), "Send failed, reverting entire transaction");
        }
    }
}

// Attacker contract that intentionally reverts when receiving Ether
contract Attack {
    NaiveBankVulnerable public vulnerableContract;

    constructor(address _vulnerableContract) {
        vulnerableContract = NaiveBankVulnerable(_vulnerableContract);
    }

    // Fallback function which reverts on receiving Ether
    fallback() external payable {
        revert("Attack: Reverting on receive");
    }

    // Function to trigger the bank's setTransfer function
    function attack() public {
        vulnerableContract.setTransfer();
    }
}

// Dummy contract that accepts Ether
contract DummyReceiverAccepting {
    // Provide a receive function that accepts Ether silently
    receive() external payable {}
}


contract NaiveBankVulnerableTest is Test {
    NaiveBankVulnerable public bank;
    uint constant INITIAL_BANK_BALANCE = 5 ether;

    // Allow this test contract to receive Ether
    receive() external payable {}

    function setUp() public {
        bank = new NaiveBankVulnerable();
        // Fund the bank contract so it can cover transfers
        vm.deal(address(bank), INITIAL_BANK_BALANCE);
    }

    // Test that when an attacker is in the winners list, setTransfer() reverts 
    // and the bank's balance remains unchanged
    function testSetTransferRevertsWithAttacker() public {
        // Deploy a dummy receiver that will accept funds
        DummyReceiverAccepting receiver = new DummyReceiverAccepting();
        bank.addWinner(payable(address(receiver)));

        // Deploy attack contract whose fallback reverts on receiving funds
        Attack attacker = new Attack(address(bank));
        bank.addWinner(payable(address(attacker)));

        // Expect revert with message "Send failed, reverting entire transaction"
        vm.expectRevert(bytes("Send failed, reverting entire transaction"));
        bank.setTransfer();

        // Ensure bank balance is unchanged after the revert
        uint bankBalance = address(bank).balance;
        assertEq(bankBalance, INITIAL_BANK_BALANCE, "Bank balance should remain unchanged after revert");
    }

    // Test that when only valid recipients (that accept funds) are in the winners list,
    // the transfer succeeds
    function testSetTransferSuccessWithoutAttack() public {
        // Deploy a dummy receiver that accepts funds
        DummyReceiverAccepting receiver = new DummyReceiverAccepting();
        bank.addWinner(payable(address(receiver)));
        
        // Note: winners array already contains the deployer (this contract), which can also receive Ether
        // So total winners count is now 2
        // Calling setTransfer should succeed
        bank.setTransfer();
        
        // Calculate expected bank balance after transfers: 2 winners * reward(1 ether) = 2 ether deducted
        uint expectedDeduction = bank.reward() * 2;
        uint bankBalance = address(bank).balance;
        assertEq(bankBalance, INITIAL_BANK_BALANCE - expectedDeduction, "Bank balance should be reduced by total reward sent");
        
        // Verify that the dummy receiver actually received the reward
        assertEq(address(receiver).balance, bank.reward(), "Dummy receiver should receive exactly 1 ether");
    }
}
