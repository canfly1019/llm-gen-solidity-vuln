pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Interface and contracts copied from the vulnerable contract file

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

// VulnerableTokenHandler contains the vulnerability: aborting the return value from transfer
contract VulnerableTokenHandler {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    // withdraw does not check the return value of token.transfer
    function withdraw(uint256 amount) external {
        token.transfer(msg.sender, amount);
    }
}

// MaliciousToken simulates a token that always returns false for transfer
contract MaliciousToken is IERC20 {
    mapping(address => uint256) public balances;

    constructor() {
        // For testing, give deployer plenty tokens
        balances[msg.sender] = 1000000 ether;
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        // Does not adjust balances, always returns false to simulate a faulty token
        return false;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }
}

// Foundry test contract
contract VulnerableTokenHandlerTest is Test {
    VulnerableTokenHandler public handler;
    MaliciousToken public malicious;

    // We'll use a test address to simulate a caller
    address public constant user = address(0xABCD);

    function setUp() public {
        // Deploy the MaliciousToken contract
        malicious = new MaliciousToken();
        // Deploy the VulnerableTokenHandler with the malicious token address
        handler = new VulnerableTokenHandler(address(malicious));
    }

    // Test that withdraw() does not revert even when token.transfer fails
    // and that the user does not actually receive tokens
    function testWithdrawWithFaultyTokenDoesNotTransferFunds() public {
        // We'll use vm.prank to simulate call from 'user'
        uint256 withdrawAmount = 100 ether;

        // Get initial balance of user in the malicious token
        uint256 initialBalance = malicious.balanceOf(user);

        // Expect no revert here even though transfer returns false
        vm.prank(user);
        handler.withdraw(withdrawAmount);

        // Since transfer always returns false and the contract does nothing on failure,
        // the user's balance should remain unchanged
        uint256 finalBalance = malicious.balanceOf(user);
        assertEq(finalBalance, initialBalance, "User balance should not increase despite withdraw call");
    }

    // Additional test to confirm that even a direct call to MaliciousToken.transfer always returns false
    function testDirectMaliciousTokenTransferAlwaysFails() public {
        // Even when invoked by the user, transfer should always return false
        vm.prank(user);
        bool success = malicious.transfer(user, 50 ether);
        assertFalse(success, "MaliciousToken.transfer should always return false");
    }
}
