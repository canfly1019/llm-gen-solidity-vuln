pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the VulnerableToken and AttackMissingThrownException from the vulnerable contract file
// Assumes the file name is 2.2.1-Missing-Thrown-Exception-vulnerability.sol and is placed in the src/ directory
import "../src/2.2.1-Missing-Thrown-Exception-vulnerability.sol";

contract VulnerableTokenTest is Test {
    VulnerableToken token;
    AttackMissingThrownException attacker;

    // Deploy the vulnerable token with an initial supply of 500 tokens to the deployer (this contract)
    // Deploy the attack contract which will try to exploit the missing thrown exception vulnerability
    function setUp() public {
        token = new VulnerableToken(500);
        attacker = new AttackMissingThrownException(address(token));
    }

    // Test to verify that when the transfer conditions are not met (i.e., insufficient balance),
    // the vulnerable transfer function returns false instead of throwing/reverting.
    function testInsufficientBalanceTransferReturnsFalse() public {
        // this contract has 500 tokens. Try to transfer 600 tokens. Should return false since balance < 600
        bool success = token.transfer(address(0x123), 600);
        
        // Instead of reverting, the contract returns false
        assertEq(success, false, "Transfer should return false when insufficient balance is provided.");

        // Additionally, verify that the balance remains unchanged
        assertEq(token.balances(address(this)), 500, "Sender's balance should remain the same after a failed transfer.");
    }

    // Test the attack contract's function which exploits the missing exception vulnerability.
    // The attack contract attempts to transfer 1000 tokens from its own account, but as it was not allocated any tokens,
    // the transfer returns false rather than reverting. This might trick users into thinking the transfer succeeded.
    function testAttackInsufficientBalanceTransfer() public {
        // Call the attack function from the attack contract
        bool result = attacker.attackTransferWithInsufficientBalance();
        
        // Since the attacker's balance is 0, the transfer should return false
        assertEq(result, false, "Attack transfer should return false due to insufficient balance.");

        // Check that the attacker's balance remains zero
        assertEq(token.balances(address(attacker)), 0, "Attacker contract balance should be zero.");
    }

    // Optional: test a normal successful transfer to show that the function works when conditions are met.
    function testSuccessfulTransfer() public {
        // This contract has 500 tokens. Transfer 200 tokens to a recipient address
        bool success = token.transfer(address(0xABC), 200);
        
        // The transfer should succeed
        assertEq(success, true, "Transfer should succeed with sufficient balance.");

        // Verify that sender's and receiver's balances are updated accordingly
        assertEq(token.balances(address(this)), 300, "Sender's balance should be reduced by the transfer amount.");
        assertEq(token.balances(address(0xABC)), 200, "Receiver's balance should be increased by the transfer amount.");
    }
}
