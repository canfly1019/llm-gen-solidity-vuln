pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// VulnerableToken contract with extraneous exception handling vulnerability
// SPDX-License-Identifier: MIT
contract VulnerableToken {
    mapping(address => uint) public balances;
    
    // 初始化部署者擁有 1000 wei 的代幣
    constructor() {
        balances[msg.sender] = 1000;
    }
    
    // 存在問題的 transferFrom 函式，額外的 require 限制會導致符合規範的操作被拒絕
    function transferFrom(address _spender, uint _value) public returns (bool success) {
        // extraneous exception handling vulnerability
        require(_value < 20 wei, "value must be less than 20 wei");
        
        // 檢查呼叫者是否有足夠的餘額
        require(balances[msg.sender] >= _value, "Insufficient balance");
        
        balances[msg.sender] -= _value;
        balances[_spender] += _value;
        return true;
    }
    
    // 查詢餘額
    function getBalance(address account) public view returns (uint) {
        return balances[account];
    }
}

// 攻擊合約
contract AttackContract {
    VulnerableToken public vulnerableToken;
    
    // 初始化時設定被攻擊的 VulnerableToken 合約地址
    constructor(address _vulnerableTokenAddress) {
        vulnerableToken = VulnerableToken(_vulnerableTokenAddress);
    }
    
    // 攻擊函式，故意傳入大於或等於 20 wei 的值以觸發 extraneous require 條件失敗，導致轉帳失敗
    function attack() public {
        // 此處使用 25 wei ，觸發 require 條件，使轉帳 revert
        vulnerableToken.transferFrom(msg.sender, 25 wei);
    }
}

// Forge Foundry Test
contract VulnerableTokenTest is Test {
    VulnerableToken vulnerable;
    
    // setUp deploys the VulnerableToken contract
    function setUp() public {
        vulnerable = new VulnerableToken();
    }
    
    // Test a normal transfer with a value less than 20 wei. Expect success.
    function testNormalTransferWorks() public {
        // msg.sender is the deployer (and owner) so it initially has 1000 wei
        uint initialBalance = vulnerable.getBalance(address(this));
        assertEq(initialBalance, 1000, "Initial balance should be 1000 wei");
        
        // Attempt to transfer 15 wei, which is less than 20 wei
        bool success = vulnerable.transferFrom(address(this), 15 wei);
        assertTrue(success, "Transfer should succeed for values less than 20 wei");
        
        // Check balances update
        uint finalBalance = vulnerable.getBalance(address(this));
        // Since the transfer subtracts 15 from the sender and then adds it to the recipient, and both are the same,
        // balance remains unchanged.
        assertEq(finalBalance, initialBalance, "Balance should remain the same for self-transfer");
    }
    
    // Test that a transfer with a value >= 20 wei reverts due to the extraneous require
    function testTransferRevertsForExtraHandling() public {
        vm.expectRevert(bytes("value must be less than 20 wei"));
        // Attempt to transfer 25 wei, which should trigger the require and revert
        vulnerable.transferFrom(address(this), 25 wei);
    }
    
    // Test that the AttackContract successfully triggers the vulnerability (i.e., causes a revert)
    function testAttackContractRevertsTransfer() public {
        // Deploy the AttackContract with the address of the vulnerable token
        AttackContract attacker = new AttackContract(address(vulnerable));
        
        // The attack contract will call transferFrom with 25 wei which should revert.
        vm.expectRevert(bytes("value must be less than 20 wei"));
        attacker.attack();
    }
}
