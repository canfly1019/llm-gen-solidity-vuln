pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Interfaces and vulnerable contracts from the provided file

interface ICallable {
    function callMe() external;
}

contract HardcodedNotGood {
    address payable public _callable;
    ICallable public callable;

    constructor(address payable _target) payable {
        _callable = _target;
        callable = ICallable(_target);
    }

    // Vulnerable: Uses transfer which provides a fixed gas stipend of 2300
    function doTransfer(uint256 amount) public {
        _callable.transfer(amount);
    }

    // Vulnerable: Uses send which provides a fixed gas stipend of 2300
    function doSend(uint256 amount) public returns (bool) {
        bool success = _callable.send(amount);
        return success;
    }

    // Vulnerable: Uses call with a hardcoded gas limit of 10000
    function callLowLevel() public {
        (bool success, ) = _callable.call{value: 0, gas: 10000}("");
        require(success, "callLowLevel failed");
    }

    // Vulnerable: Uses call with a hardcoded gas limit of 10000
    function callWithArgs() public {
        (bool success, ) = address(callable).call{gas: 10000}(abi.encodeWithSignature("callMe()"));
        require(success, "callWithArgs failed");
    }
}

// Attacker contract that intentionally consumes a lot of gas in its fallback and callMe functions

contract Attacker is ICallable {
    event Called(address caller);

    // Fallback function that consumes gas
    fallback() external payable {
        // Intensive loop to consume gas
        for (uint i = 0; i < 1000; i++) {
            // Some dummy arithmetic
            uint x = i * i;
            x;
        }
        emit Called(msg.sender);
    }

    // callMe function that also consumes gas
    function callMe() external override {
        for (uint i = 0; i < 1000; i++) {
            uint x = i * i;
            x;
        }
        emit Called(msg.sender);
    }
}


contract HardcodedNotGoodTest is Test {
    HardcodedNotGood public vulnerable;
    Attacker public attacker;

    // send some ether to vulnerable contract when deploying
    uint constant initialBalance = 1 ether;
    
    function setUp() public {
        // Deploy attacker
        attacker = new Attacker();
        
        // Deploy HardcodedNotGood using the attacker as the _callable
        vulnerable = new HardcodedNotGood(payable(address(attacker)));

        // Fund the vulnerable contract with some ether to perform transfers
        vm.deal(address(vulnerable), initialBalance);
    }

    // Test that doTransfer fails because Attacker's fallback uses too much gas
    function testDoTransferFails() public {
        uint transferAmount = 0.1 ether;

        // Expect revert due to out of gas in the fallback
        vm.expectRevert();
        vulnerable.doTransfer(transferAmount);
    }

    // Test that doSend returns false because the call fails silently
    function testDoSendReturnsFalse() public {
        uint sendAmount = 0.1 ether;
        bool success = vulnerable.doSend(sendAmount);
        // Since send will return false instead of reverting, check the returned value
        assertFalse(success, "doSend should have returned false due to insufficient gas");
    }

    // Test that callLowLevel fails with the specified error message
    function testCallLowLevelFails() public {
        vm.expectRevert(bytes("callLowLevel failed"));
        vulnerable.callLowLevel();
    }

    // Test that callWithArgs fails with the specified error message
    function testCallWithArgsFails() public {
        vm.expectRevert(bytes("callWithArgs failed"));
        vulnerable.callWithArgs();
    }
}
