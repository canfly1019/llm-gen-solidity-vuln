pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// VulnerableNotification contract with the Fake Notification vulnerability
contract VulnerableNotification {
    address public owner;

    event Notified(address indexed from, address indexed to, uint256 quantity, string memo);

    constructor() {
        owner = msg.sender;
    }

    // Vulnerable function: does not check that 'to' is a specific intended address
    function eosponser(address from, address to, uint256 quantity, string calldata memo) public payable {
        // Forward funds to 'to'
        (bool success, ) = payable(to).call{value: quantity}("");
        require(success, "Transfer failed");

        emit Notified(from, to, quantity, memo);
    }

    // Allow the contract to receive Ether
    receive() external payable {}
}

// AttackVulnerable contract demonstrating the attack
contract AttackVulnerable {
    VulnerableNotification public vulnerableContract;
    address public victim;

    constructor(address _vulnerable, address _victim) {
        vulnerableContract = VulnerableNotification(payable(_vulnerable));
        victim = _victim;
    }

    // The attacker calls this function, forwarding the Ether to VulnerableNotification.eosponser with victim as the target
    function performAttack() public payable {
        require(msg.value > 0, "Send some ether");
        vulnerableContract.eosponser{value: msg.value}(msg.sender, victim, msg.value, "Fake notification");
    }
}

// Forge test for the Fake Notification vulnerability
contract FakeNotificationVulnerabilityTest is Test {
    VulnerableNotification vulnerable;
    AttackVulnerable attack;

    // Define test addresses for the attacker and the victim
    address attacker = address(0x1);
    address victim = address(0x2);

    // Event signature of Notified from VulnerableNotification for event checking
    event Notified(address indexed from, address indexed to, uint256 quantity, string memo);

    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableNotification();
        // Deploy the attack contract, providing it the victim's address
        attack = new AttackVulnerable(address(vulnerable), victim);
        // Fund the attacker address with sufficient Ether
        vm.deal(attacker, 10 ether);
    }

    // Test the attack: funds sent by the attacker are forwarded to the victim due to the vulnerability
    function testPerformAttackTransfersFundsToVictim() public {
        uint256 attackValue = 1 ether;
        uint256 victimInitialBalance = victim.balance;

        // Expect the Notified event to be emitted from the vulnerable contract
        vm.expectEmit(true, true, true, true);
        emit Notified(attacker, victim, attackValue, "Fake notification");

        // Prank as the attacker and call performAttack with 1 ether
        vm.prank(attacker);
        attack.performAttack{value: attackValue}();

        // Verify that the victim received the funds due to the attack
        uint256 victimFinalBalance = victim.balance;
        assertEq(victimFinalBalance, victimInitialBalance + attackValue, "Victim did not receive the expected funds");
    }

    // Test that calling performAttack without sending Ether reverts with the correct error
    function testPerformAttackFailsWhenNoEtherSent() public {
        vm.prank(attacker);
        vm.expectRevert(bytes("Send some ether"));
        attack.performAttack();
    }
}
