pragma solidity ^0.8.0;

// Import Foundry's standard library
import "forge-std/Test.sol";

// Vulnerable Contract as provided in the problem statement
contract C {
    // Initialize x with a fixed-length bytes string
    bytes public x = "012345678901234567890123456789";

    // Vulnerable: using public instead of external
    function test() public returns (uint) {
        // The following two operations simulate modifying x. In a real case,
        // unnecessary internal calls using memory instead of calldata may incur extra gas costs.
        // Here we illustrate state modifications to show the function can be called both internally and externally.
        // Note: The syntax below is not standard but is kept to mirror the vulnerability description.
        // In practice, you would call x.push(0x01) etc. For demo purposes, we simulate the change.
        x.push() = 0x01;
        x.push() = 0x02;
        return x.length;
    }
}

// Attack Contract that calls C.test() from an external call
contract Attack {
    C public target;

    // Set target contract address
    constructor(address _target) {
        target = C(_target);
    }

    // Attack function that initiates the call to target.test()
    function attack() public returns (uint) {
        // Call the vulnerable test() function
        uint len = target.test();
        return len;
    }
}

// Forge test contract demonstrating the vulnerability
contract VulnerabilityTest is Test {
    C vulnerable;
    Attack attacker;

    // Deploy the vulnerable contract before each test
    function setUp() public {
        vulnerable = new C();
    }

    // Test that calling test() externally via direct call works as expected
    function testDirectCall() public {
        // Verify initial length (should be 30 bytes from the string "012345678901234567890123456789")
        bytes memory initial = vulnerable.x();
        assertEq(initial.length, 30, "Initial x length should be 30");

        // Call test() directly from the test contract. This call is external but uses the public visibility
        uint newLength = vulnerable.test();
        // Since test() pushes two bytes, expected length = 30 + 2 = 32
        assertEq(newLength, 32, "x length should be 32 after direct test() call");

        // Read the state variable x directly to confirm
        bytes memory afterCall = vulnerable.x();
        assertEq(afterCall.length, 32, "x length in state should be 32 after direct call");
    }

    // Test that the attack contract can call test() and further modify x
    function testAttackCall() public {
        // Deploy the Attack contract with the address of the vulnerable contract
        attacker = new Attack(address(vulnerable));

        // Call attack() which internally calls vulnerable.test()
        uint lenAfterAttack = attacker.attack();
        // After one call from testDirectCall, x might be 30 if independent; here we are working on a fresh contract so it should be 30+2 = 32
        assertEq(lenAfterAttack, 32, "x length should be 32 after first attack call");

        // Calling attack() again to simulate repeated use: should add two more bytes, making the total length 34
        uint lenAfterSecondAttack = attacker.attack();
        assertEq(lenAfterSecondAttack, 34, "x length should be 34 after second attack call");

        // Confirm the change by reading state variable x directly
        bytes memory finalX = vulnerable.x();
        assertEq(finalX.length, 34, "Final x length in state should be 34 after two attack calls");
    }

    // Demonstrate that the vulnerability of using public (instead of external) allows both external and internal calls
    // which in a realistic scenario could lead to extra gas usage due to internal data copying
    function testInternalVersusExternal() public {
        // This test calls the test() function directly and via the Attack contract.
        // While we cannot easily quantify gas costs in a test, the fact that the function is callable both ways
        // makes it susceptible to unintended internal calls which may lead to extra gas consumption.

        // Direct call
        uint lengthDirect = vulnerable.test();
        // Expecting x: 30 + 2 = 32
        assertEq(lengthDirect, 32, "Direct call: x length should be 32");

        // Now deploy the attacker and call attack(), which makes an external call
        attacker = new Attack(address(vulnerable));
        uint lengthViaAttack = attacker.attack();
        // Now two additional bytes pushed; expected length 34
        assertEq(lengthViaAttack, 34, "Attack call: x length should be 34");
    }
}
