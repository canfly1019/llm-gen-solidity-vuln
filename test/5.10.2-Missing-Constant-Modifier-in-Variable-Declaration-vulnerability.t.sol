pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contracts as provided
contract C1 {
    // Vulnerability: these variables should be declared as constant
    uint pi = 314; // should be constant
    uint FavorateNumber = 25; // should be constant

    // Each call reads from storage
    function getNumbers() public view returns(uint) {
        return FavorateNumber * pi;
    }
}

contract C2 {
    // Vulnerability: pi should be declared as constant
    uint pi = 314;

    function getPi() public view returns(uint) {
        return pi;
    }
}

// Attack contract that demonstrates the gas inefficiency
interface IC1 {
    function getNumbers() external view returns(uint);
}

interface IC2 {
    function getPi() external view returns(uint);
}

contract Attack {
    IC1 public c1;
    IC2 public c2;

    // Provide addresses of deployed C1 and C2 contracts
    constructor(address _c1, address _c2) {
        c1 = IC1(_c1);
        c2 = IC2(_c2);
    }

    // Calls getNumbers and getPi, incurring extra gas cost due to storage reads
    function attack() public view returns(uint, uint) {
        uint numberResult = c1.getNumbers();
        uint piResult = c2.getPi();
        return (numberResult, piResult);
    }
}

// For comparison, we define optimized versions with constant variables
contract C1Optimized {
    uint constant pi = 314;
    uint constant FavorateNumber = 25;

    // As constants, getNumbers is marked pure (and inlined), saving gas
    function getNumbers() public pure returns(uint) {
        return FavorateNumber * pi;
    }
}

contract C2Optimized {
    uint constant pi = 314;

    function getPi() public pure returns(uint) {
        return pi;
    }
}

contract AttackOptimized {
    C1Optimized public c1;
    C2Optimized public c2;

    constructor(address _c1, address _c2) {
        c1 = C1Optimized(_c1);
        c2 = C2Optimized(_c2);
    }

    function attack() public view returns(uint, uint) {
        uint numberResult = c1.getNumbers();
        uint piResult = c2.getPi();
        return (numberResult, piResult);
    }
}

// Foundry test contract
contract VulnerabilityTest is Test {
    C1 public c1Vuln;
    C2 public c2Vuln;
    Attack public attackVuln;

    C1Optimized public c1Opt;
    C2Optimized public c2Opt;
    AttackOptimized public attackOpt;

    // Setup deploys both vulnerable and optimized contracts
    function setUp() public {
        // Deploy the vulnerable contracts
        c1Vuln = new C1();
        c2Vuln = new C2();
        attackVuln = new Attack(address(c1Vuln), address(c2Vuln));

        // Deploy the optimized contracts
        c1Opt = new C1Optimized();
        c2Opt = new C2Optimized();
        attackOpt = new AttackOptimized(address(c1Opt), address(c2Opt));
    }

    // Test to check that the attack contract returns the correct values
    function testAttackReturnsCorrectValues() public {
        (uint numResult, uint piResult) = attackVuln.attack();
        // Expected: FavorateNumber * pi = 25 * 314 = 7850 and pi = 314
        assertEq(numResult, 7850, "C1 getNumbers multiplication incorrect");
        assertEq(piResult, 314, "C2 getPi value incorrect");
    }

    // Test to simulate repeated calls and compare gas consumption between vulnerable and optimized versions
    function testGasConsumptionComparison() public {
        uint iterations = 10;
        uint totalGasVuln = 0;
        uint totalGasOpt = 0;

        // Loop and measure gas usage for the vulnerable attack calls
        for (uint i = 0; i < iterations; i++) {
            // Record starting gas
            uint gasStart = gasleft();
            // Use low-level staticcall for vulnerable attack
            (bool success, bytes memory data) = address(attackVuln).staticcall(abi.encodeWithSignature("attack()"));
            require(success, "Vulnerable attack call failed");
            // Calculate gas used in this call
            uint gasUsed = gasStart - gasleft();
            totalGasVuln += gasUsed;
        }

        // Loop and measure gas usage for the optimized attack calls
        for (uint i = 0; i < iterations; i++) {
            uint gasStart = gasleft();
            (bool success, bytes memory data) = address(attackOpt).staticcall(abi.encodeWithSignature("attack()"));
            require(success, "Optimized attack call failed");
            uint gasUsed = gasStart - gasleft();
            totalGasOpt += gasUsed;
        }

        uint avgGasVuln = totalGasVuln / iterations;
        uint avgGasOpt = totalGasOpt / iterations;

        // Log the average gas consumption for observation
        emit log_named_uint("Average gas used (vulnerable attack)", avgGasVuln);
        emit log_named_uint("Average gas used (optimized attack)", avgGasOpt);

        // Assert that the vulnerable contracts use more gas than the optimized versions
        // The exact margin may differ depending on the EVM, but the optimized version should be lower
        assertTrue(avgGasVuln > avgGasOpt, "Vulnerable contract did not use more gas than optimized version");
    }

    // Demonstrate repeated calls that could be exploited in a gas consumption attack scenario
    function testRepeatedCallsDoNotRevert() public {
        // In an actual attack, the attacker might repeatedly call the methods to increase gas cost.
        // Here we simply run the attack function multiple times to ensure there are no reverts and correct behavior.
        for (uint i = 0; i < 50; i++) {
            (uint numResult, uint piResult) = attackVuln.attack();
            assertEq(numResult, 7850, "Iteration: Incorrect multiplication result in vulnerable attack");
            assertEq(piResult, 314, "Iteration: Incorrect pi value in vulnerable attack");
        }
    }
}
