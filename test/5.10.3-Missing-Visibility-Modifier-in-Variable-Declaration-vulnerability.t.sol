pragma solidity ^0.8.0;
// SPDX-License-Identifier: UNLICENSED

import "forge-std/Test.sol";

// Import the vulnerable contract and attack contract
// Make sure the file path is correct relative to your project structure
import "../src/5.10.3-Missing-Visibility-Modifier-in-Variable-Declaration-vulnerability.sol";

contract VulnerabilityTest is Test {
    AttackVulnerable public attackContract;

    function setUp() public {
        // Deploy the attack contract which inherits TestStorageVulnerable
        attackContract = new AttackVulnerable();
    }

    // This test demonstrates that an attacker can read internal state variables via inheritance
    function testExploitAccessInternalState() public {
        // Populate storage by calling testStorage
        attackContract.testStorage();

        // Attack via the exploit function which directly reads internal state
        (uint arrayLength, uint deviceDataLength) = attackContract.exploit();

        // Assert that internal arrays have the intended length
        // uintarray had two pushes
        assertEq(arrayLength, 2, "uintarray should have two elements");
        // deviceDataArray had one push
        assertEq(deviceDataLength, 1, "deviceDataArray should have one element");
    }

    // Additionally, verify that public mapping functionality remains intact
    function testPublicMappingAccessible() public {
        attackContract.testStorage();
        
        // The addresses must match the checksums used in the vulnerable contract
        uint value1 = attackContract.uints1(0xbCcc714d56bc0da0fd33d96d2a87b680dD6D0DF6);
        uint value2 = attackContract.uints1(0xaee905FdD3ED851e48d22059575b9F4245A82B04);

        assertEq(value1, 88, "Address1 should map to 88");
        assertEq(value2, 99, "Address2 should map to 99");
    }
}
