pragma solidity ^0.8.0;
// SPDX-License-Identifier: UNLICENSED

import "forge-std/Test.sol";

// Vulnerable Contract with Redundant Fallback Function
contract ExRedundantVulnerable {
    // Redundant fallback: reverts when called with non-empty calldata
    fallback() external payable {
        revert("Vulnerable fallback: Do not use this function");
    }
    
    // Correct receive function: accepts Ether with empty calldata
    receive() external payable {
        // Just accept Ether
    }
    
    // Track the total Ether received via deposit functions only
    uint256 public totalReceived;
    
    // deposit() function, adds msg.value to totalReceived
    function deposit() external payable {
        totalReceived += msg.value;
    }
    
    // Each address can deposit Ether into its balance
    mapping(address => uint256) public balances;
    
    function depositFor() external payable {
        balances[msg.sender] += msg.value;
        totalReceived += msg.value;
    }
}

// Attack Contract demonstrating how sending non-empty calldata triggers fallback
contract AttackRedundant {
    ExRedundantVulnerable public vulnerableContract;
    
    // Constructor takes a payable address for the vulnerable contract
    constructor(address payable _vulnerableAddress) {
        vulnerableContract = ExRedundantVulnerable(_vulnerableAddress);
    }
    
    // Attack function: sends Ether with non-empty calldata to trigger fallback
    function attack() external payable {
        // Sending non-empty calldata ("attack") deliberately triggers fallback
        (bool success, ) = address(vulnerableContract).call{value: msg.value}(abi.encodePacked("attack"));
        require(success, "Attack failed: vulnerable fallback reverted transaction");
    }
}

// Helper interface to force calling fallback by invoking a non-existent function
interface IFallbackCaller {
    function nonExistent() external payable;
}

// Foundry Test Contract
contract RedundantVulnerabilityTest is Test {
    ExRedundantVulnerable vulnerable;
    AttackRedundant attacker;

    // Deploy the vulnerable contract and the attacker contract
    function setUp() public {
        vulnerable = new ExRedundantVulnerable();
        attacker = new AttackRedundant(payable(address(vulnerable)));
    }

    // Test that sending Ether with empty calldata (thus invoking receive()) works correctly
    function testReceiveFunctionality() public {
        uint256 sendValue = 1 ether;
        // Direct ETH transfer with empty calldata should trigger the receive() function
        (bool success, ) = payable(address(vulnerable)).call{value: sendValue}("");
        require(success, "Direct ETH transfer failed");

        /*
         Note: The receive() function in ExRedundantVulnerable does not update totalReceived.
         Only deposit() or depositFor() do that.
         So here we additionally test deposit() functionality.
        */
        uint256 depositValue = 2 ether;
        vulnerable.deposit{value: depositValue}();
        assertEq(vulnerable.totalReceived(), depositValue, "Deposit did not update totalReceived correctly");
    }

    // Test that sending ETH with non-empty calldata reverts due to the vulnerable fallback
    function testFallbackRevert() public {
        uint256 sendValue = 1 ether;
        // Cast the vulnerable contract address to an interface that declares a non-existent function.
        // This call will trigger the fallback function.
        IFallbackCaller caller = IFallbackCaller(address(vulnerable));
        
        vm.expectRevert("Vulnerable fallback: Do not use this function");
        caller.nonExistent{value: sendValue}();
    }

    // Test the attack demonstration: AttackRedundant calls vulnerable with non-empty calldata.
    // The attack() function expects the vulnerable fallback to revert, and hence it will itself revert
    // with a specific error message.
    function testAttackRedundant() public {
        uint256 attackValue = 1 ether;
        vm.expectRevert("Attack failed: vulnerable fallback reverted transaction");
        attacker.attack{value: attackValue}();
    }
}
