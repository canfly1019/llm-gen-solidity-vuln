pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable Contract with Shadowing vulnerability
contract Vulnerable {
    uint public balance; // state variable intended to record deposit amount

    // deposit function uses parameter with same name as state variable, which shadows the state variable
    function deposit(uint balance) public payable {
        require(msg.value == balance, "Incorrect value");
        // This assignment updates the parameter, not the state variable
        balance = msg.value;
    }

    function getBalance() public view returns(uint) {
        return balance;
    }
}

// Attack Contract demonstrating exploitation of the vulnerability
contract Attack {
    Vulnerable public vulnerable;

    constructor(address _vulnerable) {
        vulnerable = Vulnerable(_vulnerable);
    }

    function attack() public payable {
        // Call deposit with msg.value, the shadowing bug makes state variable remain unchanged
        vulnerable.deposit{value: msg.value}(msg.value);
    }
}

// Foundry test contract to demonstrate the shadowing vulnerability
contract ShadowingVulnerabilityTest is Test {
    Vulnerable vulnerable;
    Attack attacker;

    // Setup the Vulnerable contract before each test
    function setUp() public {
        vulnerable = new Vulnerable();
        attacker = new Attack(address(vulnerable));
    }

    // Test that deposit call does not update the state variable due to shadowing
    function testDepositDoesNotUpdateState() public {
        uint depositValue = 1 ether;

        // Call deposit directly from this contract with correct parameters
        vulnerable.deposit{value: depositValue}(depositValue);

        // Since the state variable is never updated, getBalance should return 0
        uint storedBalance = vulnerable.getBalance();
        assertEq(storedBalance, 0, "State variable should not have been updated due to shadowing");
    }

    // Test deposit reverts when msg.value does not match the parameter
    function testDepositRevertsOnIncorrectValue() public {
        uint depositValue = 1 ether;
        uint incorrectParam = 2 ether;

        // expect revert with error message "Incorrect value"
        vm.expectRevert(bytes("Incorrect value"));
        vulnerable.deposit{value: depositValue}(incorrectParam);
    }

    // Test the attack contract which exploits the vulnerability
    function testAttackDoesNotIncreaseStoredBalance() public {
        uint depositValue = 1 ether;

        // Simulate an external call to the attack contract with 1 ether
        attacker.attack{value: depositValue}();
        
        // Even though attack sent ether to deposit(), the state variable is still not updated
        uint storedBalance = vulnerable.getBalance();
        assertEq(storedBalance, 0, "Vulnerable contract's state balance should remain 0 after attack");
    }
}
