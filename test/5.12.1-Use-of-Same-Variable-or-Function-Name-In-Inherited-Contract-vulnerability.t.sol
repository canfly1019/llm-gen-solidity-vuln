pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contracts as provided

contract Tokensale {
    // 父合約 hardcap 變數，預設為 10000 ether
    uint public hardcap = 10000 ether;

    // 建構子
    constructor() {}

    // 回傳目前的 hardcap
    function fetchCap() public view returns(uint) {
        return hardcap;
    }
}

contract Presale is Tokensale {
    // 漏洞處：在建構子中錯誤地宣告了一個區域變數 hardcap，
    // 本意是要更新父合約的 hardcap 值為 1000 ether，但結果只是建立了一個局部變數，
    // 因此父合約的 hardcap 依然維持 10000 ether，不符合預期。
    constructor() Tokensale() {
        uint hardcap = 1000 ether;  // 漏洞重點：僅建立局部變數，未修改 state 變數
    }
}

// 攻擊合約用以展示漏洞效果
contract Attack {
    // 範例流程：
    // 1. 部署 Presale 合約。
    // 2. 呼叫 fetchCap()，預期應為 1000 ether，但實際回傳為 10000 ether，
    //    因為建構子內部的局部變數 hardcap 沒有影響到父合約 state 變數 hardcap。
    function attack(address presaleAddress) public view returns (uint) {
        return Presale(presaleAddress).fetchCap();
    }
}


contract VulnerabilityTest is Test {
    Presale presale;
    Attack attackContract;

    // Set up the contracts before each test
    function setUp() public {
        // Deploy the Presale contract
        presale = new Presale();
        // Deploy the Attack contract
        attackContract = new Attack();
    }

    // Test to demonstrate the vulnerable behavior in Presale
    function testPresaleHardcap() public {
        // Even though the developer intended to set hardcap to 1000 ether, it remains 10000 ether
        uint cap = presale.fetchCap();
        // Assert that the hardcap remains unchanged
        assertEq(cap, 10000 ether, "The hardcap should remain at 10000 ether due to variable shadowing");
    }

    // Test to demonstrate the attack contract retrieves the wrong hardcap due to the vulnerability
    function testAttackReturnsIncorrectHardcap() public {
        uint cap = attackContract.attack(address(presale));
        // The attack contract expected the hardcap to be changed to 1000 ether, but gets 10000 ether instead
        assertEq(cap, 10000 ether, "Attack contract retrieves 10000 ether, demonstrating the vulnerability");
    }

    // Optionally, if we try to simulate any revert or failure expected in secure versions, we can test that
    // But in this vulnerable contract, no revert is expected. We include a demonstration:
    function testNoRevertOnFetchCap() public {
        // There is no in-built safe check that will revert on calling fetchCap(), so ensure it runs
        uint cap;
        try presale.fetchCap() returns (uint result) {
            cap = result;
        } catch {
            revert("fetchCap should not revert");
        }
        assertEq(cap, 10000 ether, "fetchCap should return 10000 ether");
    }
}
