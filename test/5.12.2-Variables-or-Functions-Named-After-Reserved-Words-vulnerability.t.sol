pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as provided
contract Bug {
    // Vulnerability: using reserved keyword 'now' as state variable, shadows global now/block.timestamp
    uint now;

    // Vulnerability: naming this function 'assert' shadows built-in assert
    function assert(bool condition) public pure {
        // This function does nothing, which may lead to unintended behavior
    }

    // Public function to get next expiration. Supposed to add 259200 seconds (3 days) to current time, but uses uninitialized 'now'
    function get_next_expiration(uint earlier_time) public view returns (uint) {
        // The calculation mistakenly uses the state variable 'now' (which is always 0) instead of block.timestamp
        return now + 259200;
    }
}

// Attack contract to demonstrate the vulnerability
contract Attack {
    Bug public vulnerableContract;

    // Constructor takes the address of the vulnerable Bug contract
    constructor(address _vulnerableAddress) {
        vulnerableContract = Bug(_vulnerableAddress);
    }

    // Attack demonstration: call get_next_expiration and return the result
    function attack() public view returns (uint) {
        // The input parameter is irrelevant due to the vulnerability
        return vulnerableContract.get_next_expiration(block.timestamp);
    }
}

contract BugTest is Test {
    Bug bug;
    Attack attackContract;

    function setUp() public {
        // Deploy the vulnerable contract
        bug = new Bug();
        // Deploy the attack contract with the address of the bug contract
        attackContract = new Attack(address(bug));
    }

    function testGetNextExpirationVulnerability() public {
        // Ideally, get_next_expiration should compute block.timestamp + 259200
        // But due to the vulnerability, the 'now' variable is 0, so the calculation becomes 0 + 259200 = 259200
        uint expectedExpiration = 259200;

        // Call the vulnerable contract's function directly
        uint result = bug.get_next_expiration(block.timestamp);
        assertEq(result, expectedExpiration, "get_next_expiration did not return the expected fixed value due to the vulnerability");
    }

    function testAttackReturnsVulnerableValue() public {
        // The attack contract's attack function returns the same calculation
        uint result = attackContract.attack();
        uint expectedExpiration = 259200;
        assertEq(result, expectedExpiration, "Attack contract did not return the expected vulnerable fixed value");
    }

    // Additional test to show that block.timestamp is non-zero, so if it were used, the expiration would be different
    function testBlockTimestampIsNonZero() public {
        // vm.warp allows us to set the block.timestamp
        uint warpTime = 1000000;
        vm.warp(warpTime);
        // Though block.timestamp is set, get_next_expiration still uses state's now value (0), and returns 259200.
        uint result = bug.get_next_expiration(block.timestamp);
        uint wrongExpected = warpTime + 259200;
        // The following should fail if the vulnerability is patched. We use an assertion to verify that it DOES NOT equal the correct calculation.
        assertTrue(result != wrongExpected, "Vulnerable contract incorrectly used block.timestamp for calculation");
        // And, of course, it should equal 259200
        assertEq(result, 259200, "Vulnerable contract did not return the vulnerable result");
    }
}
