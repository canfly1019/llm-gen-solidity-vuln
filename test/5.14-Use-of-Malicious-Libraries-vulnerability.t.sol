pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// SPDX-License-Identifier: UNLICENSED

// 模擬惡意庫 (Malicious Library with harmful behavior)
library MaliciousLibrary {
    // 此處的 doSomething 函式故意回傳經過操縱的數值，將輸入值乘以 10000
    function doSomething(uint x) external pure returns (uint) {
        return x * 10000; // 惡意行為：操縱計算結果
    }
}

// 漏洞合約：使用了惡意庫來進行數值計算
contract ExampleLibrary {
    uint public data; // 狀態變數 data 存放計算結果

    // 漏洞函式：直接調用第三方惡意庫函式，計算結果將被操控
    function updateData(uint _data) public {
        data = MaliciousLibrary.doSomething(_data);
    }

    // 接收 Ether 的 fallback 和 receive 函式
    receive() external payable {}
    fallback() external payable {}
}

// 攻擊合約：攻擊者透過此合約觸發漏洞
contract AttackExample {
    ExampleLibrary public victim;

    // 注意：此處將 constructor 參數型別更改為 address payable
    constructor(address payable _victim) {
         victim = ExampleLibrary(_victim);
    }

    // 攻擊函式：呼叫 updateData 函式後， victim.data 將會被操控
    function attack() public {
         victim.updateData(10);
         // 預期 victim.data = 10 * 10000 = 100000
    }
}

contract TestMaliciousLibrary is Test {
    ExampleLibrary victim;
    AttackExample attacker;

    function setUp() public {
        victim = new ExampleLibrary();
        attacker = new AttackExample(payable(address(victim)));
    }

    // 測試直接調用 updateData 時惡意庫乘數的效果
    function testDirectCallManipulation() public {
        // 原本使用 5 進行計算，期望值是 5 * 10000 = 50000
        victim.updateData(5);
        uint expected = 5 * 10000;
        uint result = victim.data();
        assertEq(result, expected, "Data is not multiplied correctly by malicious library");
    }

    // 測試 AttackExample 攻擊合約是否能利用惡意庫漏洞
    function testAttackExploit() public {
        // 執行攻擊，攻擊後 victim.data 應為 10 * 10000 = 100000
        attacker.attack();
        uint expected = 10 * 10000;
        uint result = victim.data();
        assertEq(result, expected, "Attack did not manipulate data as expected");
    }
}
