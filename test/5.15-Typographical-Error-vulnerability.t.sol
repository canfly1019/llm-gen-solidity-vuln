// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

/*
   Vulnerable contract definition
*/
contract TypoOneCommandVulnerable {
    // State variable (initial value 1)
    uint public numberOne = 1;

    // Function intended to accumulate but due to typographical error, always resets to 1
    function alwaysOne() public {
        // Intended logic: numberOne += 1; But error: numberOne = 1;
        numberOne = 1;
    }
}

/*
   Attack contract targeting the vulnerability
*/
contract AttackTypoVulnerable {
    TypoOneCommandVulnerable public target;

    // Constructor accepts address of the vulnerable contract
    constructor(address _targetAddress) {
        target = TypoOneCommandVulnerable(_targetAddress);
    }

    // Attack function that repeatedly calls alwaysOne()
    function attack() public {
        for (uint i = 0; i < 5; i++) {
            target.alwaysOne();
        }
    }

    // Returns the current value of numberOne from the target contract
    function getNumber() public view returns (uint) {
        return target.numberOne();
    }
}


/*
   Foundry test contract
*/
contract TypoOneCommandVulnerableTest is Test {
    TypoOneCommandVulnerable vulnerable;
    AttackTypoVulnerable attacker;

    function setUp() public {
        vulnerable = new TypoOneCommandVulnerable();
        attacker = new AttackTypoVulnerable(address(vulnerable));
    }

    // Test to confirm that the accumulation intended in alwaysOne() has failed
    function testAlwaysOneLogic() public {
        // Initially, the value is 1
        uint initial = vulnerable.numberOne();
        assertEq(initial, 1, "Initial value should be 1");

        // Call alwaysOne() repeatedly (simulate expected cumulative behavior)
        for (uint i = 0; i < 10; i++) {
            vulnerable.alwaysOne();
        }

        // Even though the caller may expect accumulation, due to typographic error, the value remains 1
        uint finalValue = vulnerable.numberOne();
        assertEq(finalValue, 1, "After repeated calls, numberOne should remain 1 due to faulty logic");
    }

    // Test using the attack contract to simulate the exploitation of the vulnerability
    function testAttackVulnerability() public {
        // Execute attack which calls alwaysOne() multiple times
        attacker.attack();
        
        // The attack contract reads the target's numberOne, which should remain 1
        uint result = attacker.getNumber();
        assertEq(result, 1, "Attack contract should reveal that numberOne stays at 1");
    }
}
