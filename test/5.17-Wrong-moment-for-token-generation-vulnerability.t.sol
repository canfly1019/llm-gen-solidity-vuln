pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// VulnerableTokenSale from the given contract
contract VulnerableTokenSale {
    mapping(address => uint256) public balances;
    uint256 public tokenPrice = 1 ether;

    function buyTokens(address beneficiary) public payable {
        require(msg.value >= tokenPrice, "Insufficient Ether");
        uint256 tokens = msg.value / tokenPrice;
        balances[beneficiary] += tokens;
    }
}

// Attack contract
contract AttackVulnerable {
    VulnerableTokenSale public vulnerableSale;
    address public attacker;

    constructor(address _vulnerableSale) {
        vulnerableSale = VulnerableTokenSale(_vulnerableSale);
        attacker = msg.sender;
    }

    function attack() public payable {
        require(msg.sender == attacker, "Not authorized");
        // Even if someone else sends the funds, the tokens are minted for attacker
        vulnerableSale.buyTokens{value: msg.value}(attacker);
    }

    function getMyTokens() public view returns (uint256) {
        return vulnerableSale.balances(attacker);
    }
}

contract VulnerableTokenSaleTest is Test {
    VulnerableTokenSale public vulnerableSale;
    AttackVulnerable public attackContract;

    // Some preset addresses
    address public attacker = address(0xABcD);
    address public thirdParty = address(0xBEEF);

    function setUp() public {
        // Deploy the vulnerable token sale contract
        vulnerableSale = new VulnerableTokenSale();

        // Fund attacker and thirdParty with enough Ether, so that OutOfFunds error does not occur
        vm.deal(attacker, 10 ether);
        vm.deal(thirdParty, 10 ether);

        // Deploy the attack contract using the attacker account
        vm.prank(attacker);
        attackContract = new AttackVulnerable(address(vulnerableSale));
    }

    function testInsufficientEtherReverts() public {
        // Test that buying tokens with insufficient Ether reverts
        vm.expectRevert(bytes("Insufficient Ether"));
        vulnerableSale.buyTokens{value: 0.5 ether}(attacker);
    }

    function testAttackVulnerability() public {
        // Using the attacker account, call the attack function with sufficient Ether
        uint256 attackValue = 2 ether;
        vm.prank(attacker);
        // Call attack, which should mint tokens to the attacker address
        attackContract.attack{value: attackValue}();

        // Calculate expected tokens - tokenPrice is 1 ether
        uint256 expectedTokens = attackValue / vulnerableSale.tokenPrice();
        uint256 actualTokens = vulnerableSale.balances(attacker);

        assertEq(actualTokens, expectedTokens, "Attacker should receive correct token amount");
    }

    function testExploitUsingWrongBeneficiaryByThirdParty() public {
        // In this test, thirdParty calls buyTokens but specifies attacker as beneficiary
        uint256 purchaseValue = 1 ether;
        vm.prank(thirdParty);
        vulnerableSale.buyTokens{value: purchaseValue}(attacker);

        // The tokens are minted for attacker even though thirdParty paid
        uint256 expectedTokens = purchaseValue / vulnerableSale.tokenPrice();
        uint256 actualTokens = vulnerableSale.balances(attacker);

        assertEq(actualTokens, expectedTokens, "Attacker should receive tokens even when third party pays");
    }
}
