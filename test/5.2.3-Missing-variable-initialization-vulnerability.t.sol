pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract
contract Uninitialized {
    // Vulnerability: destination is not initialized and defaults to address(0)
    address payable public destination;

    // transfer() function: sends received Ether to destination
    function transfer() public payable {
        // Vulnerability: destination is address(0) if not set, so funds are sent to address(0)
        destination.transfer(msg.value);
    }

    // Fallback receive function
    receive() external payable {}
}

// Attack contract to trigger the vulnerability
contract Attack {
    Uninitialized public target;

    constructor(address payable _target) {
        target = Uninitialized(_target);
    }

    // Attack entry: send Ether to the vulnerable contract
    function attack() external payable {
        target.transfer{value: msg.value}();
    }
}

contract MissingVarInitTest is Test {
    Uninitialized vulnerable;
    Attack attacker;
    
    // Setup the environment
    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new Uninitialized();
        // Deploy the attacker contract and pass vulnerable's address
        attacker = new Attack(payable(address(vulnerable)));
    }

    // Test the vulnerability by triggering transfer through the Attack contract
    function testAttackBurnsFundsViaAttackContract() public {
        // Choose an amount to attack with
        uint256 attackAmount = 1 ether;
        
        // Record the balance of the burn address before the attack
        uint256 burnBalanceBefore = address(0).balance;
        
        // Execute the attack: we call attacker.attack with attackAmount
        // The caller (this contract) sends attackAmount Ether
        attacker.attack{value: attackAmount}();
        
        // After the call, the vulnerable contract's transfer() function sends the Ether to address(0)
        // Check that the vulnerable contract doesn't hold any Ether
        assertEq(address(vulnerable).balance, 0, "Vulnerable contract should have 0 balance after transfer");
        
        // Check that the burn address (address(0)) had its balance increased by attackAmount
        uint256 burnBalanceAfter = address(0).balance;
        assertEq(burnBalanceAfter, burnBalanceBefore + attackAmount, "Burn address did not receive the expected Ether");
    }
    
    // Test the vulnerability when calling transfer() directly
    function testDirectTransferBurnsFunds() public {
        uint256 sendAmount = 0.5 ether;
        
        // Record the burn address balance before
        uint256 burnBalanceBefore = address(0).balance;
        
        // Directly call transfer() on the vulnerable contract with sendAmount
        // Using low-level call from this contract
        vulnerable.transfer{value: sendAmount}();
        
        // Check that vulnerable contract has 0 funds after transfer call
        assertEq(address(vulnerable).balance, 0, "Vulnerable contract should have 0 balance after direct transfer");
        
        // Check that the burn address received the sent Ether
        uint256 burnBalanceAfter = address(0).balance;
        assertEq(burnBalanceAfter, burnBalanceBefore + sendAmount, "Burn address did not receive the expected Ether via direct call");
    }

    // Test to ensure that when no Ether is sent nothing unexpected happens
    function testNoEtherNoTransfer() public {
        // Even if transfer() is called without Ether, it should simply forward 0 Ether to address(0)
        uint256 burnBalanceBefore = address(0).balance;
        vulnerable.transfer{value: 0}();
        uint256 burnBalanceAfter = address(0).balance;
        assertEq(burnBalanceAfter, burnBalanceBefore, "Burn address's balance should remain unchanged if no Ether is sent");
    }

    // Fallback to allow receiving Ether in this contract if needed
    receive() external payable {}
}
