pragma solidity ^0.8.0;
// SPDX-License-Identifier: UNLICENSED

import "forge-std/Test.sol";

// Vulnerable contract that has a hardcoded BENEFICIARY address. Donation funds are always forwarded to this fixed address.
contract VulnerableContract {
    // Vulnerability: Hardcoded beneficiary address instead of using an input parameter
    address public constant BENEFICIARY = 0x1234567890123456789012345678901234567890;

    // When a donation is made, the entire funds are forwarded to the hardcoded BENEFICIARY
    function donate() external payable {
        require(msg.value > 0, "Must send some Ether");
        payable(BENEFICIARY).transfer(msg.value);
    }

    // Fallback to accept ETH
    receive() external payable {}
}

// Attacker contract which demonstrates how an attacker might try to abuse the vulnerability
contract Attacker {
    VulnerableContract public vulnerable;

    constructor(address _vulnerable) {
        vulnerable = VulnerableContract(payable(_vulnerable));
    }

    // Attack function which forwards funds via VulnerableContract's donate():
    // Note: Due to hardcoded BENEFICIARY, the funds still go to the fixed address.
    function attack() external payable {
        vulnerable.donate{value: msg.value}();
    }

    // Fallback to accept ETH
    receive() external payable {}
}

// Foundry Test Contract to demonstrate the vulnerability
contract VulnerableContractTest is Test {
    VulnerableContract public vulnerable;
    Attacker public attackerContract;
    // Hardcoded beneficiary address from the VulnerableContract
    address payable constant BENEFICIARY = payable(0x1234567890123456789012345678901234567890);

    // Set up for tests
    function setUp() public {
        vulnerable = new VulnerableContract();
    }

    // Test that a donation forwards sent ETH to the hardcoded beneficiary address
    function testDonateForwardsFunds() public {
        // Prepare donor account with 10 ether
        address donor = address(0xABCD);
        vm.deal(donor, 10 ether);

        // Record initial balance of the beneficiary
        uint256 initialBeneficiaryBalance = BENEFICIARY.balance;

        // Have donor call donate with 1 ether
        vm.prank(donor);
        vulnerable.donate{value: 1 ether}();

        // After donate() the beneficiary should receive the funds
        uint256 finalBeneficiaryBalance = BENEFICIARY.balance;
        assertEq(finalBeneficiaryBalance - initialBeneficiaryBalance, 1 ether, "Beneficiary did not receive the correct funds");
    }

    // Test that calling donate without sending any Ether fails
    function testDonateWithoutEtherReverts() public {
        // Prepare donor account
        address donor = address(0xBEEF);
        vm.prank(donor);

        // Expect revert because 0 ether is sent
        vm.expectRevert(bytes("Must send some Ether"));
        vulnerable.donate();
    }

    // Test the attacker contract demonstration which calls vulnerable.donate() via attack()
    function testAttackSendsFundsToHardcodedBeneficiary() public {
        // Deploy attacker contract with the address of the vulnerable contract
        attackerContract = new Attacker(address(vulnerable));

        // Prepare an attacker account with 10 ether and a separate beneficiary balance check
        address attackerUser = address(0xCAFE);
        vm.deal(attackerUser, 10 ether);

        // Record initial balance of the hardcoded beneficiary
        uint256 initialBeneficiaryBalance = BENEFICIARY.balance;

        // Attacker account calls attack() on the attacker contract. Funds are forwarded to VulnerableContract.donate()
        vm.prank(attackerUser);
        attackerContract.attack{value: 2 ether}();

        // Verify that the funds have been transferred to the hardcoded beneficiary, not retained by attacker
        uint256 finalBeneficiaryBalance = BENEFICIARY.balance;
        assertEq(finalBeneficiaryBalance - initialBeneficiaryBalance, 2 ether, "Beneficiary did not receive funds from attack");
    }

    // Additional test: Ensure that when donating via the attacker contract, the attacker does not get the funds
    function testAttackerDoesNotReceiveFunds() public {
        attackerContract = new Attacker(address(vulnerable));

        // Pre-fund the attacker contract with 1 ether to differentiate balances (though it won't be used for funds recovery)
        payable(address(attackerContract)).transfer(1 ether);

        // Record attacker's contract balance before attack call
        uint256 attackerInitialBalance = address(attackerContract).balance;

        // Call attack() from a funded account, sending additional ether, funds are forwarded to BENEFICIARY
        address attackerUser = address(0xDEAD);
        vm.deal(attackerUser, 5 ether);
        vm.prank(attackerUser);
        attackerContract.attack{value: 1 ether}();

        // After the attack, the attacker contract's balance should not have increased by the donated value
        uint256 attackerFinalBalance = address(attackerContract).balance;
        // The attacker's balance should remain the same as it did not capture the funds
        assertEq(attackerFinalBalance, attackerInitialBalance, "Attacker contract unexpectedly received funds");
    }

    // Allow the test contract to receive Ether
    receive() external payable {}
}
