// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract from file 5.3-Isolation-Phenomena-vulnerability.sol
contract IsolationVulnerable {
    // 漏洞重點：使用 state variable 和 block.timestamp 改變查詢結果
    uint public constant baseReward = 100;

    // vulnerable 查詢函數：依賴動態變數 block.timestamp 作運算
    function getReward() public view returns (uint) {
        // 注意：區塊時間可能因共識機制而略有不同，導致同一查詢在不同區塊中得到不同結果
        return baseReward + (block.timestamp % 10);  // 漏洞重點：使用 block.timestamp 作為折加 Bonus
    }
}

// 攻擊者合約示例
contract Attacker {
    IsolationVulnerable public vulnerable;

    // 部署時傳入目標合約的地址
    constructor(address _vulnerableAddress) {
        vulnerable = IsolationVulnerable(_vulnerableAddress);
    }

    // 攻擊示例：攻擊者透過多次呼叫 getReward 並觀察返回結果，在獲得理想的 bonus 時發起關鍵交易
    // 此示例僅示範回傳漏洞合約的 getReward 結果
    function executeAttack() external view returns (uint optimalReward) {
        optimalReward = vulnerable.getReward();
    }
}

contract IsolationVulnerableTest is Test {
    IsolationVulnerable vulnerable;
    Attacker attacker;

    // setUp deploys the vulnerable contract and attacker contract
    function setUp() public {
        vulnerable = new IsolationVulnerable();
        attacker = new Attacker(address(vulnerable));
    }

    // Test that the reward value changes with different block timestamps to simulate isolation phenomena
    function testInconsistentRewardAcrossBlocks() public {
        // Set block.timestamp to a known value
        vm.warp(1000); // 1000 % 10 = 0, so reward should be 100
        uint reward1 = vulnerable.getReward();
        assertEq(reward1, 100, "Reward should be 100 at timestamp 1000");

        // Move forward to a block timestamp that gives a different result
        vm.warp(1005); // 1005 % 10 = 5, so reward should be 105
        uint reward2 = vulnerable.getReward();
        assertEq(reward2, 105, "Reward should be 105 at timestamp 1005");

        // Again, test with another timestamp
        vm.warp(1010); // 1010 % 10 = 0, so reward should be 100
        uint reward3 = vulnerable.getReward();
        assertEq(reward3, 100, "Reward should be 100 at timestamp 1010");

        // Assert the values are not constant across blocks
        assertTrue(reward1 != reward2, "Reward should differ between blocks");
    }

    // Test the Attacker contract's ability to read the reward, demonstrating exploitation likelihood
    function testAttackerExecuteAttack() public {
        // Warp to a deterministic block.timestamp
        vm.warp(1234); // 1234 % 10 = 4, expected reward = 104
        uint rewardFromAttacker = attacker.executeAttack();
        assertEq(rewardFromAttacker, 104, "Attacker should see reward = 104");
    }

    // Additional demonstration: simulate multiple queries to observe the isolated reward phenomenon
    function testMultipleQueriesForOptimalReward() public {
        // We simulate that an attacker queries multiple blocks to find the optimal reward
        // For simplicity, assuming attacker prefers a reward bonus of 9 (i.e., highest possible bonus)
        uint optimalBonus = 9;
        uint optimalReward;
        uint blockTimeFound;

        // iterate over a small range of block timestamps
        for (uint ts = 1000; ts < 1020; ts++) {
            vm.warp(ts);
            uint currentReward = vulnerable.getReward();
            if ((currentReward - 100) == optimalBonus) {
                optimalReward = currentReward;
                blockTimeFound = ts;
                break;
            }
        }

        // Ensure we found a block time that yields the optimal reward
        assertEq(optimalReward, 100 + optimalBonus, "Did not find the optimal reward");
        emit log_named_uint("Optimal reward found at timestamp", blockTimeFound);
    }
}
