pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract with phantom reads vulnerability
contract VulnerablePhantom {
    uint256[] public records;

    function addRecord(uint256 value) public {
        records.push(value);
    }

    function startProcess() public view returns (uint256) {
        return records.length;
    }

    function finishProcess(uint256 snapshot) public view returns (uint256 sum) {
        require(snapshot <= records.length, "Data modified");
        for (uint256 i = 0; i < snapshot; i++) {
            sum += records[i];
        }
        return sum;
    }
}

// Attack contract demonstrating exploitation of phantom reads vulnerability
contract AttackPhantom {
    VulnerablePhantom public vulnerable;

    constructor(address vulnerableAddress) {
        vulnerable = VulnerablePhantom(vulnerableAddress);
    }

    // The attack function simulates obtaining an outdated snapshot
    // In an environment without atomicity guarantees (e.g., Hyperledger Fabric),
    // this could be exploited by triggering state changes between the snapshot and finishProcess calls.
    function attack() public view returns (uint256) {
        uint256 snapshot = vulnerable.startProcess();
        // In a real attack scenario, state could have been modified between the above call and the following one.
        uint256 result = vulnerable.finishProcess(snapshot);
        return result;
    }
}

contract VulnerablePhantomTest is Test {
    VulnerablePhantom vulnerable;
    AttackPhantom attacker;

    function setUp() public {
        vulnerable = new VulnerablePhantom();
        attacker = new AttackPhantom(address(vulnerable));
    }

    // Test to demonstrate the phantom read vulnerability
    function testPhantomExploit() public {
        // Initial state: add two records
        vulnerable.addRecord(10);
        vulnerable.addRecord(20);

        // Attacker takes a snapshot in one transaction (simulate first step)
        uint256 snapshot = vulnerable.startProcess();
        assertEq(snapshot, 2, "Snapshot should record 2 records");

        // In a separate transaction, someone adds another record resulting in a phantom record
        // (Simulate the timing gap between startProcess() and finishProcess())
        vulnerable.addRecord(30);

        // Now finish processing using the outdated snapshot
        uint256 sum = vulnerable.finishProcess(snapshot);
        // Expected sum with the snapshot (only first two records): 10 + 20 = 30
        // However, the current total sum in records would be 10 + 20 + 30 = 60
        assertEq(sum, 30, "Sum computed using outdated snapshot should be 30");

        // If we were to process with the current state, we would get a different result
        uint256 currentSnapshot = vulnerable.startProcess();
        uint256 fullSum = vulnerable.finishProcess(currentSnapshot);
        assertEq(fullSum, 60, "Sum computed with current state should be 60");
    }

    // Test that finishProcess reverts if provided snapshot is greater than the current records length
    function testSnapshotMismatchRevert() public {
        // Add one record
        vulnerable.addRecord(100);
        
        // Provide an out-of-date snapshot which is larger than records.length
        uint256 fakeSnapshot = 2; // But records.length is only 1
        vm.expectRevert(bytes("Data modified"));
        vulnerable.finishProcess(fakeSnapshot);
    }

    // Test using the AttackPhantom contract to simulate the vulnerability
    function testAttackContract() public {
        // Set up initial records
        vulnerable.addRecord(5);
        vulnerable.addRecord(15);

        // Attacker takes a snapshot via direct call
        uint256 snapshot = vulnerable.startProcess();
        assertEq(snapshot, 2, "Snapshot should be 2 records");

        // In a separate transaction, add a phantom record
        vulnerable.addRecord(25);

        // The attacker now invokes the attack function, which internally calls startProcess & finishProcess
        // Note: Because attack() is a view function and EVM transactions are atomic, in a single call,
        // the state is consistent. Thus, to simulate the attack, we force the snapshot external to the attack contract.
        // So here we replicate the idea by calling finishProcess with the old snapshot directly.
        uint256 attackedSum = vulnerable.finishProcess(snapshot);
        assertEq(attackedSum, 20, "Attacker's computed sum should only use the original snapshot records (5 + 15 = 20)");
        
        // For comparison, the full sum with all records is 5 + 15 + 25 = 45
        uint256 currentSum = vulnerable.finishProcess(vulnerable.startProcess());
        assertEq(currentSum, 45, "Full sum computed with current records should be 45");
    }
}
