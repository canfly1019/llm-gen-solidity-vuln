pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract and the attacker contract
// It is assumed that the contracts from 5.3.2-Dirty-Reads-vulnerability.sol are compiled and available

interface IAttacker {
    function notify(uint oldValue) external;
}

contract VulnerableContract {
    uint public value;

    constructor() {
        value = 0;
    }
    
    function updateValueAndNotify(uint newValue, address attackerAddr) public {
        // Read the current value (potential dirty read risk)
        uint oldValue = value;
        
        // Callback to external attacker contract, exposing the stale data
        IAttacker(attackerAddr).notify(oldValue);
        
        // Update the state variable AFTER callback
        value = newValue;
    }
}

contract Attacker {
    VulnerableContract public vulnerableContract;
    uint public capturedValue;

    event AttackNotified(uint oldValue);

    constructor(address vulnerableAddr) {
        vulnerableContract = VulnerableContract(vulnerableAddr);
    }

    // Initiates the attack
    function attack() external {
        // Attack scenario: pass in new value 100, but the callback will capture the old value
        vulnerableContract.updateValueAndNotify(100, address(this));
    }

    // Callback function that will be called from VulnerableContract
    function notify(uint oldValue) external {
        capturedValue = oldValue;
        emit AttackNotified(oldValue);
        // Further attack logic might be implemented based on oldValue
    }
}

contract DirtyReadsTest is Test {
    VulnerableContract public vulnerable;
    Attacker public attacker;

    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableContract();
        // Deploy the attacker contract with a pointer to the vulnerable contract
        attacker = new Attacker(address(vulnerable));
    }

    function testDirtyReadVulnerability() public {
        // Check initial state: value should be 0
        assertEq(vulnerable.value(), 0, "Initial value is not 0");

        // Perform the attack: call attacker.attack, which in turn calls updateValueAndNotify
        attacker.attack();

        // After the attack, the vulnerable contract's state variable 'value' is updated to 100
        assertEq(vulnerable.value(), 100, "Value was not updated correctly");

        // However, the attacker captured the dirty (stale) value before the update, which should be 0
        assertEq(attacker.capturedValue(), 0, "Dirty read vulnerability not demonstrated (captured value is incorrect)");
    }
}
