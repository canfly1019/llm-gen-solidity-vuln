pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract
contract Bank {
    mapping(address => uint256) public balances;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 _amount) public {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        // Incorrect function signature call
        (bool success, ) = msg.sender.call(abi.encodeWithSignature("performWithdraw(bool,uint256)", false, _amount));
        require(success, "Call failed");
        
        // Normal withdrawal flow
        balances[msg.sender] -= _amount;
        payable(msg.sender).transfer(_amount);
    }

    // Intended internal function (not callable externally)
    function performWithdraw(uint256 _amount) public {
        // normal logic, not used
    }

    // Fallback receive function to accept ETH
    receive() external payable {}
}

// Attack contract
contract Attack {
    Bank public bank;
    address public attacker;

    // Constructor now uses payable address
    constructor(address payable _bank) {
        bank = Bank(_bank);
        attacker = msg.sender;
    }

    // The function with the wrong signature that Bank.withdraw will call
    function performWithdraw(bool /*_flag*/, uint256 /*_amount*/) public {
        // Malicious logic: drain all ETH from Bank
        // Note: Transfer uses 2300 gas, if this call is triggered via low-level call it might succeed
        // but then the subsequent legitimate transfer in Bank.withdraw will fail due to lack of funds.
        payable(attacker).transfer(address(bank).balance);
    }

    function attack() public payable {
        require(msg.value > 0, "Need ETH to attack");
        bank.deposit{value: msg.value}();
        bank.withdraw(msg.value);
    }

    receive() external payable {}
}

contract VulnerabilityTest is Test {
    Bank bank;
    Attack attackContract;
    address user = address(0xbEEF);
    address attacker = address(0xcafE);

    function setUp() public {
        bank = new Bank();
        // Fund a user account and deposit funds into Bank
        vm.deal(user, 10 ether);
        vm.prank(user);
        bank.deposit{value: 10 ether}();
    }

    // Test that an externally owned account (EOA) can withdraw normally
    function testWithdrawFromEOA() public {
        uint256 initialUserBalance = user.balance;
        vm.startPrank(user);
        bank.withdraw(10 ether);
        vm.stopPrank();

        // Since EOA has no code, the low-level call in withdraw returns success
        // and the withdrawal transfer succeeds
        assertEq(address(user).balance, initialUserBalance + 10 ether);
        // Bank contract should have 0 balance now
        assertEq(address(bank).balance, 0);
    }

    // Test that if a contract (Attack) attempts to use the vulnerability,
    // the malicious call drains the Bank before the legitimate transfer,
    // causing the final transfer to fail and the transaction to revert.
    function testExploitAttackReverts() public {
        // Provide extra ETH to the bank owner to ensure bank holds sufficient funds
        // Bank already has 10 ether from setUp
        vm.deal(attacker, 1 ether);
        vm.prank(attacker);
        attackContract = new Attack(payable(address(bank)));

        // When the attack contract calls attack(), the flow will be:
        // - deposit(msg.value) increases its balance by 1 ether
        // - withdraw(1 ether) triggers Attack.performWithdraw which drains bank's ETH
        // - then Bank.withdraw attempts to transfer 1 ether to the attack contract, but bank's balance is 0
        // Thus, the transaction reverts with an error (or fails).
        vm.prank(attacker);
        // We expect a revert due to the final transfer failure (or the require in withdraw)
        vm.expectRevert();
        attackContract.attack{value: 1 ether}();

        // Even though the attack drains funds internally, the overall transaction reverts,
        // so Bank's balance remains unchanged.
        // The vulnerability is demonstrated by the fact that a contract can intercept the low-level call.
        assertEq(address(bank).balance, 10 ether);
    }
}
