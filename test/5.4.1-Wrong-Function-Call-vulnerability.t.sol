// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// The IReservable interface
interface IReservable {
    function reserve(uint seats) external payable;
}

// Vulnerable contract as provided
contract FoodBudgetWallet_Vulnerable {
    // Vulnerability: _restaurant is hardcoded to an incorrect address
    address payable constant private _restaurant = payable(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2);

    constructor() payable { }

    // The makeReservation function erroneously sends 1 ether to _restaurant
    function makeReservation(uint seats) public {
        IReservable r = IReservable(_restaurant);
        r.reserve{value: 1 ether}(seats);
    }

    // Allow receiving Ether
    receive() external payable { }
}

// FakeReservation contract deployed by the attacker to exploit the vulnerability
contract FakeReservation {
    event ReceivedReservation(address indexed from, uint seats, uint value);

    // The reserve function mimics the IReservable interface but performs malicious operations
    function reserve(uint seats) external payable {
        emit ReceivedReservation(msg.sender, seats, msg.value);
        // Malicious action: transfer ALL balance of this contract to the caller (which is NOT the attacker!)
        payable(msg.sender).transfer(address(this).balance);
    }

    // Allow receiving Ether
    receive() external payable { }
}

// Simplified AttackDemo contract (for demonstration though not used directly in the test)
contract AttackDemo {
    FoodBudgetWallet_Vulnerable public victim;
    FakeReservation public attackerContract;

    constructor() payable {
        // Deploy FakeReservation (attacker-controlled)
        attackerContract = new FakeReservation();
        // Deploy the victim contract
        victim = new FoodBudgetWallet_Vulnerable{value: 2 ether}();
    }

    // Execute the attack: triggers victim.makeReservation, which calls attackerContract.reserve
    function executeAttack(uint seats) external payable {
        require(msg.value >= 1 ether, "min 1 ether required");
        victim.makeReservation(seats);
    }

    // Allow receiving Ether
    receive() external payable { }
}

// Our Foundry test contract
contract FoodBudgetWalletVulnerableTest is Test {
    FoodBudgetWallet_Vulnerable victim;
    
    // The hardcoded restaurant address from the vulnerable contract
    address constant restaurant = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;

    // This event is used to verify that FakeReservation's reserve was called
    event ReceivedReservation(address indexed from, uint seats, uint value);

    function setUp() public {
        // Fund the test contract so that we can fund victim if needed
        vm.deal(address(this), 10 ether);
        
        // Deploy the vulnerable contract with an initial balance of 2 ether
        victim = (new FoodBudgetWallet_Vulnerable){value: 2 ether}();

        // Use vm.etch to simulate attacker deploying FakeReservation at the fixed restaurant address
        // vm.etch replaces the code at 'restaurant' with the runtime code of FakeReservation
        vm.etch(restaurant, type(FakeReservation).runtimeCode);
        
        // Also fund the restaurant contract with 0 ether initially (shouldn't matter)
        vm.deal(restaurant, 0);
    }

    // Test demonstrating the vulnerability of calling a function on the wrong address
    function testWrongFunctionCallVulnerability() public {
        uint seats = 3;

        // Record initial balance of the victim
        uint initialVictimBalance = address(victim).balance;

        // Expect the FakeReservation's ReceivedReservation event to be emitted
        // Note: In the call, msg.sender inside FakeReservation.reserve will be the victim contract address
        vm.expectEmit(true, false, false, true);
        emit ReceivedReservation(address(victim), seats, 1 ether);

        // Call makeReservation. This call will forward 1 ether from victim to FakeReservation
        // The victim's balance will decrease by 1 ether and then immediately receive the ether back from FakeReservation
        victim.makeReservation(seats);

        // After the call, the balance of the victim should be unchanged because the 1 ether was refunded
        uint finalVictimBalance = address(victim).balance;
        assertEq(finalVictimBalance, initialVictimBalance, "Victim balance should be unchanged after refund");

        // Additionally, verify that the restaurant (malicious contract) ends with zero balance
        assertEq(restaurant.balance, 0, "Restaurant (attacker) contract balance should be zero");
    }

    // Additional test: demonstrate that if the fake contract wasn't deployed, the call would fail
    function testMakeReservationRevertWhenNoContractAtAddress() public {
        // Remove the fake contract by etching an empty code at the restaurant address
        vm.etch(restaurant, "");
        
        // Expect the call to revert because the call to reserve() will fail (no contract code)
        vm.expectRevert();
        victim.makeReservation(2);
    }
}
