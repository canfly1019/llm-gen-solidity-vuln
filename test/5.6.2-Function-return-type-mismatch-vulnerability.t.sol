pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/5.6.2-Function-return-type-mismatch-vulnerability.sol";


contract VulnerabilityTest is Test {
    Attack attack;
    Token vulnerableToken;
    Bob bob;

    // setUp deploys the Attack contract, which itself deploys Token and Bob and mints a token
    function setUp() public {
        attack = new Attack();
        vulnerableToken = attack.vulnerableToken();
        bob = attack.bob();
    }

    // This test demonstrates the expected behavior in a non-attacker scenario: if the token hasn't been minted,
    // the require in Bob.transfer will revert with "Not owner".
    function testTransferRevertsWhenTokenNotMinted() public {
        // Deploy a new Token contract which has not minted any token
        Token token = new Token();
        
        // Bob.tokenId defaults to 0. Since token 0 is not minted, ownerOf(0) will return false.
        // Calling Bob.transfer should revert.
        vm.expectRevert(bytes("Not owner"));
        bob.transfer(address(token));
    }

    // This test demonstrates the vulnerability exploit. In a correctly implemented contract, transfer would require
    // that msg.sender is the owner of the token. Here, due to the return type mismatch in ownerOf, the check simply
    // verifies that the token exists (i.e., the stored owner address != address(0)).
    // The Attack contract minted token id 1 in the vulnerable Token contract. However, Bob's tokenId is by default 0.
    // An attacker can manipulate Bob.tokenId (since it is a public variable) to point to the minted token id and bypass
    // the genuine ownership check.
    function testAttackExploit() public {
        // The Attack contract minted token id 1 in the vulnerableToken during its constructor.
        // Bob.tokenId is initially 0. We use Foundry's cheat code vm.store to modify the storage slot for Bob.tokenId.
        // Bob.tokenId is the first state variable in Bob, so it's stored at slot 0.
        bytes32 slot = bytes32(uint256(0));
        // Set Bob.tokenId to 1, matching the token minted in Attack.
        vm.store(address(bob), slot, bytes32(uint256(1)));

        // Now, calling attack.attack() will invoke bob.transfer with vulnerableToken's address as parameter.
        // The require in Bob.transfer calls vulnerableToken.ownerOf(1), which checks if _owners[1] != address(0).
        // Since token id 1 has been minted (by Attack, so _owners[1] != address(0)), the check returns true even though it
        // does not verify the actual owner. This demonstrates the vulnerability.
        attack.attack();
    }
}
