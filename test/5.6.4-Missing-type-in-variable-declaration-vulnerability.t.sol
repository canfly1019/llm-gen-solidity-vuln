// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/5.6.4-Missing-type-in-variable-declaration-vulnerability.sol";

contract VulnerableContractTest is Test {
    VulnerableContract public vuln;

    function setUp() public {
        vuln = new VulnerableContract();
    }

    function testAttackReturnsCorrectSum() public {
        // The sum of 0 through 256 inclusive is (256 * 257)/2 = 32896
        int256 expectedSum = 32896;
        int256 result = vuln.attack();
        assertEq(result, expectedSum, "Attack did not return expected sum");
    }

    // Although the vulnerability hint is about the use of an int256 loop counter
    // and potential underflow/overflow issues if negative values are used, the contract
    // as written does not allow for such exploitation. In more complex scenarios, an attacker
    // could potentially provide negative input that might cause logical errors.
    // Here we simulate that the contract calculates with a signed integer, even though the result
    // is as expected given non-negative looping.
    
    function testPotentialUnderflowExploitBehavior() public {
        // In this contract, there is no direct way to provide negative input to the loop
        // or change the behavior of the calculation.
        // That said, we demonstrate that if the compiler had inferred an improper type (int instead of uint),
        // then passing negative values could in theory trigger issues.
        // We therefore assert that in the current design, only the intended non-negative path is executed.

        int256 result = vuln.attack();
        // Verifying that the result is correct and no underflow occurred
        assertTrue(result >= 0, "Result should be non-negative");
    }
}
