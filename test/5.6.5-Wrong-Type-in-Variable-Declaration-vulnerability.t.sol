pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/5.6.5-Wrong-Type-in-Variable-Declaration-vulnerability.sol";

contract VulnerableTest is Test {
    VulnerableSampleBytesArray vulnerable;
    AttackVulnerable attacker;

    function setUp() public {
        vulnerable = new VulnerableSampleBytesArray();
        attacker = new AttackVulnerable(address(vulnerable));
    }

    // Test to ensure that adding a single byte record works correctly
    function testAddSimBytes() public {
        // Add a single byte
        vulnerable.addSimBytes(hex"00");
        
        // Retrieve the first element using the automatic getter
        bytes memory storedData = vulnerable.simBytes(0);
        
        // Assert the stored value is equal to what we pushed
        assertEq(storedData, hex"00", "simBytes[0] should be equal to hex 00");
    }

    // Test demonstrating the vulnerability: repetitive execution of addSimBytes (attack scenario)
    function testAttackAddsMultipleEntries() public {
        uint256 count = 10;
        
        // Execute the attack by calling attack() which in turn calls addSimBytes multiple times
        attacker.attack(count);
        
        // Validate that exactly count number of entries have been added
        for (uint256 i = 0; i < count; i++) {
            bytes memory entry = vulnerable.simBytes(i);
            assertEq(entry, hex"00", "Each entry should be equal to hex 00");
        }
    }

    // Optional: Test to illustrate increased gas usage. Note: Gas measurement in tests can be non-deterministic
    function testGasConsumptionDifference() public {
        // Measure gas usage when calling addSimBytes() directly vs. looping via attack
        uint256 directGasStart = gasleft();
        vulnerable.addSimBytes(hex"00");
        uint256 directGasUsed = directGasStart - gasleft();

        // Removing the first inserted element for a clear test, deploy a fresh instance
        vulnerable = new VulnerableSampleBytesArray();
        attacker = new AttackVulnerable(address(vulnerable));

        uint256 attackGasStart = gasleft();
        attacker.attack(1);
        uint256 attackGasUsed = attackGasStart - gasleft();
        
        // Although both should execute successfully, the gas consumed by the attack path is expected to be higher due to the extra overhead in bytes[] storage
        // This does not revert, but demonstrates inefficiency. We assert that the gas used by attack is not less than direct call.
        assertGe(attackGasUsed, directGasUsed, "Gas consumption via attack should be greater or equal than a direct call");
    }
}
