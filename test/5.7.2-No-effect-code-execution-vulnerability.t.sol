pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/5.7.2-No-effect-code-execution-vulnerability.sol";

contract NoEffectCodeExecutionVulnerabilityTest is Test {
    Attack public attack;

    // Test that deploying the Attack contract deploys B and that B has code
    function testAttackDeployment() public {
        attack = new Attack();
        B vulnerableB = attack.vulnerableB();
        // Check that vulnerableB is a non-zero address
        assertTrue(address(vulnerableB) != address(0), "vulnerableB should have a non-zero address");
        // Check that the code size of vulnerableB is greater than 0
        uint codeSize = address(vulnerableB).code.length;
        assertGt(codeSize, 0, "Code size of vulnerableB should be greater than 0");
    }

    // Test that deploying contract B consumes extra gas due to redundant call to A's constructor
    function testGasUsage() public {
        uint gasBefore = gasleft();
        B bInstance = new B();
        uint gasAfter = gasleft();
        uint gasUsed = gasBefore - gasAfter;

        // Log the gas used for deployment; this is to illustrate that extra (redundant) operations are performed
        // Note: The exact gas used may vary between environments, but we expect it to be non-zero
        emit log_named_uint("Gas used to deploy B (with redundant A() call)", gasUsed);

        // Assert that some gas is consumed (this is a trivial check since any deployment costs gas)
        assertGt(gasUsed, 0, "Deployment should consume non-zero gas");
    }

    // Illustrate potential indirect cost via mass deployment simulation
    function testMultipleDeployments() public {
        uint totalGasUsed = 0;
        uint iterations = 5; // simulate deploying several contracts
        for (uint i = 0; i < iterations; i++) {
            uint startGas = gasleft();
            new B();
            uint gasUsed = startGas - gasleft();
            totalGasUsed += gasUsed;
            emit log_named_uint(string(abi.encodePacked("Deployment ", uint2str(i), " gas used:")), gasUsed);
        }
        emit log_named_uint("Total gas used for multiple deployments", totalGasUsed);
        // The idea is that even a small redundant call in each deployment could add up in aggregate
        assertGt(totalGasUsed, iterations, "Total gas used should be more than the number of iterations");
    }

    // Utility function: convert uint to string
    function uint2str(uint _i) internal pure returns (string memory str) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i % 10));
            bstr[k] = bytes1(temp);
            _i /= 10;
        }
        str = string(bstr);
    }
}
