// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/5.8.1-Undetermined-Program-Version-Prevalence-vulnerability.sol";

// This test demonstrates the vulnerability due to not locking the compiler version.
// The contract PragmaNotLocked is compiled with a lenient pragma (>=0.8.0) and thus can be compiled
// with different compiler versions. An attacker might take advantage of behavior differences between compiler versions.
//
// In this test we simulate a basic exploit by deploying PragmaNotLocked and Attack contracts. The Attack contract's exploit()
// function simply reads the public state variable x from PragmaNotLocked. Under normal conditions, this should always
// return 1. However, if a known version difference exists in an older compiler version, the returned value might differ.


contract PragmaNotLockedTest is Test {
    PragmaNotLocked vulnerable;
    Attack attack;

    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new PragmaNotLocked();
        // Deploy the attack contract pointing to the vulnerable contract
        attack = new Attack(address(vulnerable));
    }

    function testExploitReturnsExpectedValue() public {
        // Execute the exploit function to read the value of x
        uint returnedValue = attack.exploit();

        // Under normal circumstances the value should be 1
        // If the contract is compiled using a specific older compiler with known behavior differences,
        // then returnedValue might differ. In our test environment using ^0.8.0, we expect 1.
        assertEq(returnedValue, 1, "Expected x to be 1. Vulnerability may be exploitable with certain compiler versions.");
    }

    // Additional test to simulate what an attacker might check for.
    // In a real-world scenario, the attacker might attempt to use a different compiler version to trigger unexpected behavior.
    // Here, we simulate that by checking that if x is not equal to 1, then it would be a sign of an anomaly.
    function testDetectAnomaly() public {
        uint xValue = vulnerable.x();

        // If the compiler version or behavior difference had been exploited, this value could be different.
        // We assert that under the current environment (pragma solidity ^0.8.0) the value should be 1.
        if(xValue != 1) {
            // Simulate detection of exploit/anomalous behavior
            revert("Anomaly detected: x is not equal to 1");
        }

        // Otherwise, the system is behaving as expected
        assertEq(xValue, 1, "x should be 1 under normal conditions");
    }
}
