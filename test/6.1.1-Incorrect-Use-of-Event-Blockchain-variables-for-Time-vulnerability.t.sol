pragma solidity ^0.8.0;

// Import Foundry's Test contract from forge-std
import "forge-std/Test.sol";

// Alias the vulnerable contract 'Test' as 'VulnerableTest' to avoid naming collisions with Foundry's Test contract
import { Test as VulnerableTest, Attack } from "../src/6.1.1-Incorrect-Use-of-Event-Blockchain-variables-for-Time-vulnerability.sol";

contract VulnerabilityExploitTest is Test {

    // Test case: When the contract is deployed with an odd block.timestamp, the pay function will transfer 100 wei
    // to the caller via the Attack contract. This demonstrates the vulnerability in using a static deployment timestamp.
    function testAttackWhenTimestampOdd() public {
        // Set block.timestamp to an odd number before deployment
        vm.warp(3);

        // Deploy the vulnerable contract (its 'time' variable is set to 3, which is odd)
        VulnerableTest vulnerable = new VulnerableTest();

        // Fund the vulnerable contract using cheat code so that it has sufficient balance to pay out 100 wei
        vm.deal(address(vulnerable), 200);

        // Deploy the Attack contract using the vulnerable contract's address
        Attack attacker = new Attack(address(vulnerable));

        // Record the initial balance of the attacker contract
        uint initialBalance = address(attacker).balance;

        // Execute the attack which calls vulnerable.pay()
        attacker.attack();

        // Check that the attacker contract received exactly 100 wei
        uint finalBalance = address(attacker).balance;
        assertEq(finalBalance - initialBalance, 100, "Attacker should have received 100 wei");
    }

    // Test case: When the contract is deployed with an even block.timestamp, the pay function should not transfer funds
    function testNoAttackWhenTimestampEven() public {
        // Set block.timestamp to an even number before deployment
        vm.warp(2);

        // Deploy the vulnerable contract (its 'time' variable is set to 2, which is even)
        VulnerableTest vulnerable = new VulnerableTest();

        // Fund the vulnerable contract with sufficient balance
        vm.deal(address(vulnerable), 200);

        // Deploy the Attack contract
        Attack attacker = new Attack(address(vulnerable));

        // Record the initial balance of the attacker contract
        uint initialBalance = address(attacker).balance;

        // Execute the attack which calls vulnerable.pay()
        attacker.attack();

        // No funds should be transferred since time is even
        uint finalBalance = address(attacker).balance;
        assertEq(finalBalance, initialBalance, "Attacker should not receive funds when time is even");
    }

    // Additional test to ensure that if the vulnerable contract does not have enough funds, the transfer reverts
    // We expect a revert in this scenario
    function testAttackRevertsWithoutFunds() public {
        vm.warp(3);
        VulnerableTest vulnerable = new VulnerableTest();

        // Do NOT fund the vulnerable contract, so balance is 0

        // Deploy the Attack contract
        Attack attacker = new Attack(address(vulnerable));

        // Expect the call to revert due to insufficient balance for transfer
        vm.expectRevert();
        attacker.attack();
    }

    // A helper function to allow the test contract to receive Ether, if needed
    receive() external payable {}
}
