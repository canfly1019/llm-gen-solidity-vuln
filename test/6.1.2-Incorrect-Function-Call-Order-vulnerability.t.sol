pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/6.1.2-Incorrect-Function-Call-Order-vulnerability.sol";

contract IncorrectFunctionCallOrderVulnerabilityTest is Test {
    EthTxOrderDependenceMinimal vulnerable;
    AttackExploit attackerContract;
    address owner = address(this);
    address attacker = address(0xBEEF);

    // set up initial funds for testing
    function setUp() public {
        // deploy the vulnerable contract (owner is this contract)
        vulnerable = new EthTxOrderDependenceMinimal();
        
        // fund vulnerable contract by calling setReward as owner with 1 ether
        // Initially, reward is 0, so nothing is transferred out
        uint rewardAmount = 1 ether;
        vulnerable.setReward{value: rewardAmount}();
        // after setReward, vulnerable.reward is set to 1 ether
        assertEq(vulnerable.reward(), rewardAmount);
        
        // Fund the attacker with some ether if necessary
        vm.deal(attacker, 10 ether);
    }

    // Test that an attacker can abuse the call order to claim the reward out of order
    function testAttackExploit() public {
        // deploy the attack contract as attacker
        vm.startPrank(attacker);
        attackerContract = new AttackExploit(address(vulnerable));
        
        // Call attack with a valid submission (e.g., 11) to meet the requirement
        attackerContract.attack(11);
        vm.stopPrank();
        
        // Check that the vulnerable contract now has marked reward as claimed
        assertEq(vulnerable.claimed(), true);
        
        // The reward (1 ether) should have been transferred to the AttackExploit contract
        uint exploitBalance = address(attackerContract).balance;
        assertEq(exploitBalance, 1 ether, "Attack contract should have received the reward");
        
        // Now, simulate the attacker withdrawing the funds from the attack contract
        vm.startPrank(attacker);
        uint attackerBalanceBefore = attacker.balance;
        attackerContract.withdraw();
        vm.stopPrank();
        
        // After withdrawal, attacker's balance should increase by 1 ether
        uint attackerBalanceAfter = attacker.balance;
        assertEq(attackerBalanceAfter - attackerBalanceBefore, 1 ether, "Attacker should have withdrawn the reward");
    }

    // Test that calling claimReward with an invalid submission value reverts
    function testClaimRewardWithInvalidSubmission() public {
        // Try to call claimReward with submission <= 10; should revert with "Submission must be > 10"
        vm.startPrank(attacker);
        vm.expectRevert(bytes("Submission must be > 10"));
        vulnerable.claimReward(10);
        vm.stopPrank();
    }

    // Test that claimReward cannot be called twice
    function testClaimRewardTwice() public {
        // First, attacker successfully calls claimReward
        vm.startPrank(attacker);
        attackerContract = new AttackExploit(address(vulnerable));
        attackerContract.attack(11);
        vm.stopPrank();
        
        // Then, any subsequent call to claimReward should revert because reward is already claimed
        vm.startPrank(attacker);
        vm.expectRevert(bytes("Reward already claimed"));
        vulnerable.claimReward(11);
        vm.stopPrank();
    }

    // Test that owner cannot call setReward after reward has been claimed
    function testSetRewardAfterClaimed() public {
        // First, simulate a valid claim by attacker
        vm.startPrank(attacker);
        attackerContract = new AttackExploit(address(vulnerable));
        attackerContract.attack(11);
        vm.stopPrank();
        
        // Now, if owner (this contract) tries to call setReward, it should revert with "Reward already claimed"
        vm.expectRevert(bytes("Reward already claimed"));
        vulnerable.setReward{value: 1 ether}();
    }

    // fallback receive to support funding transactions in the test
    receive() external payable {}
}
