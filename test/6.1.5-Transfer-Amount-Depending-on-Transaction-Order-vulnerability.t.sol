pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/6.1.5-Transfer-Amount-Depending-on-Transaction-Order-vulnerability.sol";

// This Foundry test demonstrates the vulnerability in AmountSenderVuln contract
// related to transaction ordering, where the final transfer amount depends on
// the ordering of the setAmount operations in the block.

contract TransferOrderVulnTest is Test {
    // Use a helper address for simulating a different actor
    address constant ATTACKER = address(0x1337);
    address constant PROVIDER  = address(0xBEEF);
    address constant RECIPIENT = address(0xCAFE);

    // Allow the test contract to receive Ether
    receive() external payable {}

    // setUp is automatically called before each test
    function setUp() public {
        // Give this test contract sufficient balance
        vm.deal(address(this), 10 ether);
        // Also fund our helper actors
        vm.deal(ATTACKER, 10 ether);
        vm.deal(PROVIDER, 10 ether);
        vm.deal(RECIPIENT, 10 ether);
    }

    // Helper function to fund target contract using Foundry cheatcodes
    function fundTarget(address target, uint amount) internal {
        // Set the balance of the target to amount wei
        vm.deal(target, amount);
    }

    // Test the normal expected behavior when operations occur in the intended order
    // Expected ordering: Provider sets high value and then Recipient sets a small value,
    // so that the final amount used for transfer is low (e.g., 1 wei).
    function testNormalOrdering() public {
        AmountSenderVuln target = new AmountSenderVuln();
        // Fund the target contract with 2000 wei
        fundTarget(address(target), 2000);

        // Simulate the provider and recipient calls in the normal (intended) order
        // Provider (authorized) sets a high transfer amount
        vm.prank(PROVIDER);
        target.setAmountOp2(1000);

        // Then the recipient (authorized) tries to set a lower transfer amount
        vm.prank(RECIPIENT);
        target.setAmountOp1(1);

        // At this point, the last call was setAmountOp1, so final amount should be 1
        uint expectedAmount = target.amount();
        assertEq(expectedAmount, 1, "Normal ordering should result in amount = 1");

        // Record the balance of the RECIPIENT before transfer
        uint initialBalance = RECIPIENT.balance;

        // Now, simulate the recipient triggering the transfer
        vm.prank(RECIPIENT);
        target.setTransferAmount();

        // After transfer, RECIPIENT should receive 1 wei
        uint finalBalance = RECIPIENT.balance;
        assertEq(finalBalance - initialBalance, 1, "Recipient should receive 1 wei in normal ordering");
    }

    // Test the vulnerability scenario where transaction ordering is manipulated
    // Malicious ordering: The recipient's call is executed first, setting a low amount,
    // but then the provider's call is ordered later in the block, overwriting the amount
    // with a high value, so that the final transfer sends 1000 wei instead of 1 wei.
    function testReorderedTransactionsExploit() public {
        AmountSenderVuln target = new AmountSenderVuln();
        // Fund the target contract with 2000 wei
        fundTarget(address(target), 2000);

        // Malicious ordering is simulated here by calling operations in a different order
        // First, the recipient sets a low amount
        vm.prank(RECIPIENT);
        target.setAmountOp1(1);

        // Then, the provider (or malicious actor acting as provider) overwrites the amount
        vm.prank(PROVIDER);
        target.setAmountOp2(1000);

        // Now, the final stored amount is 1000, which is not what the recipient would expect
        uint exploitedAmount = target.amount();
        assertEq(exploitedAmount, 1000, "Exploited ordering should result in amount = 1000");

        // Record the balance of RECIPIENT before transfer
        uint initialBalance = RECIPIENT.balance;

        // The recipient now calls for transfer
        vm.prank(RECIPIENT);
        target.setTransferAmount();

        // The recipient unexpectedly receives 1000 wei
        uint finalBalance = RECIPIENT.balance;
        assertEq(finalBalance - initialBalance, 1000, "Recipient receives 1000 wei due to tx ordering vulnerability");
    }

    // Test the AttackVuln contract to demonstrate that if executed in a single transaction,
    // the intended ordering in its executeAttack function results in a safe outcome (transfer of 1 wei).
    // This illustrates that the vulnerability arises only when multiple transactions in the same block
    // can be re-ordered, not when a single atomic contract call is made.
    function testAttackContractSingleTx() public {
        AmountSenderVuln target = new AmountSenderVuln();
        // Fund the target with 2000 wei
        fundTarget(address(target), 2000);

        // Deploy the AttackVuln contract, which takes the target address in its constructor
        AttackVuln attack = new AttackVuln(payable(address(target)));

        // Record the initial balance of the AttackVuln contract
        uint initialAttackBalance = address(attack).balance;

        // Execute the attack in one transaction
        // Within a single transaction, the calls occur in the order:
        // setAmountOp2(1000) -> setAmountOp1(1) -> setTransferAmount(), resulting in a final amount of 1
        vm.prank(ATTACKER);
        attack.executeAttack();

        // Because executeAttack is atomic, the final amount transferred is 1 wei
        assertEq(address(attack).balance - initialAttackBalance, 1, "Attack contract should only receive 1 wei in single tx execution");
    }

    // Demonstrate the vulnerability in a simulated multi-transaction scenario
    // where the attacker can force a reordering between separate transactions
    // In a real mempool, a malicious miner could order transactions to overwrite the intended amount.
    // For testing, we simulate this by issuing the calls in different transactions.
    function testAttackByReorderingTxs() public {
        AmountSenderVuln target = new AmountSenderVuln();
        // Fund the target with 2000 wei
        fundTarget(address(target), 2000);

        // The victim (recipient) believes that by calling setAmountOp1(1) they will receive only 1 wei.
        vm.prank(RECIPIENT);
        target.setAmountOp1(1);

        // However, a malicious actor (or miner) submits a transaction later in the block that calls setAmountOp2(1000)
        // The victim is unaware of this overwrite.
        vm.prank(PROVIDER);
        target.setAmountOp2(1000);

        // Now, when RECIPIENT calls setTransferAmount, the amount has been maliciously increased to 1000 wei
        uint initialRecipientBalance = RECIPIENT.balance;
        vm.prank(RECIPIENT);
        target.setTransferAmount();
        uint finalRecipientBalance = RECIPIENT.balance;

        // The recipient unexpectedly receives 1000 wei instead of 1 wei
        assertEq(finalRecipientBalance - initialRecipientBalance, 1000, "Recipient receives 1000 wei due to reordering exploit");
    }
}
