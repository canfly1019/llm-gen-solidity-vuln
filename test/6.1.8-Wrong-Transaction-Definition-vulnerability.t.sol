pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/6.1.8-Wrong-Transaction-Definition-vulnerability.sol";

contract WrongTransactionDefinitionVulnerabilityTest is Test {
    VulnerableContract vulnerable;
    Attacker attacker;

    function setUp() public {
        vulnerable = new VulnerableContract();
        attacker = new Attacker();
    }

    // Test that a normal caller (EOA) can successfully call execute() such that the state update holds.
    function testNormalDeposit() public {
        // Setup: Use an externally owned account (EOA) simulation.
        uint depositAmount = 1 ether;
        // Fund the EOA account
        address user = address(1);
        vm.deal(user, depositAmount);

        // Prank as the EOA
        vm.prank(user);
        // The call should succeed because EOA has no fallback that reverts.
        vulnerable.execute{value: depositAmount}();

        // Check that total increases by the deposit amount; note that the inline call sends the funds back to the user (no net Ether transfer),
        // but the state variable is updated before the inline call.
        assertEq(vulnerable.total(), depositAmount);
    }

    // Test that an attacker using a malicious contract is able to force the transaction to revert.
    function testAttackReverts() public {
        // Setup: The attacker contract will try to call the vulnerable contract's execute() by sending Ether.
        uint depositAmount = 1 ether;
        // Ensure the attacker contract has enough balance
        vm.deal(address(attacker), depositAmount);

        // Expect the attack() call to revert with "Attack failed" because the inline external call in execute() tries to send Ether to the attacker,
        // triggering its fallback which reverts.
        vm.expectRevert(bytes("Attack failed"));
        attacker.attack{value: depositAmount}(address(vulnerable));

        // Verify that the state update was reverted due to the inline external call failure
        assertEq(vulnerable.total(), 0);
    }
}
