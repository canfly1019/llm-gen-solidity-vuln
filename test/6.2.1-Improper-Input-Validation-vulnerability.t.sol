// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/6.2.1-Improper-Input-Validation-vulnerability.sol";

contract ImproperInputValidationTest is Test {
    NonPayloadAttackableToken token;
    Attack attacker;

    function setUp() public {
        // deploy token & attacker
        token = new NonPayloadAttackableToken();
        attacker = new Attack(address(token));
        // sanity check initial balance
        assertEq(token.balances(address(this)), 1000);
        assertEq(token.balances(address(attacker)), 0);
    }

    function testLegitimateTransfer() public {
        // a normal transfer of 10
        token.transfer(address(0xBEEF), 10);
        assertEq(token.balances(address(this)), 990);
        assertEq(token.balances(address(0xBEEF)), 10);
    }

    function testOverflowTransferReverts() public {
        // trying to transfer more than balance
        vm.expectRevert(bytes("Insufficient balance"));
        token.transfer(address(0xBEEF), 2000);
    }

    function testShortAddressAttackReverts() public {
        // craft a truncated calldata (remove one byte from the address argument)
        bytes memory full = abi.encodeWithSelector(
            token.transfer.selector,
            address(this),
            uint256(1)
        ); // length = 4 + 32 + 32 = 68
        // create shortData of length 67 (one byte missing)
        bytes memory shortData = new bytes(full.length - 1);
        for (uint i = 0; i < shortData.length; i++) {
            shortData[i] = full[i];
        }

        // the low-level call should revert due to invalid calldata length
        vm.expectRevert();
        attacker.attack(shortData);
    }

    function testFullCalldataAttackSucceeds() public {
        // pre-fund attacker contract so that Attack can pay
        token.transfer(address(attacker), 100);
        assertEq(token.balances(address(attacker)), 100);

        // craft a correct full payload: transfer 50 tokens from Attack to arbitrary recipient
        address victim = address(0xCAFE);
        bytes memory payload = abi.encodeWithSelector(
            token.transfer.selector,
            victim,
            uint256(50)
        );

        // call attack: this low-level .call uses exact-length data
        attacker.attack(payload);

        // after the attack call:
        // Attack (msg.sender) had balance 100, sent 50 to victim
        assertEq(token.balances(address(attacker)), 50);
        assertEq(token.balances(victim), 50);
    }
}
