pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/7.1.2-Integer-Overflow-vulnerability.sol";

contract IntegerOverflowMappingSym1VulnTest is Test {
    IntegerOverflowMappingSym1Vuln vuln;

    function setUp() public {
        vuln = new IntegerOverflowMappingSym1Vuln();
    }

    function testIntegerOverflowVulnerability() public {
        uint256 key = 1;
        
        // Step 1: Set map[key] close to uint256 maximum value (2**256 - 10)
        // We do this by initializing it with (2**256 - 10).
        // type(uint256).max is 2**256 - 1, so initial value = type(uint256).max - 9 == 2**256 - 10
        uint256 initialValue = type(uint256).max - 9;
        vuln.init(key, initialValue);
        
        // Check that the value was set correctly
        uint256 preVal = vuln.map(key);
        assertEq(preVal, initialValue, "Initial value not set correctly");

        // Step 2: Now, perform an addition that will cause an overflow.
        // The contract uses unchecked block to do addition. So, adding 20 will cause:
        // (2**256 - 10) + 20 = 2**256 + 10, which modulo 2**256 equals 10.
        vuln.init(key, 20);
        
        // Calculate expected result after overflow
        uint256 expected = 10;
        uint256 postVal = vuln.map(key);
        
        assertEq(postVal, expected, "Overflow did not wrap-around as expected");
    }
}
