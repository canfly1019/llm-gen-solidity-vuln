pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/7.3.1-Truncation-Bugs-vulnerability.sol";

contract TruncationBugsTest is Test {
    VulnerableContract public vulnerable;
    AttackContract public attacker;

    function setUp() public {
        vulnerable = new VulnerableContract();
        attacker = new AttackContract(payable(address(vulnerable)));
    }

    function testAttackTruncation() public {
        // Use an attack value > uint32 max value (uint32 max = 2^32 - 1 = 4294967295)
        // We'll use 5000000000 wei as an example
        uint256 attackValue = 5000000000;

        // expectedTruncated is computed as the value cast to uint32 (this will truncate to lower 32 bits)
        uint32 expectedTruncated = uint32(attackValue);
        // expected value equals 5000000000 - 4294967296 = 705032704 wei

        // Ensure this test contract has sufficient balance
        vm.deal(address(this), attackValue);

        // Execute the attack from this contract by calling the attack() function
        // Using low-level call to be explicit
        (bool success, ) = address(attacker).call{value: attackValue}(abi.encodeWithSignature("attack()"));
        require(success, "Attack call failed");

        // Retrieve the truncated balance stored in the VulnerableContract
        uint32 actual = attacker.checkTruncatedBalance();

        // Use explicit type conversion to avoid ambiguity in assertEq overloads
        assertEq(uint256(actual), uint256(expectedTruncated), "Truncated balance does not match expected value");
    }
}
