// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/7.3.2-Signedness-Bugs-vulnerability.sol";

contract VulnerableWithdrawTest is Test {
    VulnerableWithdraw vulnerable;
    AttackVulnerable attackContract;

    /// @notice Setup deploys a new VulnerableWithdraw contract and funds it with max ether
    function setUp() public {
        vulnerable = new VulnerableWithdraw();
        // Fund the vulnerable contract with the maximum possible balance so that even a transfer of uint(-1) succeeds
        vm.deal(address(vulnerable), type(uint256).max);
    }

    /// @notice Test the attack that uses a negative number to withdraw an enormous value
    function testAttack() public {
        // Deploy the attack contract with the address of the vulnerable contract
        attackContract = new AttackVulnerable(payable(address(vulnerable)));
        uint256 initialAttackBalance = address(attackContract).balance;

        // Calling attack() sends -1 as an int, which converts to uint(max) and triggers a huge transfer
        attackContract.attack();

        // Calculate the expected amount transferred: uint(-1) is equal to type(uint256).max
        uint256 expectedAmount = type(uint256).max;
        uint256 newAttackBalance = address(attackContract).balance;

        // Check that the attack contract received the full amount
        assertEq(newAttackBalance - initialAttackBalance, expectedAmount);

        // Additionally, verify that the vulnerable contract has recorded the transfer
        bool flag = vulnerable.transferred(address(attackContract));
        assertTrue(flag);
    }

    /// @notice Test that a double withdraw is not allowed from the same address
    function testDoubleWithdraw() public {
        // First withdraw using a safe positive amount (0.5 ether) which is within the allowed range
        vulnerable.withdrawOnce(0.5 ether);

        // Second call from the same address should revert because the transfer flag is already set
        vm.expectRevert();
        vulnerable.withdrawOnce(0.5 ether);
    }

    /// @notice Test that providing a positive amount greater than 1 ether reverts
    function testWithdrawPositiveRevert() public {
        // Passing an amount greater than 1 ether should trigger the revert condition
        vm.expectRevert();
        vulnerable.withdrawOnce(2 ether);
    }

    // Receive function so this contract can accept Ether transfers
    receive() external payable {}
}
