pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.1.2-Owner-Manipulation-vulnerability.sol";

contract VulnerableHOTTOTest is Test {
    VulnerableHOTTO target;
    Attacker attacker;

    function setUp() public {
        // Deploy the vulnerable contract, msg.sender becomes the initial owner
        target = new VulnerableHOTTO();
    }

    function testWithdrawByNonOwnerFails() public {
        // Send 10 ether to target contract
        vm.deal(address(target), 10 ether);

        // Try to withdraw funds from an address that is not the owner.
        // Since the onlyOwner modifier checks msg.sender against owner,
        // and target's owner is still the deployer (this contract),
        // we simulate a different address calling withdraw.
        vm.prank(address(0xBEEF));
        vm.expectRevert("NOT OWNER");
        target.withdraw();
    }

    function testAttackExploit() public {
        // Deposit 10 ether into the vulnerable contract
        vm.deal(address(target), 10 ether);

        // Deploy the attacker contract from a different address
        vm.startPrank(address(0xDEAD));
        attacker = new Attacker(address(target));

        // Record the attacker's starting balance
        uint256 attackerBalanceBefore = address(attacker).balance;

        // Call the attack function, which calls target.HT() to change owner to attacker
        // and then withdraws the funds
        attacker.attack();
        vm.stopPrank();

        // Assert that the vulnerable contract's balance is now zero
        assertEq(address(target).balance, 0, "Target contract should have zero balance after exploit");

        // The funds are transferred to the attacker contract address (as it becomes owner).
        // Check that the attacker receives 10 ether.
        uint256 attackerBalanceAfter = address(attacker).balance;
        assertEq(attackerBalanceAfter - attackerBalanceBefore, 10 ether, "Attacker should receive all withdrawn funds");
    }
}
