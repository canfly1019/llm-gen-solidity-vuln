pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.2.1-Exposed-private-data-vulnerability.sol";

contract VulnerabilityTest is Test {
    OddEven oddEven;

    function setUp() public {
        oddEven = new OddEven();
    }

    // Demonstrate that even though players array is declared private,
    // its data is available on-chain via the storage slots
    function testExposedStorage() public {
        // Simulate player1 participating in the game
        address player1 = address(0xABCD);
        vm.deal(player1, 10 ether);
        
        // player1 calls play with number 42 and sends exactly 1 ether
        vm.prank(player1);
        oddEven.play{value: 1 ether}(42);

        // Since only one play has occurred, the contract state has not been reset, 
        // leaving players[0] data still in contract storage

        // Read the storage slot for players[0].addr which is stored at slot 0
        bytes32 slot0 = vm.load(address(oddEven), bytes32(uint256(0)));
        // Read the storage slot for players[0].number which is stored at slot 1
        bytes32 slot1 = vm.load(address(oddEven), bytes32(uint256(1)));

        // Convert the loaded storage data into proper types
        address storedAddr = address(uint160(uint256(slot0)));
        uint256 storedNumber = uint256(slot1);

        // Assert that the data matches what was sent in the play
        assertEq(storedAddr, player1, "Player address doesn't match");
        assertEq(storedNumber, 42, "Player number doesn't match");
    }

    // This test shows that an attacker can read data before it is cleared
    // even though it is marked as private.
    function testExposedBeforeGameReset() public {
        // Using two players. The game resets after two plays.
        address player1 = address(0x1111);
        address player2 = address(0x2222);
        vm.deal(player1, 10 ether);
        vm.deal(player2, 10 ether);

        // Player1 plays with number 5
        vm.prank(player1);
        oddEven.play{value: 1 ether}(5);

        // The players array now holds one participant.
        // An attacker could read the storage slot for players[0].number
        bytes32 dataBefore = vm.load(address(oddEven), bytes32(uint256(1)));
        uint256 firstNumber = uint256(dataBefore);
        assertEq(firstNumber, 5, "Exposed data not matching the stored value");

        // Now player2 plays, which triggers selectWinner() and resets the state
        vm.prank(player2);
        oddEven.play{value: 1 ether}(4);

        // After resetting, reading players[0] should return default zero values
        bytes32 slot0After = vm.load(address(oddEven), bytes32(uint256(0)));
        bytes32 slot1After = vm.load(address(oddEven), bytes32(uint256(1)));
        
        // Check that the player's address and number have been cleared
        assertEq(uint256(slot0After), 0, "Players[0].addr not reset");
        assertEq(uint256(slot1After), 0, "Players[0].number not reset");
    }

    // Even though the Attack contract does not launch a real exploit on-chain,
    // it demonstrates the intended attack vector, where off-chain, an attacker
    // can call eth_getStorageAt to obtain private data.
    function testAttackContract() public {
        Attack attackContract = new Attack();
        // The attack function is just a dummy view that returns empty bytes32.
        bytes32 result = attackContract.attack(address(oddEven));
        assertEq(result, bytes32(0), "Attack did not return the default value");
    }
}
